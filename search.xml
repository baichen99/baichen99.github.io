<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>408-数据结构常见算法</title>
    <url>/2021/10/06/408-ds-algorithm/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="线性表">线性表</h2>
<h3 id="原地逆置">原地逆置</h3>
<h4 id="链表">链表</h4>
<p>法1：因为头插法获得的顺序是逆序，所以可以利用头插法来实现原地逆置：将头节点取下，一次用头插法插入后面的节点。</p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/IMG_0475.jpg" /></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Reverse</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">  LNode *p, *r;</span><br><span class="line">  p = L-&gt;next;	<span class="comment">// p遍历节点</span></span><br><span class="line">  L-&gt;next = <span class="literal">NULL</span>; <span class="comment">//  头节点摘下</span></span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">    r = p-&gt;next;	<span class="comment">// 指向后继，防止断链</span></span><br><span class="line">		p-&gt;next = L-&gt;next;</span><br><span class="line">    L-&gt;next = p;</span><br><span class="line">    p = r;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> L</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>法2：三个指针pre, p, r，指向前驱、当前节点、后继。</p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/IMG_0476.jpg" /></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Reverse</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">  LNode *p, *pre, *r;</span><br><span class="line">  p = L-&gt;next;</span><br><span class="line">  r = p-&gt;next;</span><br><span class="line">  <span class="keyword">while</span>(r!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">    pre = p;</span><br><span class="line">    p = r;</span><br><span class="line">    r = r-&gt;next;</span><br><span class="line">    p-&gt;next = pre;	<span class="comment">//  逆置</span></span><br><span class="line">  &#125;</span><br><span class="line">  L-&gt;next = p;	<span class="comment">// 处理最后一个节点，因为p在倒数第二个节点时就结束循环了</span></span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="顺序表">顺序表</h4>
<p>交换对称的两个元素，0与n-1对称，i与n-i-1对称。（加起来都为n-1）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp;	<span class="comment">// 用来交换</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;L.length/<span class="number">2</span>; i++) &#123;</span><br><span class="line">    temp = L[i];</span><br><span class="line">    L[i] = L[L.length-i<span class="number">-1</span>];</span><br><span class="line">    L[L.length-i<span class="number">-1</span>] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有序表去重">有序表去重</h3>
<h4 id="顺序表-1">顺序表</h4>
<p>双指针，i指向存储指针遇到不同才+1，j是工作指针每次循环+1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteSame</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;L.length; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(L[i] != L[j]) &#123;</span><br><span class="line">      L[++i] = L[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  L.length = i+<span class="number">1</span>;	<span class="comment">//修改长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="链表-1">链表</h4>
<p>双指针，p指向当前节点，r指向下一个节点，p、r若相同则直接删掉r指向的节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteSame</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">  LNode *p, *r;</span><br><span class="line">  p = L-&gt;next;</span><br><span class="line">  <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    r = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;data == r-&gt;data) &#123;</span><br><span class="line">      p-&gt;next = r-&gt;next;</span><br><span class="line">      <span class="built_in">free</span>(r);	<span class="comment">// 删除重复节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无序表去重">无序表去重</h3>
<p>只需设置一个辅助数组，用哈希表的方式判断元素是否出现过。</p>
<h3 id="找到链表倒数第k个元素">找到链表倒数第k个元素</h3>
<p>双指针，一个先走k步，走到末尾停止。</p>
<h3 id="判断链表是否有环">判断链表是否有环</h3>
<p>快慢指针 王道P44，快慢指针还可以解决“找到链表中间节点”的问题（走一步，走两步）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 统计每个元素的出现次数</span><br><span class="line"></span><br><span class="line">可以引申出问题：查找出现次数超过一半的元素（<span class="number">2013</span>）、找到未出现的最小正整数（<span class="number">2018</span>）</span><br><span class="line"></span><br><span class="line">用哈希表时间最快。</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="keyword">int</span> count[L.length];</span><br><span class="line"><span class="comment">//  初始化次数为0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;L.length; i++) &#123;</span><br><span class="line">  count[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;L.length; i++) &#123;</span><br><span class="line">  count[L[i]] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="找到中间节点">找到中间节点</h3>
<p>使用快慢指针，一个走2步，一个走1步，当一个到头时，另一个边为中间节点</p>
<h3 id="排序">排序</h3>
<h4 id="堆排序">堆排序</h4>
<p>看排序算法笔记</p>
<p><a href="https://baichen99.github.io/2021/08/23/sort-notes/#more">排序效率 | 黑石的技术笔记 (baichen99.github.io)</a></p>
<h4 id="快排">快排</h4>
<p>必须熟练写出来</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pivot = A[low];  <span class="comment">// 第一个为枢轴</span></span><br><span class="line">  <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; A[high] &gt;= pivot) high--;</span><br><span class="line">    A[low] = A[hight];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; A[low] &lt;= pivot) low--;</span><br><span class="line">    A[high] = A[low];</span><br><span class="line">  &#125;</span><br><span class="line">  A[low] = pivot;</span><br><span class="line">  <span class="keyword">return</span> low;   <span class="comment">// 返回枢轴的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuikSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pivot_pos = Partition(A, low, high);</span><br><span class="line">  QuickSort(A, low, pivot_pos<span class="number">-1</span>);</span><br><span class="line">  QuickSort(A, pivot_pos+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二路归并排序">二路归并排序</h4>
<p>引申的问题：合并两个有序列表</p>
<p>时间效率都为<span class="math inline">\(O(m+n)\)</span>，空间效率：若使用辅助数组<span class="math inline">\(O(m+n)\)</span>，链表<span class="math inline">\(O(1)\)</span></p>
<h5 id="顺序表-2">顺序表</h5>
<p><strong>使用辅助数组</strong></p>
<ol type="1">
<li>使用辅助数组C，其大小为A、B大小之和</li>
<li>依次比较A、B元素，将较小的放入C</li>
<li>当一个表遍历结束，要把另一个表剩余元素加入C</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(SqList &amp;A, SqList &amp;B, SqList &amp;C)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, k=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt; A.length &amp;&amp; j &lt; B.length) &#123;</span><br><span class="line">    <span class="keyword">if</span>(A[i] &lt; B[j])</span><br><span class="line">      C[k++] = A[i++];</span><br><span class="line">   	<span class="keyword">else</span></span><br><span class="line">      C[k++] = B[j++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(i &lt; A.length)	C[k++] = A[i++];</span><br><span class="line">  <span class="keyword">while</span>(j &lt; B.length)	C[k++] = B[i++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度和空间复杂度都是<span class="math inline">\(O(m+n)\)</span></p>
<p><strong>不使用辅助数组，原地合并</strong></p>
<p>插入排序的思想，从m开始插入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  <span class="keyword">for</span>(i=m+<span class="number">1</span>; i&lt;m+n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(A[i<span class="number">-1</span>] &lt; A[i]) &#123;</span><br><span class="line">      temp = A[i<span class="number">-1</span>];</span><br><span class="line">      <span class="keyword">for</span>(j=i<span class="number">-1</span>; i&gt;=<span class="number">0</span> &amp;&amp; A[j]&gt;temp; j--)</span><br><span class="line">        A[j+<span class="number">1</span>] = A[j];</span><br><span class="line">      A[j+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于后面n个数据，每次插入复杂度为<span class="math inline">\(O(m)\)</span>，所以时间复杂度为<span class="math inline">\(O(mn)\)</span>，空间复杂度为<span class="math inline">\(O(1)\)</span></p>
<h5 id="链表-2">链表</h5>
<p>注意插入时要采用头插法还是尾插法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(LinkList &amp;A, LinkList &amp;B)</span> </span>&#123;</span><br><span class="line">	LNode *pa = A-&gt;next, *pb = B-&gt;next, *r;</span><br><span class="line">  <span class="comment">// 将A作为结果链表</span></span><br><span class="line">  A-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span>(pa &amp;&amp; pb) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pa-&gt;data &lt;= pb-&gt;data) &#123;</span><br><span class="line">      r = pa-&gt;next;</span><br><span class="line">			<span class="comment">// 采用头插法</span></span><br><span class="line">      pa-&gt;next = A-&gt;next;</span><br><span class="line">      A-&gt;next = pa;</span><br><span class="line">      pa = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      r = pb-&gt;next;</span><br><span class="line">      pb-&gt;next = A-&gt;next;</span><br><span class="line">      A-&gt;next = pb;</span><br><span class="line">      pb = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pa)	<span class="comment">// pa还有剩余，就继续加入A中</span></span><br><span class="line">      pb = pa;</span><br><span class="line">    <span class="keyword">while</span>(pb) &#123;	<span class="comment">// 否则将pb加入A中</span></span><br><span class="line">      r = pb-&gt;next;</span><br><span class="line">      pb-&gt;next = A-&gt;next;</span><br><span class="line">      A-&gt;next = pb;</span><br><span class="line">      pb = r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找">查找</h3>
<h4 id="折半查找">折半查找</h4>
<p>只适用于顺序表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(SeqList L, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low=<span class="number">0</span>, hight=L.length, mid;</span><br><span class="line">  <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">    mid = (high+low)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(L.data[mid] == key)</span><br><span class="line">      <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L.data[mid] &lt; key)</span><br><span class="line">      low = mid+<span class="number">1</span>;</span><br><span class="line">   	<span class="keyword">else</span></span><br><span class="line">      high = mid<span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树">树</h2>
<h3 id="前序遍历">前序遍历</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!T) &#123;</span><br><span class="line">    visit(T);</span><br><span class="line">    PreOrder(T-&gt;leftchild);</span><br><span class="line">    PreOrder(T-&gt;rightchild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历">中序遍历</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!T) &#123;</span><br><span class="line">    PreOrder(T-&gt;leftchild);</span><br><span class="line">    visit(T);</span><br><span class="line">    PreOrder(T-&gt;rightchild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后序遍历">后序遍历</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!T) &#123;</span><br><span class="line">    PreOrder(T-&gt;leftchild);</span><br><span class="line">    PreOrder(T-&gt;rightchild);</span><br><span class="line">    visit(T);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="层次遍历">层次遍历</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IsComplete</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">  Queue Q;</span><br><span class="line">  TreeNode *p;</span><br><span class="line"></span><br><span class="line">  EnQueue(Q, T);</span><br><span class="line">  <span class="keyword">while</span>(!IsEmpty(Q)) &#123;</span><br><span class="line">    DeQueue(Q, p);</span><br><span class="line">    visit(p);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;leftchild)</span><br><span class="line">	    EnQueue(Q, p-&gt;leftchild);</span><br><span class="line">    <span class="keyword">if</span>(-&gt;rightchild)</span><br><span class="line">  	  EnQueue(Q, p-&gt;rightchild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求wpl">求WPL</h3>
<p>递归遍历</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WPL</span><span class="params">(BiTree root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> preOrder(root, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> preOrder(BiTree *T, <span class="keyword">int</span> height) &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> wpl = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(T-&gt;left==<span class="literal">NULL</span> &amp;&amp; T-&gt;right==<span class="literal">NULL</span>)&#123;	<span class="comment">// 叶节点</span></span><br><span class="line">  	wpl += height*T-&gt;weight;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(T-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    wpl += preOrder(T-&gt;left, height+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(T-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    wpl += preOrder(T-&gt;right, height+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> wpl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断完全二叉树">判断完全二叉树</h3>
<p>层次遍历，将所有节点入队 包括空节点，依次出队访问，当访问到空节点时，查看后面是否有非空节点，若有则非完全二叉树。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsComplete</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">  Queue Q;</span><br><span class="line">  TreeNode *p;	<span class="comment">// 暂存出队的二叉树节点</span></span><br><span class="line">  <span class="keyword">if</span>(!T)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">// 空树为完全二叉树</span></span><br><span class="line">  EnQueue(Q, T);</span><br><span class="line">  <span class="keyword">while</span>(!IsEmpty(Q)) &#123;</span><br><span class="line">    DeQueue(Q, p);</span><br><span class="line">    <span class="keyword">if</span>(p) &#123;	<span class="comment">// 非空则将孩子入对</span></span><br><span class="line">      EnQueue(Q, p-&gt;leftchild);</span><br><span class="line">      EnQueue(Q, p-&gt;rightchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;	<span class="comment">// 若空，看之后是否有非空节点。</span></span><br><span class="line">      <span class="keyword">while</span>(!IsEmpty(Q)) &#123;</span><br><span class="line">        DeQueue(Q, p);</span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>另一种方法：从上往下给每个节点编号i并入栈（包括空节点），然后依次出栈，检查第j个出栈的非空节点 是否<strong>i==j</strong>，不过只需要检查最后一个，因为编号最大</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isCompleteTree</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        nodes = [(root, <span class="number">1</span>)]</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nodes):</span><br><span class="line">            node, v = nodes[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                nodes.append((node.left, <span class="number">2</span>*v))</span><br><span class="line">                nodes.append((node.right, <span class="number">2</span>*v+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  nodes[-<span class="number">1</span>][<span class="number">1</span>] == <span class="built_in">len</span>(nodes)</span><br><span class="line"></span><br><span class="line">链接：https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/solution/er-cha-shu-de-wan-quan-xing-jian-yan-by-leetcode/</span><br></pre></td></tr></table></figure></li>
</ul>
<p>因为二叉树的层次遍历也是BFS，这题也可以用BFS来做。</p>
<h3 id="求二叉树高度">求二叉树高度</h3>
<p>递归实现简单。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BTDepth</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">    retrun <span class="number">0</span>;</span><br><span class="line">  ldep = BTDepth(T-&gt;leftchild);</span><br><span class="line">  rdep = BTDepth(T-&gt;rightchild);</span><br><span class="line">  <span class="keyword">if</span>(ldep &gt; rdep)</span><br><span class="line">    <span class="keyword">return</span> ldep+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> rdep+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求二叉树宽度">求二叉树宽度</h3>
<p>已知高度H，定义一个width[H]数组，遍历所有节点，每访问一个节点，将其所在层数+1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="comment">//先序遍历，同时统计各层结点总数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOder</span><span class="params">(BiTree T, <span class="keyword">int</span> level, <span class="keyword">int</span> width[])</span></span>&#123;	<span class="comment">// level是当前层数</span></span><br><span class="line">	<span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	width[level]++; <span class="comment">//根据当前结点所处层数，累加该层结点总数 </span></span><br><span class="line">  PreOder(T-&gt;lchild, level + <span class="number">1</span>, width); <span class="comment">//遍历左子树 			</span></span><br><span class="line">	PreOder(T-&gt;rchild, level + <span class="number">1</span>, width); <span class="comment">//遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeWidth</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> width[H];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;H; i++)	width[i] = <span class="number">0</span>;	<span class="comment">// 初始化	 </span></span><br><span class="line">  </span><br><span class="line">  PreOrder(T, <span class="number">0</span>, width);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 找到最大宽度</span></span><br><span class="line">  <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;H; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(width[i] &gt; max)</span><br><span class="line">      max = width[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图">图</h2>
<h3 id="dfs">DFS</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[vnum];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">从序号为begin的顶点出发，递归深度优先遍历连通图Gp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph Gp, <span class="keyword">int</span> begin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//遍历输出序号为begin的顶点的数据域，并保存遍历信息</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,Gp[begin].data);</span><br><span class="line">	visited[begin] = <span class="literal">true</span>; </span><br><span class="line"> </span><br><span class="line">	<span class="comment">//循环访问当前节点的所有邻接点（即该节点对应的链表）</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=first_vertex(Gp,begin); i&gt;=<span class="number">0</span>; i=next_vertex(Gp,begin,i))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!visited[i])  <span class="comment">//对于尚未遍历的邻接节点，递归调用DFS</span></span><br><span class="line">			DFS(Gp,i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">从序号为begin的节点开始深度优先遍历图Gp，Gp可以是连通图也可以是非连通图</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_traverse</span><span class="params">(Graph Gp,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;NUM;i++)  visited[i] = <span class="literal">false</span>; </span><br><span class="line"> </span><br><span class="line">	DFS(Gp,v);</span><br><span class="line">	<span class="comment">//如果是非连通图，该循环保证每个极大连通子图中的顶点都能被遍历到   </span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NUM;i++)&#123;	    </span><br><span class="line">		<span class="keyword">if</span>(!visited[i])</span><br><span class="line">			DFS(Gp,i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bfs">BFS</h3>
<p>用队列实现，类似于树的层次遍历。</p>
<p>需要设置标记数组，标记是否访问过</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[vnum];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  visited[v] = <span class="literal">true</span>;</span><br><span class="line">  EnQueue(Q, v);</span><br><span class="line">  <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">    DeQueue(Q, v);</span><br><span class="line">    <span class="keyword">for</span>(w=FirstNeighbor(G, v); w&gt;=<span class="number">0</span>; w=NextNeightbor(G, v)) &#123;	<span class="comment">// 邻接表实现</span></span><br><span class="line">      <span class="keyword">if</span>(!visited[w]) &#123;</span><br><span class="line">        visited[w] = <span class="literal">true</span>;</span><br><span class="line">        EnQueue(Q, w);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vum; i++)	visited[i] = <span class="literal">false</span>;</span><br><span class="line">  Queue Q;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vnum; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited[i])</span><br><span class="line">      BFS(G, i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓扑排序判断有环">拓扑排序/判断有环</h3>
<p>indegree记录所有点的入度，将入度为0的节点入队，出队时将其指向的点入度-1，并判断入度是否为0。每出队一个节点，count+1，最后若count&lt;vnum，则说明有环。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TopSort</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line">  Queue Q;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G.vexnum; i++)</span><br><span class="line">    <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)</span><br><span class="line">      EnQueue(Q, i);</span><br><span class="line"> 	</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(!IsEmpty(Q)) &#123;</span><br><span class="line">    DeQueue(Q, i);</span><br><span class="line">    print(i);</span><br><span class="line">    <span class="keyword">for</span>(p=G.vertices[i].firstarc; p; p=p-&gt;nextarc) &#123;</span><br><span class="line">      v = p-&gt;adjvex;</span><br><span class="line">      indegree[v] -= <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(indegree[v] == <span class="number">0</span>)</span><br><span class="line">        EnQueue(Q, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(count &lt; G.vexnum)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;			<span class="comment">// 有环</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找-1">查找</h2>
<h3 id="二分查找">二分查找</h3>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> high=n<span class="number">-1</span>, low=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> mid = (high+low)/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[mid] == key)</span><br><span class="line">    <span class="keyword">if</span>(arr[mid] &lt; key)</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="并查集">并查集</h3>
<h4 id="定义">定义</h4>
<p>采用双亲表示法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> UFSets[SIZE]</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initial</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;SIZE; i++)</span><br><span class="line">    S[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> S[], <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(x&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">    x = S[x];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> S[], <span class="keyword">int</span> r1, <span class="keyword">int</span> r2)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 小树合并到大树</span></span><br><span class="line">  <span class="keyword">if</span>(r1==r2) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(S[r1] &gt; S[r2])&#123;</span><br><span class="line">    S[r1] += S[r2];</span><br><span class="line">    S[r2] = r1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    S[r2] += S[r1];</span><br><span class="line">    S[r1] = r2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找时间复杂度：<span class="math inline">\(O(log_2n)\)</span></p>
<p>合并时间复杂度：<span class="math inline">\(O(1)\)</span></p>
<h4 id="连通分量数判断连通">连通分量数/判断连通</h4>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/Screen%20Shot%202021-10-26%20at%2009.29.50.png" /></p>
<h4 id="判断有环">判断有环</h4>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/Screen%20Shot%202021-10-26%20at%2009.32.07.png" /></p>
<p>图中，第一轮a、b、c合并，第二轮b、c合并时发现b、c已经在同一集合，直接return 1；</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>文件系统</title>
    <url>/2021/10/11/408-file-system/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>磁盘块有几块固定存放信息：</p>
<ul>
<li>第0块：引导块，存放操作系统引导程序</li>
<li>引导块后面<strong>若干个块</strong>，存放FAT表，开机后操作系统自动加载FAT表</li>
<li>FAT表后的块：存放根目录的inode信息，如果有多个磁盘就有多个根目录</li>
</ul>
<p><strong>在Unix下：</strong></p>
<p>磁盘块有几块固定存放信息：</p>
<ul>
<li>第0块：引导块，存放操作系统引导程序</li>
<li>第1块：超级块</li>
<li>第2块：存放位示图。</li>
<li>接下来若干块存放inode节点，</li>
</ul>
<h2 id="打开文件过程">打开文件过程</h2>
<p>系统会在内存中维护一个以打开文件列表，如果打开文的文件不在此列表中，会将该文件的FCB读取到内存，文件信息都存储在FCB中，然后更新已打开文件列表。</p>
<ul>
<li>open 将文件控制信息从外存读入内存</li>
<li>read，根据FCB将文件数据从外存读入内存</li>
</ul>
<h3 id="目录文件">目录文件</h3>
<p>目录的表项：<strong>文件名、文件类型、起始块号、文件大小</strong>、其他（用来实现文件保护等），一行对应一个FCB</p>
<p>目录文件所占块数量：目录项数量*目录项大小/块大小</p>
<p>目录文件太大怎么办：如果目录文件大小超过一个块，从FAT表中取出一块空闲块，分配给他。</p>
<p>从根目录开始查找，要将<code>“/A/Dm”</code>读入内存，过程</p>
<pre><code>1. 因为根目录存放在磁盘固定位置，首先到根目录序寻找A对应的目录项，确定A的起始块号5
2. 到5号物理块中尝试寻找Dm，若找不到则去下一块寻找（下一块物理地址由FAT表确定）。
3. 找到Dm的目录项，就得到了Dm对应的起始物理块号，根据FAT表找其之后的物理块，将其读入内存</code></pre>
<h2 id="文件分配方式">文件分配方式</h2>
<h3 id="连续分配">连续分配</h3>
<p>特点</p>
<h3 id="链接分配">链接分配</h3>
<h4 id="隐式链接">隐式链接</h4>
<h4 id="显式链接fat">显式链接（FAT）</h4>
<p>FAT表项为：下一块块号，<strong>当前块号是隐含的</strong>。</p>
<p>每个FAT表项大小：由磁盘块数决定，根据题目条件确定FAT16就是16bit</p>
<p>FAT表大小：磁盘块数*表项大小</p>
<h2 id="例题">例题</h2>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/%E6%88%AA%E5%B1%8F2021-10-11%20%E4%B8%8B%E5%8D%886.23.31.png" /></p>
<ol start="2" type="1">
<li>因为每个表项2B，所以用16bit表示块，一共有<span class="math inline">\(2^{16}\)</span>个块，FAT大小为<span class="math inline">\(2^{16} \times 2B = 128KB\)</span> 。文件最大长度：FAT不限制文件大小，所以最大文件就是把所有FAT表项分给一个文件<span class="math inline">\(2^{16} \times 4KB = 512MB\)</span></li>
<li>分别在100，106（链式）</li>
<li>访问内存的dir目录文件，查找dir1的簇号48并读入内存，从dir1中找到file1的起始块号100，因为5000B在第二个簇，所以在<strong>FAT中</strong>根据100找到第二块即106号，所以100号其实并没有被访问，访问了48、106</li>
</ol>
<h3 id="访问磁盘次数">访问磁盘次数</h3>
<p>若访问/a/b/c</p>
<ul>
<li><p>访问根目录，若根目录在内存中，不用访问磁盘</p></li>
<li><p>从根目录中读出a文件控制块的磁盘地址，访问磁盘取出读入内存（一次）</p></li>
<li><p>从a的文件控制块中读出b文件控制块的地址，访问磁盘读入内存（两次）</p></li>
<li><p>从b的文件控制块中读出c文件控制块的地址，访问磁盘读入内存（三次）</p></li>
<li><p>若要访问c的某一块位<strong>直接索引</strong>，直接根据索引地址，访问磁盘（四次）</p></li>
</ul>
<h3 id="支持的最大文件长度">支持的最大文件长度</h3>
<p>如果采用混合索引，最大长度为直接索引个数x块大小+一级索引个数x一块能放表项个数x块大小+…</p>
<p>如果采用FAT表，看上面例题</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>文件</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>平均查找长度总结</title>
    <url>/2021/08/17/ASL/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>通用公式 <span class="math display">\[
ASL = \sum^n_{i=1} P_iC_i
\]</span></p>
<h2 id="顺序表">顺序表</h2>
<h3 id="无序">无序</h3>
<p><strong>成功</strong> <span class="math display">\[
ASL = \sum^n_{i=1} \frac{1}{n}i = \frac{n(n+1)}{2n} = \frac{n+1}{2}
\]</span> <strong>失败</strong></p>
<p>对所有元素都进行比较，所以 <span class="math display">\[
ASL = \sum^n_{i=1} \frac{1}{n}n = n
\]</span></p>
<h3 id="有序">有序</h3>
<p>与无序不同的是，不必遍历所有元素也可以知道查找失败</p>
<p><strong>成功</strong></p>
<p>与无序相同 <span class="math display">\[
ASL = \frac{n+1}{2}
\]</span> <strong>失败</strong></p>
<p>n个元素，查找失败的可能性有n+1种，如图，总比较次数为<span class="math inline">\(1+2+...+n+n\)</span></p>
<p><img src="https://raw.githubusercontent.com/baichen99/pics/master/img/IMG_8869.png" /> <span class="math display">\[
ASL = \frac{1+2+..+n+n}{n+1} = \frac{n}{2}+\frac{n}{n+1}
\]</span></p>
<h2 id="折半查找">折半查找</h2>
<p>思想：通过判定树来理解，折半查找<strong>判定树是平衡二叉树</strong>，第l层节点比较次数为l</p>
<p><strong>成功</strong> <span class="math display">\[
ASL = \frac{1}{n}\sum^n_{i=1}l_i = \frac{1}{n}(1\times1+2\times 2 + ... + h \times 2^{h-1}) = \frac{n+1}{n}log_2(n+1)
\]</span> 平衡二叉树中：<span class="math inline">\(h = \lceil log_2(n+1) \rceil\)</span>，查找的时间复杂度为 :<span class="math inline">\(O(log_2(n))\)</span></p>
<p><strong>失败</strong></p>
<p>画出失败节点，方法同上，一般都是给出具体值。</p>
<h2 id="分块查找">分块查找</h2>
<p>设分为b块，每块s个记录。在索引表和块内都是顺序查找，所以 <span class="math display">\[
ASL  = \frac{b+1}{2} + \frac{s+1}{2}
\]</span> 分块查找分组大小最好是<span class="math inline">\(s=\sqrt{n}\)</span></p>
<h2 id="哈希表">哈希表</h2>
<p><strong>成功</strong></p>
<p><strong>失败</strong></p>
<p>看王道301 5。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>数据结构</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF跨站请求伪造</title>
    <url>/2021/01/10/CSRF%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="csrf跨站请求伪造">CSRF跨站请求伪造</h1>
<p>CSRF(Cross Site Request Forgery)是一种攻击者盗用用户身份，在当前<strong>已登录</strong>的Web上执行非本意操作的攻击方法。攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。</p>
<h2 id="原理">原理</h2>
<p><a href="https://zhuanlan.zhihu.com/p/46592479">如何防止CSRF攻击？</a></p>
<p>一个典型的CSRF攻击有着如下的流程：</p>
<ul>
<li>受害者登录<a href="https://link.zhihu.com/?target=http%3A//a.com">http://a.com</a>，并保留了登录凭证（Cookie）。</li>
<li>攻击者引诱受害者访问了<a href="https://link.zhihu.com/?target=http%3A//b.com">http://b.com</a>。</li>
<li><a href="https://link.zhihu.com/?target=http%3A//b.com">http://b.com</a> 向 <a href="https://link.zhihu.com/?target=http%3A//a.com">http://a.com</a> 发送了一个请求：<a href="https://link.zhihu.com/?target=http%3A//a.com/act%3Dxx">http://a.com/act=xx</a>。浏览器会默认携带<a href="https://link.zhihu.com/?target=http%3A//a.com">http://a.com</a>的Cookie。</li>
<li><a href="https://link.zhihu.com/?target=http%3A//a.com">http://a.com</a>接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。</li>
<li><a href="https://link.zhihu.com/?target=http%3A//a.com">http://a.com</a>以受害者的名义执行了act=xx。</li>
<li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让<a href="https://link.zhihu.com/?target=http%3A//a.com">http://a.com</a>执行了自己定义的操作。</li>
</ul>
<h2 id="csrf的特点"><strong>CSRF的特点</strong></h2>
<ul>
<li>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。</li>
<li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。</li>
<li>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。</li>
<li>跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。</li>
</ul>
<p>CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。</p>
<h2 id="防御方法">防御方法</h2>
<ul>
<li><p>阻止不明外域的访问</p></li>
<li><ul>
<li>同源检测</li>
<li>Samesite Cookie</li>
</ul></li>
<li><p>提交时要求附加本域才能获取的信息</p></li>
<li><ul>
<li>CSRF Token</li>
<li>双重Cookie验证</li>
</ul></li>
</ul>
<h3 id="同源检测">同源检测</h3>
<h4 id="验证-http-referer-字段">验证 HTTP Referer 字段</h4>
<p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。 如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p>
<p>问题在于这种方法把安全性都依赖于浏览器来保障，从理论上来讲，这样并不安全。</p>
<h3 id="csrf-token">CSRF Token</h3>
<p>前面讲到CSRF的另一个特征是，攻击者无法直接窃取到用户的信息（Cookie，Header，网站内容等），仅仅是冒用Cookie中的信息。</p>
<p>而CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。</p>
<h4 id="原理-1">原理</h4>
<p>CSRF Token的防护策略分为三个步骤：</p>
<ol type="1">
<li>将CSRF Token输出到页面中</li>
</ol>
<p>首先，用户打开页面的时候，服务器需要给这个用户生成一个Token，该Token通过加密算法对数据进行加密，一般Token都包括随机字符串和时间戳的组合，显然在提交时Token<strong>不能再放在Cookie中</strong>了，否则又会被攻击者冒用。因此，为了安全起见Token最好还是<strong>存在服务器的Session</strong>中，之后在每次页面加载时，使用JS遍历整个DOM树，对于DOM中所有的a和form标签后加入Token。这样可以解决大部分的请求，但是对于在页面加载之后<strong>动态生成</strong>的HTML代码，这种方法就没有作用，还需要程序员在编码时手动添加Token。</p>
<ol start="2" type="1">
<li>页面提交的请求携带这个Token</li>
</ol>
<p>对于GET请求，Token将附在请求地址之后，这样URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上： <code>&lt;input type=”hidden” name=”csrftoken” value=”tokenvalue”/&gt;</code> 这样，就把Token以参数的形式加入请求了。</p>
<ol start="3" type="1">
<li>服务器验证Token是否正确</li>
</ol>
<p>当用户从客户端得到了Token，再次提交给服务器的时候，服务器需要判断Token的有效性，验证过程是先解密Token，对比加密字符串以及时间戳，如果加密字符串一致且时间未过期，那么这个Token就是有效的。</p>
<h3 id="jwt">JWT</h3>
<p><a href="https://segmentfault.com/a/1190000003716037">[如何通过JWT防御CSRF](https://segmentfault.com/a/1190000003716037)</a></p>
<h2 id="参考">参考</h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin">Origin</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referer">Referer</a> <a href="https://developer.ibm.com/zh/articles/1102-niugang-csrf/">CSRF 攻击的应对之道</a> <a href="https://segmentfault.com/a/1190000003716037">CSRF JWT</a> <a href="https://stackoverflow.com/questions/37959945/how-to-destroy-jwt-tokens-on-logout">如何在logout时销毁JWT--在client端删除</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack和vue配合使用</title>
    <url>/2019/11/18/Vuejs%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%92%8C/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="目录结构">目录结构</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── dist  					# 打包后的资源</span><br><span class="line">│   ├── bundle.js  	# 打包后的js文件</span><br><span class="line">│   └── img					</span><br><span class="line">├── index.html			# 最外层文件</span><br><span class="line">├── node_modules		# 模块</span><br><span class="line">├── src							# 源代码，在此编写代码</span><br><span class="line">│   ├── css</span><br><span class="line">│   ├── img</span><br><span class="line">│   ├── js</span><br><span class="line">│   ├── main.js			# </span><br><span class="line">│   └── vue					# 存放vue组件文件</span><br><span class="line">└── webpack.config.js	# 配置</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="代码示例">代码示例</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./app.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    template: <span class="string">&#x27;&lt;App/&gt;&#x27;</span>,</span><br><span class="line">    components: &#123;</span><br><span class="line">        App,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>vue实例中不要写太多代码，把代码都写到<code>*.vue</code>文件中，以模块的方式导入</li>
<li>实例化一个vue对象时，vue会将el选择的节点替换为template的内容</li>
<li><a href="%5Bhttps://cn.vuejs.org/v2/guide/components-registration.html#%E5%B1%80%E9%83%A8%E6%B3%A8%E5%86%8C%5D(https://cn.vuejs.org/v2/guide/components-registration.html#局部注册)">组件注册</a></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123; message &#125;&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;btn&quot;</span> @click=<span class="string">&quot;btnClick&quot;</span>&gt;按钮&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                message: <span class="string">&#x27;hello webpack&#x27;</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            btnClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.message = <span class="string">&quot;changed&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;  </span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        background: url(<span class="string">&#x27;../img/timg.jpeg&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    .btn &#123;</span><br><span class="line">        width: 50px;</span><br><span class="line">        height: 30px;</span><br><span class="line">        background: red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>script标签里的<code>export default</code>是es6的语法，导出默认对象，这样再其他文件中import的时候就不需要知道原模块定义的变量名</p></li>
<li><p><a href="https://www.runoob.com/w3cnote/es6-module.html">ES6模块</a></p></li>
</ul>
<h2 id="插件的使用">插件的使用</h2>
<ol type="1">
<li>npm 下载</li>
<li>webpack.config.js 配置 ### 示例1 打包代码到dist文件夹后，index.html不在文件夹内，那么打包的js文件也没有意义了，现在用<code>HtmlWebpackPlugin</code>插件解决这个问题</li>
<li><code>npm install html-webpack-plugin --save-dev</code></li>
<li>修改<code>webpack.config.js</code>中plugin部分如下 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line">...</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: <span class="string">&#x27;index.html&#x27;</span></span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>template指明根据什么模板来生成index.html</li>
</ul>
<p><a href="https://webpack.docschina.org/plugins/html-webpack-plugin/">HtmlWebpackPlugin</a></p>
<h3 id="示例2">示例2</h3>
<p>使用 <code>UglifyjsWebpackPlugin</code>将打包后的代码进行压缩</p>
<ol type="1">
<li><code>$ npm install uglifyjs-webpack-plugin --save-dev</code></li>
<li>修改<code>webpack.config.js</code>中plugin部分如下</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> UglifyJsPlugin(),</span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://webpack.docschina.org/plugins/uglifyjs-webpack-plugin/">UglifyjsWebpackPlugin</a></p>
<h2 id="开启本地服务器">开启本地服务器</h2>
<p>不用每次写完代码都npm run build，让页面实时刷新</p>
<ol type="1">
<li><code>npm install --save-dev webpack-dev-server</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ... </span><br><span class="line">  devServer: &#123;</span><br><span class="line">      contentBase: <span class="string">&#x27;./dist&#x27;</span>,		<span class="comment">// 把这个文件夹作为</span></span><br><span class="line">      inline: <span class="literal">true</span>,							<span class="comment">// 实时更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><p>输入<code>./node_modules/.bin/webpack-dev-server</code>即可开启，但是这样太麻烦，可以在<code>package.json</code>里配置scripts</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line"></span><br><span class="line">  &quot;dev&quot;: &quot;webpack-dev-server --open&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<ul>
<li>--open 表示用浏览器打开</li>
</ul></li>
</ol>
<h2 id="配置文件的分离">配置文件的分离</h2>
<p>上一个例子中为了实现本地开发服务器配置了一些东西，但是在实际编译的时候不需要，压缩代码的插件UglifyJsPlugin在编译的时候才用到，所以要分离配置文件</p>
<ol type="1">
<li><p><code>npm install --save-dev webpack-merge</code></p></li>
<li><p>根目录新建一个build目录, 新建三个文件 base.config.js dev.config.js prod.config.js 分别存放公共部分配置，开发配置，生产配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// base.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">&#x27;vue-loader/lib/plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>),</span><br><span class="line">        filename: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">          &#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span> ]</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            test: <span class="regexp">/\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class="line">            use: [</span><br><span class="line">              &#123;</span><br><span class="line">                loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    limit: <span class="number">8192</span>,</span><br><span class="line">                    name: <span class="string">&#x27;img/[name].[hash:8].[ext]&#x27;</span>,</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            test: <span class="regexp">/\.m?js$/</span>,</span><br><span class="line">            exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">            use: &#123;</span><br><span class="line">              loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">              options: &#123;</span><br><span class="line">                presets: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">            loader: <span class="string">&#x27;vue-loader&#x27;</span></span><br><span class="line">          &#125;,</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> VueLoaderPlugin(),</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">          template: <span class="string">&#x27;index.html&#x27;</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            <span class="string">&#x27;vue$&#x27;</span>: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dev.config.js</span></span><br><span class="line"><span class="keyword">const</span> webpackMerge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">&#x27;./base.config&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackMerge(baseConfig, &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">        inline: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// prod.config.js</span></span><br><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">&#x27;./base.config&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpackMerge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackMerge(baseConfig, &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> UglifyJsPlugin(),</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>记得修改base.config.js力path中的dist为../dist</li>
</ul></li>
</ol>
<h2 id="代码">代码</h2>
<p><a href="https://github.com/baichen99/webpack_test">github</a></p>
]]></content>
      <categories>
        <category>frontend</category>
      </categories>
      <tags>
        <tag>vuejs</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS跨站脚本攻击</title>
    <url>/2021/01/10/XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="xss">XSS</h1>
<h2 id="定义">定义</h2>
<p>跨站脚本攻击(Cross Site Sript)是指攻击者利用网站对<strong>用户输入过滤不足</strong>，输入内容可以<strong>显示在页面上</strong>对其他人造成影响的HTML代码，利用用户身份进行某种动作，从而完成盗取用户资料、进行病毒侵害的一种攻击方式。为了和层叠样式表(Cascading Style Sheets)的缩写区分，跨站脚本攻击通常简写为XSS。</p>
<h2 id="反射型">反射型</h2>
<p>原理：简单的将用户输入的数据直接或未经过完善的<strong>安全过滤</strong>就在浏览器中进行输出，导致输出的数据中存在可被浏览器执行的代码数据，由于此种类型的跨站代码存在于URL中，所以黑客通常需要诱骗或加密变形等方式将存在恶意代码的链接发给用户，<strong>只有用户点击以后才能使得攻击成功实施</strong>。</p>
<p>假如有个程序是这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 伪代码</span></span><br><span class="line"><span class="meta">@route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">	name = request.args.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span> + name</span><br></pre></td></tr></table></figure>
<p>那么当访问'/?name='Bob'时，网页会显示hello bob。但这个程序对用户输入内容没有过滤和转义，也就是说我们可以将一些js代码写在参数中，这样服务器返回的响应中就会包含着写代码。比如当把name的值改为js代码，也就是访问<code>/?name=&lt;script&gt;alert(1)&lt;/script&gt;</code>的时候，页面执行了<code>alert(1)</code>，然后会出现一个弹窗。所以黑客会把这段url藏到超链接中，然后诱导用户去点击链接，就能完成XSS攻击。</p>
<h2 id="存储型">存储型</h2>
<p>原理：存储型XSS脚本攻击是指由于Web应用程序对用户输入数据的处理不严格，导致Web应用程序将黑客输入的恶意跨站攻击数据信息保存在服务端的数据库或其他文件中，当王爷进行数据查询展示时，会从数据库中获取数据内容，并将数据内容在网页中进行输出展示，进而导致XSS代码执行。</p>
<p>常见场景：留言板、博客、新闻发布系统中，恶意代码的数据信息直接写入文章、评论中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 伪代码</span></span><br><span class="line"><span class="meta">@route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">  <span class="comment"># 返回所有消息</span></span><br><span class="line">	message_list = Message.objects.<span class="built_in">all</span>()</span><br><span class="line">  <span class="keyword">return</span> <span class="number">200</span>, &#123;message_list: message_list&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@route(<span class="params"><span class="string">&#x27;/&#x27;</span>, method=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">	message = request.form.get(<span class="string">&#x27;msg&#x27;</span>)</span><br><span class="line">  <span class="comment"># 数据库中新增一条记录</span></span><br><span class="line">  m = Message(text=message)</span><br><span class="line">  m.save()</span><br><span class="line">  <span class="comment"># 201 表示创建成功</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">201</span></span><br></pre></td></tr></table></figure>
<h2 id="反射型和存储型对比">反射型和存储型对比</h2>
<p>反射型和存储型是根据表现形式来区分的，其实他们的本质都是一样的：网页可以直接显示用户输入的内容。区别在于：存储型xss指的是用户输入内容可以保存在服务器中，可以影响到其他用户的。</p>
<h2 id="预防方法">预防方法</h2>
<ul>
<li>对输入、输出信息进行过滤和转义
<ul>
<li>表单验证，对符合格式的输入允许通过检查。比如邮件地址必须是xx@xx.xx格式，age必须是int类型。</li>
<li>对特殊字符进行过滤：比如HTML中的<code>" ' &lt; &gt; % &amp;</code></li>
</ul></li>
<li>使用<a href="https://blog.csdn.net/qq_38553333/article/details/80055521">HttpOnly</a>, 将重要的cookie标记为httponly，这样的话当浏览器向Web服务器发起请求的时就会带上<code>cookie</code>字段，<strong>但是在<code>js</code>脚本中却不能访问这个cookie</strong>，这样就避免了XSS攻击利用<code>JavaScript</code>的<code>document.cookie</code>获取<code>cookie</code>。</li>
</ul>
<h2 id="参考内容">参考内容：</h2>
<p><a href="https://www.bilibili.com/video/BV1WK411V7Sz">视频演示-XSS跨站脚本漏洞原理</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/37295186">对于跨站脚本攻击（XSS攻击）的理解和总结</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title>cache映射方法</title>
    <url>/2021/06/30/cache-mapping/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>cache和主存交换单位是块</li>
<li>下面的地址结构都是主存地址，因为cpu在访问主存地址时，先根据这个地址在cache找，再再主存中找</li>
</ul>
<p><strong>给定主存地址，如何访存？</strong></p>
<h2 id="直接映射">直接映射</h2>
<p>eg：主存地址空间大小为256MB，按字节编址，数据cache有8个cache行，行长64B。</p>
<ul>
<li>确定主存地址位数：<span class="math inline">\(256M = 2^{28}\)</span>，所以有28位</li>
</ul>
<p>对于直接映射，主存地址结构如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">标记</th>
<th style="text-align: center;">cache行号</th>
<th style="text-align: center;">块内地址</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<ul>
<li><p>行长(块大小)<span class="math inline">\(64B = 2^6B\)</span>，说明行内地址占6位</p></li>
<li><p>cache有<span class="math inline">\(8=2^3个\)</span>，所以cache行号占3位</p></li>
<li><p><strong>标记位数有两种计算方式，一是<span class="math inline">\(28-6-3=19位\)</span>，二是用主存容量/cache容量得到，<span class="math inline">\(256MB/(64B*8) = 2^{19}\)</span>，所以有19位</strong>。（这两种方式本质都一样，除法也只是用指数相减）。</p>
<p>因此，给定一个主存地址，可以将其分为三部分，根据这三部分来寻址，步骤如下：</p>
<ol type="1">
<li>根据行号找到cache对应行，检查标记与cache行标记是否一致</li>
<li>若一致，且有效位为1，则命中</li>
<li>若不一致或有效位为0，则不命中</li>
</ol></li>
</ul>
<h2 id="全相连映射">全相连映射</h2>
<p>主存每一块可以装入cache任何位置</p>
<p><strong>主存地址如下</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">标记</th>
<th style="text-align: center;">块内地址</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<ul>
<li>标记为<strong>主存块号</strong>，其长度为主存地址长度</li>
<li>块内地址长度为<span class="math inline">\(log_2(块大小)\)</span></li>
</ul>
<p>过程：根据主存地址，取出其标记部分，<strong>然后对cache中所有块的标记进行比较</strong></p>
<h2 id="组相连映射">组相连映射</h2>
<p>将cache分成多个组，<strong>主存的数据块可以装入组内的任何一个位置</strong>，即组间直接映射，组内全相连映射</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">标记</th>
<th style="text-align: center;">组号</th>
<th style="text-align: center;">块内地址</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<ul>
<li>若cache行个数=<span class="math inline">\(2^n\)</span>，行号长度为n</li>
<li>块内地址根据块大小计算</li>
<li><span class="math inline">\(标记长度=主存地址长度-cache行号长度-块内地址长度\)</span>，只能通过算其他两项来计算长度</li>
</ul>
<p>过程：根据组号找到cache组，将组中每个行与标记比较</p>
<h2 id="总结">总结</h2>
<ul>
<li><p>直接映射和组相连映射主存结构相同</p></li>
<li><p><strong>三种映射方式的标记长度计算方法不同</strong></p></li>
<li><p>cache地址结构为：<strong>行号+块内地址</strong>，知道cache大小可以直接得知其地址长度，比如Cache行大小为16KB，可知其<strong>行号+块内地址</strong>长度为14。</p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/%E6%88%AA%E5%B1%8F2021-09-07%20%E4%B8%8B%E5%8D%882.45.35.png" /></p></li>
<li><p>主存地址除掉低位的块内地址部分，就是主存块号</p></li>
<li><p>cache块=标记位+数据位。</p></li>
<li><p><strong>标记项</strong>包括有效位、<strong>标记位</strong>tag、一致性维护位(脏位)、替换算法控制位/有效位（1位）。标记项长度一般用<strong>主存地址长度-组号-块内地址</strong>算得。</p></li>
<li><p>如果使用写回法，必须设置一个脏位，全写法则不用（王道组原P149.12）。</p></li>
<li><p>若采用随机替换算法不需要额外标记位。 如果使用LRU，每组/行需要设置1个LRU位 （真题 2018 44</p></li>
</ul>
]]></content>
      <categories>
        <category>计算机组成原理</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>cache</tag>
        <tag>映射</tag>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>cnn笔记</title>
    <url>/2021/04/20/cnn-notes/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="基本概念">基本概念</h2>
<p>假设输入图像为(39x39x3)，卷积层的参数如下：</p>
<ul>
<li><span class="math inline">\(n_H = n_W = 39\)</span></li>
<li>信道数量（number of channels）：<span class="math inline">\(n_c = 3\)</span></li>
<li>卷积核大小：<span class="math inline">\(f = 3\)</span></li>
<li>步长stride：<span class="math inline">\(s = 1\)</span></li>
<li>padding：<span class="math inline">\(p = 0\)</span></li>
<li>过滤器数量：<span class="math inline">\(10 filters\)</span></li>
</ul>
<p>得到结果为(37x37x10)。37通过公式：<span class="math inline">\(\frac{n+2p-f}{s} + 1\)</span>计算得来。</p>
<blockquote>
<p>对于3D卷积，卷积核大小为<span class="math inline">\(f\times f \times n_c\)</span>，图像通道数=filter通道数。卷积后<span class="math inline">\(n_c = 1\)</span></p>
</blockquote>
<h3 id="池化层">池化层</h3>
<p>Max Pooling：在卷积核范围内找到最大值作为输出。</p>
<p>eg: <span class="math inline">\(\begin{pmatrix} 1&amp;3&amp;2&amp;1\\2&amp;9&amp;1&amp;1\\1&amp;3&amp;2&amp;3\\5&amp;6&amp;1&amp;2 \end{pmatrix}\)</span>在经过<span class="math inline">\(f=s=2\)</span>的max pooling池化层之后为<span class="math inline">\(\begin{pmatrix}9&amp;2\\6&amp;3\end{pmatrix}\)</span></p>
<p>池化层输出大小也可以用上面的公式计算。也就是<span class="math inline">\((\lfloor \frac{n_H-f}{s}+1 \rfloor , \lfloor \frac{n_W-f}{s}+1 \rfloor , n_c)\)</span></p>
<h3 id="权值共享">权值共享</h3>
<p><a href="https://www.zhihu.com/question/47158818">权值共享理解</a></p>
<ul>
<li>减少参数</li>
<li>由于<strong>图片的底层特征是与特征在图片中的位置无关的</strong>，所以可用权值共享。底层特征比如边缘，要检测边缘肯定是对全局进行检测，与位置没有关系。高级特征一般是与位置有关的，比如一张人脸图片，眼睛和嘴位置不同，那么处理到高层，不同位置就需要用不同的神经网络权重，这时候卷积层就不能胜任了，就需要用局部全连接层和全连接层。</li>
</ul>
<h2 id="经典网络">经典网络</h2>
<h3 id="lenet-5">LeNet-5</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">层</th>
<th style="text-align: center;">输入大小</th>
<th style="text-align: center;">f</th>
<th style="text-align: center;">filter个数</th>
<th style="text-align: center;">输出大小</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">卷积层C1</td>
<td style="text-align: center;">32x32x1</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">28x28x6</td>
</tr>
<tr class="even">
<td style="text-align: center;">池化层S2(avg pool)</td>
<td style="text-align: center;">28x28x6</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">14x14x6</td>
</tr>
<tr class="odd">
<td style="text-align: center;">卷积层C3</td>
<td style="text-align: center;">14x14x6</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">16</td>
<td style="text-align: center;">10x10x16</td>
</tr>
<tr class="even">
<td style="text-align: center;">池化层S4(avg pool)</td>
<td style="text-align: center;">5x5x6</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">5x5x16</td>
</tr>
</tbody>
</table>
<p>全连接层FC5, 120个神经元。</p>
<p>全连接层FC6, 84个神经元。</p>
<p>最后一层softmax层，输出10种结果(0-9)。</p>
<p><strong>总结：</strong></p>
<ol type="1">
<li>卷积层后接一个池化层。</li>
<li>层数越深<span class="math inline">\(n_H, n_W\)</span>减少, <span class="math inline">\(n_c\)</span>增加</li>
</ol>
<h3 id="alexnet">AlexNet</h3>
<p><img src="https://raw.githubusercontent.com/baichen99/pics/master/img/%E6%88%AA%E5%B1%8F2021-04-20%20%E4%B8%8B%E5%8D%886.46.36.png" /></p>
<h3 id="vgg64">VGG64</h3>
<p><img src="https://raw.githubusercontent.com/baichen99/pics/master/img/%E6%88%AA%E5%B1%8F2021-04-20%20%E4%B8%8B%E5%8D%886.57.47.png" /></p>
<h2 id="使用keras编写cnn">使用keras编写CNN</h2>
<p><a href="http://nooverfit.com/wp/keras-手把手入门1-手写数字识别-深度学习实战/">keras-手把手入门1-手写数字识别-深度学习实战</a></p>
<p><a href="https://www.zhihu.com/question/32673260">深度学习中的batch的大小对学习效果有何影响？</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout, Flatten</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Conv2D, MaxPooling2D</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"></span><br><span class="line"><span class="comment"># batch_size 太小会导致训练慢，过拟合等问题，太大会导致欠拟合。所以要适当选择</span></span><br><span class="line">batch_size = <span class="number">128</span></span><br><span class="line"><span class="comment"># 0-9手写数字一个有10个类别</span></span><br><span class="line">num_classes = <span class="number">10</span></span><br><span class="line"><span class="comment"># 12次完整迭代，差不多够了</span></span><br><span class="line">epochs = <span class="number">12</span></span><br><span class="line"><span class="comment"># 输入的图片是28*28像素的灰度图</span></span><br><span class="line">img_rows, img_cols = <span class="number">28</span>, <span class="number">28</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练集，测试集收集非常方便</span></span><br><span class="line">(x_train, y_train), (x_test, y_test) = mnist.load_data()</span><br><span class="line">print(x_train.shape, y_train.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (60000, 28, 28) -&gt; (60000, 28, 28, 1)</span></span><br><span class="line">(x_train, y_train), (x_test, y_test) = mnist.load_data()</span><br><span class="line"><span class="comment"># https://stackoverflow.com/questions/49057149/expected-conv2d-1-input-to-have-shape-28-28-1-but-got-array-with-shape-1-2</span></span><br><span class="line"><span class="keyword">if</span> K.image_data_format() == <span class="string">&#x27;channels_first&#x27;</span>:</span><br><span class="line">    x_train = x_train.reshape(x_train.shape[<span class="number">0</span>], <span class="number">1</span>, img_rows, img_cols)</span><br><span class="line">    x_test = x_test.reshape(x_test.shape[<span class="number">0</span>], <span class="number">1</span>, img_rows, img_cols)</span><br><span class="line">    input_shape = (<span class="number">1</span>, img_rows, img_cols)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    x_train = x_train.reshape(x_train.shape[<span class="number">0</span>], img_rows, img_cols, <span class="number">1</span>)</span><br><span class="line">    x_test = x_test.reshape(x_test.shape[<span class="number">0</span>], img_rows, img_cols, <span class="number">1</span>)</span><br><span class="line">    input_shape = (img_rows, img_cols, <span class="number">1</span>)</span><br><span class="line">input_shape = (img_rows, img_cols, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">x_train = x_train.astype(<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">x_test = x_test.astype(<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line"><span class="comment"># 归一化</span></span><br><span class="line">x_train /= <span class="number">255</span></span><br><span class="line">x_test /= <span class="number">255</span></span><br><span class="line">print(<span class="string">&#x27;x_train shape:&#x27;</span>, x_train.shape)</span><br><span class="line">print(x_train.shape[<span class="number">0</span>], <span class="string">&#x27;train samples&#x27;</span>)</span><br><span class="line">print(x_test.shape[<span class="number">0</span>], <span class="string">&#x27;test samples&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换成one-hot编码</span></span><br><span class="line">y_train = keras.utils.to_categorical(y_train, num_classes)</span><br><span class="line">y_test = keras.utils.to_categorical(y_test, num_classes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 牛逼的Sequential类可以让我们灵活地插入不同的神经网络层</span></span><br><span class="line">model = Sequential()</span><br><span class="line"><span class="comment"># 加上一个2D卷积层， 32个filters，激活函数选用relu，</span></span><br><span class="line"><span class="comment"># 卷积核的窗口选用3*3像素窗口</span></span><br><span class="line">model.add(Conv2D(<span class="number">32</span>,</span><br><span class="line">                 kernel_size=<span class="number">3</span>,</span><br><span class="line">                 activation=<span class="string">&#x27;relu&#x27;</span>,</span><br><span class="line">                 input_shape=(<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)))</span><br><span class="line"><span class="comment"># 64个通道的卷积层</span></span><br><span class="line">model.add(Conv2D(<span class="number">64</span>,</span><br><span class="line">                 kernel_size=<span class="number">3</span>,</span><br><span class="line">                 activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line"><span class="comment"># 池化层是2*2像素的</span></span><br><span class="line">model.add(MaxPooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"><span class="comment"># 对于池化层的输出，采用0.35概率的Dropout</span></span><br><span class="line">model.add(Dropout(<span class="number">0.35</span>))</span><br><span class="line"><span class="comment"># 展平所有像素，比如[28*28] -&gt; [784]</span></span><br><span class="line">model.add(Flatten())</span><br><span class="line"><span class="comment"># 对所有像素使用全连接层，输出为128，激活函数选用relu</span></span><br><span class="line">model.add(Dense(<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line"><span class="comment"># 对输入采用0.5概率的Dropout</span></span><br><span class="line">model.add(Dropout(<span class="number">0.5</span>))</span><br><span class="line"><span class="comment"># 对刚才Dropout的输出采用softmax激活函数，得到最后结果0-9</span></span><br><span class="line">model.add(Dense(num_classes, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line"><span class="comment"># 模型我们使用交叉熵损失函数，最优化方法选用Adadelta</span></span><br><span class="line">model.<span class="built_in">compile</span>(loss=keras.metrics.categorical_crossentropy,</span><br><span class="line">              optimizer=keras.optimizers.Adadelta(),</span><br><span class="line">              metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 令人兴奋的训练过程</span></span><br><span class="line">model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs,</span><br><span class="line">          verbose=<span class="number">1</span>, validation_data=(x_test, y_test))</span><br><span class="line"></span><br><span class="line">score = model.evaluate(x_test, y_test, verbose=<span class="number">0</span>)</span><br><span class="line">print(<span class="string">&#x27;Test loss:&#x27;</span>, score[<span class="number">0</span>])</span><br><span class="line">print(<span class="string">&#x27;Test accuracy:&#x27;</span>, score[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>cnn</tag>
        <tag>卷积神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 数组传参</title>
    <url>/2018/11/08/cppshuzuchuancan/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><strong>在C/C++中，在进行数组传参时，c虽然传递的是收地址，但是在函数内部就成了普通指针，不是数组首地址了，所以在函数里得到数组长度是不可以的，所以函数参数中有数组时一般要传入数组大小</strong></p>
<h3 id="错误示范">错误示范</h3>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLen</span><span class="params">(<span class="keyword">int</span> *arr)</span></span></span><br><span class="line">return sizeof(arr)/sizeof(*a);</span><br></pre></td></tr></table></figure>
<h3 id="正确例子">正确例子</h3>
<ol type="1">
<li><p><code>void func(int *a, int length)&#123;&#125;</code></p></li>
<li><p><code>void func(int a[length]</code></p></li>
<li><p><code>void func(int a[], int length)&#123;&#125;</code></p></li>
</ol>
<h3 id="参考文章">参考文章</h3>
<p><a href="https://www.cnblogs.com/spring-hailong/p/6110685.html">C/C++数组传参</a> <a href="https://blog.csdn.net/u013025203/article/details/54379104">C/C++数组参数传递后，还能计算长度吗？</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>crnn-ctc</title>
    <url>/2021/04/23/crnn-ctc/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="ctc">CTC</h2>
<p><a href="https://xiaodu.io/ctc-explained/">CTC算法详解</a></p>
<p>CTC（Connectionist Temporal Classification）算法，它可以让RNN直接对序列数据进行学习，而无需事先标注好训练数据中输入序列和输出序列的映射关系，打破了RNN应用于语音识别、手写字识别等领域的数据依赖约束，使得RNN模型在序列学习任务中取得更好的应用效果。</p>
<p><a href="https://blog.csdn.net/qq_38410428/article/details/91381151">端到端模型（end-to-end learning）</a></p>
<p>在序列学习任务中，RNN模型对训练样本一般有这样的依赖条件：输入序列和输出序列之间的映射关系已经事先标注好了。由于输入序列和输出序列是一一对应的，所以RNN模型的训练和预测都是端到端的，即可以根据输出序列和标注样本间的差异来直接定义RNN模型的Loss函数，传统的RNN训练和预测方式可直接适用。</p>
<p>但有些数据，比如音频数据，天然难以分割，在大规模训练下这种数据要求是完全不切实际的。而如果输入序列和输出序列之间映射关系没有提前标注好，那传统的RNN训练方式就不能直接适用了，无法直接对音频数据和图像数据进行训练。</p>
<p><img src="https://raw.githubusercontent.com/baichen99/pics/master/img/r2.png.webp" /></p>
<p>Connectionist Temporal Classification（CTC）[1]是Alex Graves等人在ICML 2006上提出的一种端到端的RNN训练方法，它可以让RNN直接对序列数据进行学习，而无需事先标注好训练数据中输入序列和输入序列的映射关系，使得RNN模型在语音识别等序列学习任务中取得更好的效果。</p>
<p><a href="https://zhuanlan.zhihu.com/p/42719047">ctc原理</a></p>
<h2 id="代码">代码</h2>
<p><a href="https://keras.io/examples/vision/captcha_ocr/#model">OCR model for reading Captchas</a></p>
]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>cnn</tag>
        <tag>crnn</tag>
        <tag>ctc</tag>
      </tags>
  </entry>
  <entry>
    <title>css笔记</title>
    <url>/2021/08/25/css-notes/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="css">css</h2>
<h3 id="伪元素和伪类">伪元素和伪类</h3>
<p><a href="https://segmentfault.com/a/1190000015468617">伪元素 ::after 和 ::before 应该这么用（一） - SegmentFault 思否</a></p>
<h3 id="clip-path">clip-path</h3>
<p><a href="https://segmentfault.com/a/1190000010936207">不可思议的CSS之clip-path - SegmentFault 思否</a></p>
<h3 id="blend-mode-混合模式正片叠底等">blend-mode 混合模式（正片叠底等）</h3>
<p>https://www.bilibili.com/video/BV1Qt411G7Xo</p>
<p>正片叠底就是multiply，常用黑色图像(全0)与其他图像进行multiply，从而完成遮罩的效果。如果使用<code>rgba(0, 0, 0, 0.4)</code>与原图进行正片叠底混合，原图会变暗。</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>考研笔记：数据的表示与运算</title>
    <url>/2021/06/26/data-rep-opr/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="各种码的转换">各种码的转换</h2>
<p>原-&gt;补：符号为不变，右边开始数，第一个1后面的数字都变号</p>
<p>补-&gt;原：同上</p>
<p>移-&gt;补：符号位取反</p>
<p>[x]补-&gt;[-x]补:右边开始数，第一个1后面的数字都变号，包括符号位</p>
<h2 id="特殊二进制数">特殊二进制数</h2>
<p>n位全1=<span class="math inline">\(2^n-1\)</span>，如1111=15</p>
<p>最高位为1，其余全为0=<span class="math inline">\(2^{n-1}\)</span>，如1000=<span class="math inline">\(2^3=8\)</span></p>
<p>采用补码表示时，数值位越大，码值越大。如1011&lt;1101</p>
<pre><code>-  如1.abcd需要满足什么条件才可以&lt;-1/2? $-\frac&#123;1&#125;&#123;2&#125;$对应的补码为1.1000，数值部分比1000小，条件为a为0，其余任意。
-  参考[再谈二进制补码 - sinkinben](https://www.cnblogs.com/sinkinben/p/12377232.html)</code></pre>
<h2 id="范围">范围</h2>
<h3 id="补码">补码</h3>
<p>假设补码一共有n位。原码和补码都有一位符号位，所以只有n-1位可以表示数值大小。</p>
<p>因为原码中有+0，-0之分，所以其取值范围为<span class="math inline">\([-(2^{n-1}-1), 2^{n-1}-1]\)</span></p>
<p>对于补码，认为其只有+0，因此-0(即10000)空余出来，<strong>规定</strong>其表示最小负数<span class="math inline">\(-2^{n-1}\)</span>其最大值和原码一样，因此补码的范围是<span class="math inline">\([-2^{n-1}, 2^{n-1}-1]\)</span></p>
<p>例子1：对于定点数，原码最小值为1.11111，转为补码为1.000001， 但这不是最小负数，最小负数是人为规定的1.00000</p>
<p>例子2：如果用8位表示补码整数，其范围是<span class="math inline">\([-128, 127]\)</span></p>
<h3 id="移码">移码</h3>
<p>只有一个+0，范围是<span class="math inline">\([-2^n, 2^n-1]\)</span></p>
<p>移码转补码：</p>
<ul>
<li>符号位取反</li>
</ul>
<p>求移码真值：</p>
<ul>
<li>将移码看作无符号数，将其真值减去偏置<span class="math inline">\(2^{n-1}\)</span>，如0000 0000对应真值为<span class="math inline">\(0-2^7=-128\)</span></li>
</ul>
<h2 id="浮点数的范围">浮点数的范围</h2>
<h3 id="ieee-754-float">IEEE 754 float</h3>
<p>以IEEE 754为例，其格式如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">数符</th>
<th style="text-align: center;">阶码</th>
<th style="text-align: center;">尾数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">位数</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">23(补码)</td>
</tr>
</tbody>
</table>
<p>最大正数：</p>
<ul>
<li>阶码：8位能表示的范围是0-255，<strong>去掉最高和最低位</strong>范围是1-254，减去偏置<code>2^&#123;8-1&#125;-1=127</code>范围是-126-127。</li>
<li>尾数：注意隐含位1，其他为全为1，根据n项和求和公式可得尾数最大为<span class="math inline">\(1+\frac{1}{2} + ... + (\frac{1}{2})^{23} = \frac{1\times (1-2^{-24}) }{1- 1/2} = 2 - 2^{-23}\)</span></li>
</ul>
<p>所以最大正数为<span class="math inline">\(2^{127} \times (2-2^{-23})\)</span></p>
<p>最小正数：</p>
<ul>
<li>阶码最小为-126</li>
<li>尾数最小为1.0</li>
</ul>
<p>所以最小正数为<span class="math inline">\(1.0 \times 2^{-126}\)</span></p>
<h3 id="题目中给定格式">题目中给定格式</h3>
<p>如：7位阶码，1位数符，8位尾数，阶码用移码，尾数用补码，求表示范围：</p>
<p>分析：</p>
<ul>
<li>7位无符号数，其表示范围为<span class="math inline">\(0-127\)</span>，减去偏置<span class="math inline">\(2^{6} = 64\)</span>，范围是-64~63</li>
<li>尾数为8位补码，首先在定点数补码中，将<code>1.0000</code>规定位最小负数代表-1，最大正数为8位全1，即<span class="math inline">\(1-2^{-8}\)</span></li>
</ul>
<p>因此表示范围为<span class="math inline">\([-2^{63}, (1-2^{-8})\times 2^{63}]\)</span></p>
<p>注意：</p>
<ul>
<li><p>IEEE 754中有隐含位，其他情况不考虑</p></li>
<li><p>IEEE 754中移码偏置为<span class="math inline">\(2^{r-1}-1\)</span>，而其他情况偏置为<span class="math inline">\(2^{r-1}\)</span></p></li>
<li><p>规格化后的浮点数范围看王道书P65</p></li>
</ul>
<h2 id="移位补什么">移位补什么</h2>
<h3 id="算术移位">算术移位</h3>
<p>原码：左移右移都补0</p>
<p>反码：左移右移补符号位</p>
<p><strong>补码：</strong>正数跟原码一样，均补0。负数：左移补0，右移补1</p>
<blockquote>
<p>回想负数原码转补码，是将第一个1左边取反，因此可以将“1”看作分界线，“1”左边位反码，右边位原码。当负数补码左移，右边有空位，按照原码的方式补0，右移时，左边有空位，按照反码的方式补1</p>
</blockquote>
<h3 id="逻辑移位">逻辑移位</h3>
<p>补0</p>
]]></content>
      <categories>
        <category>计算机组成原理 cvb c</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
        <tag>二进制</tag>
        <tag>补码</tag>
      </tags>
  </entry>
  <entry>
    <title>docker笔记</title>
    <url>/2021/02/21/docker-notes/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="常用命令">常用命令</h2>
<h3 id="后台运行">后台运行</h3>
<ol type="1">
<li>首先可以<code>docker run -it &lt;image_id&gt; bash</code>，在容器运行bash。</li>
<li>如果想退出docker但是不停止容器，可以按ctrl+p+q来退出</li>
<li>如果想回到容器继续执行指令，<code>docker attatch &lt;container_id&gt;</code></li>
<li>也可以通过<code>docker exec -it &lt;container_id&gt; bash</code> 在容器中执行bash，并分配一个tty，将tty的STDIN绑定到容器的标准输入上，这样你输入的命令就会传送到容器的bash中执行。</li>
</ol>
<h3 id="挂载文件夹">挂载文件夹</h3>
<ol type="1">
<li><p>运行之前挂载 <code>docker run -v /src:/dest&lt;image&gt; &lt;command&gt;</code></p>
<p>如果只有一个地址<code>docker run -v /test ...</code>Docker 就会默认在宿主机 上创建一个临时目录 /var/lib/docker/volumes/[VOLUME_ID]/_data，然后把它挂载到容器的 /test 目录上。</p></li>
<li><p>通过修改配置来挂载 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop docker.service</span><br><span class="line">vim /var/lib/docker/containers/container-ID/config.v2.json</span><br><span class="line">systemctl start docker.service</span><br><span class="line">docker start &lt;container-name/ID&gt;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<blockquote>
<p>挂载的目录下的内容，不会被docker commit提交，但是目录本身会出现在新的image中</p>
</blockquote>
<h2 id="dockerfile">dockerfile</h2>
<h3 id="设置时区">设置时区</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUN ln -sf &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime</span><br><span class="line">RUN echo &#39;Asia&#x2F;Shanghai&#39; &gt;&#x2F;etc&#x2F;timezone</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/linjiqin/p/10607800.html">Dockerfile 时区设置</a></p>
<h3 id="cmd和entrypoint区别">CMD和Entrypoint区别</h3>
<p>CMD用来指定容器启动的默认命令和参数。其格式为<code>CMD ['指令', '参数']</code>，可以在docker run的时候对其进行替换。</p>
<p>Entrypoint也是为了指定容器启动的默认命令和参数，但是不同之处在于，当指定了Entrypoint，会将CMD内容作为参数传给Entrypoint，也就是<code>&lt;ENTRYPOINT&gt; "&lt;CMD&gt;"</code>，这样的好处是<strong>可以在docker run 的时候可以传参数给启动命令</strong></p>
<p>举例：假如有<code>CMD [ "curl", "-s", "http://myip.ipip.net" ]</code>，那么在运行<code>docker run &lt;image&gt;</code>便可以获取到运行结果，但并不允许加入curl的参数，比如不能<code>docker run &lt;image&gt; -i</code>。但如果有Entrypoint，你在启动容器时输入的参数可以拼接到Entrypoint后面，比如<code>ENTRYPOINT [ "curl", "-s", "http://myip.ipip.net" ]</code>，你可以这样调用：<code>docker run &lt;image&gt; -i</code></p>
<p><strong>参考：</strong></p>
<p><a href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html">curl 的用法指南 - 阮一峰的网络日志 (ruanyifeng.com)</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/entrypoint">ENTRYPOINT 入口点 - Docker —— 从入门到实践 (gitbook.io)</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络：dropout 正则化</title>
    <url>/2021/02/19/dropout/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="dropout原理">dropout原理</h2>
<p>直觉-1：每次迭代之后，神经网络都会变得更小，采用一个较小的神经网络好像和使用正则化的效果是一样的。</p>
<p>直觉-2：神经元不能依赖任何特征，因为每个特征都可能被随机清除，所以不能把所有赌注放在一个节点上，不能给一个输入太多权重，这样改单元通过这种方式积极传播开</p>
<p>dropout的功能类似于L2正则化。</p>
<h2 id="实现方法">实现方法</h2>
<p>比如我们有一个神经网络，要在第3层进行dropout。</p>
<p>定义keep_prob 为保留单元的概率</p>
<p><span class="math inline">\(d^{[3]} = np.random.rand(a^{[3]}.shape[0], a^{[3]}.shape[1]) &lt; keep_prob\)</span> 这一步是生成一个bool矩阵，其中1的概率为keep_prob。</p>
<p><span class="math inline">\(a^{[3]} = np.multiply(a^{[3]}, d^{[3]})\)</span></p>
<p><span class="math inline">\(a^{[3]} /= keep\_prob\)</span> 这里除以keep_prob是为了让期望保持不变，因为直接去除几个结果期望肯定会改变。</p>
<blockquote>
<p>设置 keep _prob==1则保留这一层的结果，不进行dropout。</p>
</blockquote>
<p>另外dropout只在训练时执行，测试阶段则不进行dropout，因为在测试阶段我们不希望输出结果是随机的。</p>
<h2 id="keras中使用dropout">keras中使用dropout</h2>
<p>使用dropout正则化随机禁用隐藏层中神经元的某些部分。 在Keras库中，你可以在任何隐藏层之后添加dropout，并且可以指定rate，该rate决定了<strong>上一层</strong>中禁用的神经元的百分比。</p>
<p>https://machinelearningmastery.com/dropout-regularization-deep-learning-models-keras/</p>
]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>dropout</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>中文分词正向最大匹配算法(C++)</title>
    <url>/2018/11/12/fenci/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="机械分词法">机械分词法</h3>
<blockquote>
<p>它是按照一定的策略将待分析的汉字串与一个“充分大的”机器词典中的词条进行配，若在词典中找到某个字符串，则匹配成功。按照扫描方向的不同，串匹配分词方法可以分为正向匹配和逆向匹配；按照不同长度优先匹配的情况，可以分为最大匹配和最小匹配。</p>
</blockquote>
<p>正向最大匹配算法是从左到右将待分词文本中的几个连续字符与词表匹配，如果匹配上，则切分出一个词。但如果要切分出最大长度的词该怎么办呢？</p>
<p>这里有个办法是设定最大词长度Max，每次切下Max个字符串，然后将这个字符串与词库中的词比对，如果存在相同的则输出，否则切下最后一个词继续与词库中的词匹配。直到匹配成功或者剩余字符串长度为1（不输出单字）。这时候将原字符串str修改为str减去切下的词。</p>
<h3 id="实例说明">实例说明</h3>
<p>这里有个简单的例子： 假设词库里有 <code>“大学生”, “学生”, “上海大学”, “自强不息”</code>这几个词, 现有待分词字符串<code>”上海大学的大学生自强不息”</code> 首先确定Max为4, 切下字符串上海大学, 检测在词库中, 输出, 修改字符串为 ”的大学生自强不息”, 切下字符串 ”的大学生”, 检测不在词库中, 切下一个字变成 ”的大学”, 仍不在词库中, 一直到”的” 仍不在词库中此时不输出单字, 修改字符串为”大学生自强不息”, 重复上述步骤, 输出结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上海大学</span><br><span class="line">大学生</span><br><span class="line">自强不息</span><br></pre></td></tr></table></figure>
<p>用流程图表示为 <img src="https://s1.ax1x.com/2018/11/12/iOEdeA.png" /></p>
<p>主要实现的函数有 <code>int isinDict(string word);</code> // 遍历词典, 查询word是否在词典中</p>
<p><code>string CutDown(string&amp; str);</code> // 分出一个词并返回, 修改str为str – sub</p>
<p><code>void Out(string&amp; str);</code> // 当str长度大于一个字符时变继续分词, 并把结果输出</p>
<p><code>void SetDict()</code> // 统计词典词的个数, 并把词储存在string数组中.</p>
<h3 id="代码">代码</h3>
<h4 id="文件结构">文件结构</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- dict.text   &#x2F;&#x2F; 字典</span><br><span class="line">- text.txt    &#x2F;&#x2F; 未分词文本</span><br><span class="line">- result.txt  &#x2F;&#x2F;分词结果</span><br><span class="line">- main.cpp</span><br><span class="line">- Cut.cpp</span><br><span class="line">- Cut.h</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面只放出Cut类的实现代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cut.h</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Cut.h</span></span><br><span class="line"><span class="comment">//  中文分词</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Chen Bai on 2018/10/24.</span></span><br><span class="line"><span class="comment">//  Copyright © 2018 Chen Bai. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> Cut_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cut_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cut</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetDictPath</span><span class="params">(<span class="built_in">string</span> path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetResPath</span><span class="params">(<span class="built_in">string</span> path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetTextPath</span><span class="params">(<span class="built_in">string</span> path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Out</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetDict</span><span class="params">()</span></span>;   <span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span> count;   <span class="comment">//词典词的个数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> DictPath;</span><br><span class="line"><span class="built_in">string</span> ResPath;</span><br><span class="line"><span class="built_in">string</span> TextPath;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">GetText</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">CutDown</span><span class="params">(<span class="built_in">string</span>&amp; str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isinVs</span><span class="params">(<span class="built_in">string</span> str)</span></span>;</span><br><span class="line"><span class="keyword">int</span> Max = <span class="number">60</span>;  <span class="comment">//最长词的字数</span></span><br><span class="line"><span class="built_in">string</span> *Dict;</span><br><span class="line"><span class="comment">//在GetText()函数中规定了读取文本时一行的中文字符数为10000个</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* Cut_h */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cut.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Cut.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cut::SetDict</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fstream fs;</span><br><span class="line">    <span class="keyword">char</span> vac[Max];</span><br><span class="line">    <span class="keyword">int</span> line=<span class="number">0</span>, i=<span class="number">0</span>;</span><br><span class="line">    fs.open(DictPath);</span><br><span class="line">    <span class="keyword">if</span>(!fs) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;字典文件打开失败&quot;</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 统计行数</span></span><br><span class="line">    <span class="keyword">while</span> (fs.getline(vac, Max))</span><br><span class="line">        line++;</span><br><span class="line">    count = line;   <span class="comment">//设置词的个数, 方便遍历</span></span><br><span class="line">    Dict = <span class="keyword">new</span> <span class="built_in">string</span>[line];</span><br><span class="line">    fs.clear();</span><br><span class="line">    fs.seekp(ios::beg);</span><br><span class="line">    <span class="keyword">while</span> (fs.getline(vac, Max))</span><br><span class="line">    &#123;</span><br><span class="line">        Dict[i] = <span class="built_in">string</span>(vac);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    fs.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Cut::isinVs</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++)</span><br><span class="line">    <span class="keyword">if</span>(str == Dict[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Cut::CutDown</span><span class="params">(<span class="built_in">string</span>&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> sub;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(str.length() &gt; Max)</span><br><span class="line">    &#123;</span><br><span class="line">        sub = str.substr(<span class="number">0</span>, Max);</span><br><span class="line">        i = Max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sub = str;</span><br><span class="line">        i = str.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( isinVs(sub) )</span><br><span class="line">        &#123;</span><br><span class="line">            str = str.substr(i, str.length());</span><br><span class="line">            <span class="keyword">return</span> sub;</span><br><span class="line">        &#125;</span><br><span class="line">        sub = sub.substr(<span class="number">0</span>, i= i<span class="number">-3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    str = str.substr(i, str.length());</span><br><span class="line">    <span class="keyword">return</span> sub.substr(<span class="number">0</span>, <span class="number">3</span>);  <span class="comment">// 单个汉字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cut::Out</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fstream fs;</span><br><span class="line">    <span class="built_in">string</span> temp;</span><br><span class="line">    <span class="comment">//    string root = GetRoot(ResPath);</span></span><br><span class="line">    fs.open(ResPath, ios::out);</span><br><span class="line">    <span class="keyword">if</span>(!fs)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;结果文件打开失败&quot;</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">string</span> str = GetText();</span><br><span class="line">    <span class="keyword">while</span> (str.length() &gt;= <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">if</span>( (temp = CutDown(str)).length()&gt; <span class="number">3</span> )</span><br><span class="line">    fs &lt;&lt; temp &lt;&lt; <span class="string">&quot;/&quot;</span>;</span><br><span class="line">    fs.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cut::SetDictPath</span><span class="params">(<span class="built_in">string</span> path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DictPath = path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cut::SetResPath</span><span class="params">(<span class="built_in">string</span> path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ResPath = path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cut::SetTextPath</span><span class="params">(<span class="built_in">string</span> path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TextPath = path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Cut::GetText</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fstream fs;</span><br><span class="line">    fs.open(TextPath);</span><br><span class="line">    <span class="keyword">if</span>(!fs) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;文本文件打开失败&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">30000</span>];</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">while</span> (fs.getline(temp, <span class="number">30000</span>))</span><br><span class="line">        res += <span class="built_in">string</span>(temp);</span><br><span class="line">    fs.close();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>分词</tag>
        <tag>最大匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>flask01-路由</title>
    <url>/2018/09/22/flask01-1/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="route装饰器">route装饰器</h3>
<p>route()装饰器的第一个参数是<strong>URL规则</strong>，用字符串表示，必须以斜杠开始，这里的URL是相对URL。 以<code>www.blacston.com</code>为例，'/' 对应的是根地址 <code>www.blacton.com</code>, '/hello'对应的是 <code>www.blacton.com/hello</code> <span id="more"></span> ### 为视图函数绑定多个URL 一个视图函数可以绑定多个URL <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hi&#x27;</span></span>)</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure> 这样访问两个URL时都会出发say_hello()函数</p>
<h3 id="动态url">动态URL</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/greet/&lt;name&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello %s&#x27;</span> % name</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Flask会解析请求并把请求的URL与视图函数的URL规则进行匹配，比如这里的URL规则是/greet/<name> 那么/greet/baichen，/greet/bar 的请求都会出发这个视图函数</p>
<h3 id="设置默认值">设置默认值</h3>
<p>当URL规则包含变量时，如果用户访问的url没有变量，flask在匹配失败后会返回一个404错误响应，解决方法是在route()函数里使用defaults参数设置变量的默认值，这个参数接收字典作为输入 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello&#x27;</span>, defaults=&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;游客&#x27;</span>&#125;</span>)</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello/&lt;name&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello %s&#x27;</span> % name</span><br><span class="line"></span><br></pre></td></tr></table></figure> 它其实相当于 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello&#x27;</span></span>)</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello/&lt;name&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">name=<span class="string">&#x27;游客&#x27;</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello %s&#x27;</span> % name</span><br><span class="line">    </span><br></pre></td></tr></table></figure></p>
<h3 id="url处理">URL处理</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello/&lt;int:year&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">year</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;year is : &#x27;</span> % year</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中int把year转换成了整型，flask还提供了其他的转换器，有以下几种</p>
<ul>
<li>string</li>
<li>int</li>
<li>float</li>
<li>path （包含斜线的字符串）</li>
<li>any 匹配一系列给定值的一个元素</li>
<li>uuid</li>
</ul>
<p>any的用法如下 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/colors/any(blue, red, white):color&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">three_colors</span>(<span class="params">color</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;i like %s&#x27;</span> % color</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>flask学习笔记</category>
      </categories>
      <tags>
        <tag>flask</tag>
        <tag>route</tag>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title>flask02-启动开发服务器</title>
    <url>/2018/09/22/flask02/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>flask通过依赖包Click安装了一个CLI(命令行交互界面)系统, 可以通过flask命令执行内置命令 使用<code>flask run</code>来启动内置的开发服务器 <span id="more"></span> 使用命令之前确保激活了虚拟环境</p>
<p>如果执行<code>flask run</code>命令后显示(command not found)或其他错误，可以尝试使用<code>python -m flask run</code>启动服务器</p>
<p>旧的启动开发服务器的方式是使用<code>app.run()</code>方法，目前已不推荐使用</p>
<h3 id="自动发现程序实例">自动发现程序实例</h3>
<p>在执行flask run 命令之前我们需要提供程序实例所在模块的位置，我们之所以可以直接运行是因为flask会自动探测程序实例，自动探测存在下面的规则 1. 从当前目录寻找app.py或wsgi.py的模块，并从中寻找名为app.py或application的程序实例 2. 从环境变量FLASK_APP对应的值寻找名为app.py或application的程序实例</p>
<p>如果程序主模块是其他名称，比如<code>hello.py</code> ，需要设置环境变量FLASK_APP 在macos/linux下 <code>$ export FLASK_APP=hello</code></p>
<p>在windows下 <code>&gt; set FLASK_APP=hello</code></p>
<h3 id="管理环境变量">管理环境变量</h3>
<p>环境变量在创建新命令行和重启电脑之后就清除了，为了避免频繁设置环境变量，可以使用python-dotenv管理项目的环境变量 安装: <code>pipenv install python-dotenv</code> 1. 在项目根目录创建两个文件<code>.flask</code>和<code>.env</code>，环境变量使用键值对定义，每行一个，#为注释 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SOME_VAR=<span class="number">1</span></span><br><span class="line"><span class="comment">#这是注释</span></span><br><span class="line">FOO = <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="更多启动选项">更多启动选项</h3>
<h4 id="使服务器对外部可见">使服务器对外部可见</h4>
<p><code>$ flask run --host=0.0.0.0</code> #### 设置端口 <code>4 flask run --port=8000</code></p>
]]></content>
      <categories>
        <category>flask学习笔记</category>
      </categories>
      <tags>
        <tag>flask</tag>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title>flask03-cookies, session</title>
    <url>/2018/09/23/flask03/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>使用session和cookies制作一个简单的登录系统</p>
<h3 id="cookie">cookie</h3>
<h4 id="设置cookie">设置cookie</h4>
<p>在flask中，在响应中添加cookie最方便的方法是使用Response类提供的<code>set_cookie()</code>方法，要使用这个方法需要先试用<code>make_response()</code>方法生成一个response对象</p>
<p>set_cookie()方法支持多个参数来设置Cookie的选项</p>
<hr />
<p>key cookie的键 value cookie的值 max_age cookie保持的时间，单位为秒；默认在用户关闭浏览器过期 expires 具体过期时间 path domain secure httponly</p>
<hr />
<h4 id="获取cookie">获取cookie</h4>
<p>cookie可以通过request的cookies属性来获取 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    name = request.args.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        name = request.cookies.get(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;游客&#x27;</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&#x27;hello %s&#x27;</span> %s name</span><br><span class="line"></span><br></pre></td></tr></table></figure> ### session：更安全的cookie</p>
<h4 id="设置程序密钥">设置程序密钥</h4>
<p>session用来将cookie数据加密储存，所以需要设置一个密钥，是一个随机复杂的字符串 1. 通过Flask.secret_key或配置变量SECRET_KEY设置 <code>app.secret_key= 'secret string'</code> 2. 更安全的办法是将其写入环境变量中(在命令行使用<code>export</code>/<code>set</code>命令),或者保存在.env文件中 然后用os.getenv()方法获取 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 第二个参数是没有获取到SECRET_KEY取的默认值</span></span><br><span class="line">app.secret_key = os.getenv(<span class="string">&#x27;SECRET_KEY&#x27;</span>, <span class="string">&#x27;secret string&#x27;</span>)</span><br></pre></td></tr></table></figure> #### 模拟用户登录 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> redirect, session, url_for</span><br><span class="line">...</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/login&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>():</span></span><br><span class="line">    session[<span class="string">&#x27;logged_in&#x27;</span>] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;hello&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure> 在hello视图中: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="comment"># 从query string里获取name参数</span></span><br><span class="line">    name = request.args.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        name = request.cookies.get(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;游客&#x27;</span>)</span><br><span class="line">    <span class="comment"># escape 防止XSS攻击</span></span><br><span class="line">    response = <span class="string">&#x27;hello %s&#x27;</span> % escape(name)</span><br><span class="line">    <span class="keyword">if</span> session.get(<span class="string">&#x27;logged_in&#x27;</span>):</span><br><span class="line">        response += <span class="string">&#x27;[已登录]&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        response += <span class="string">&#x27;[请登录]&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="登出">登出</h4>
<p>登出账户的世纪操作就是把代表用户认证的cookie删除，这通过session.pop()方法实现 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> session</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/logout&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logout</span>():</span></span><br><span class="line">    session.pop(<span class="string">&#x27;logged_in&#x27;</span>)</span><br><span class="line">   <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;hello&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="完整代码">完整代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, make_response, redirect, url_for, session</span><br><span class="line"><span class="keyword">from</span> jinja2 <span class="keyword">import</span> escape</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">app.secret_key = <span class="string">&#x27;adadanjkdhoaf29891&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="comment"># 从query string里获取name参数</span></span><br><span class="line">    name = request.args.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        name = request.cookies.get(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;游客&#x27;</span>)</span><br><span class="line">    <span class="comment"># escape 防止XSS攻击</span></span><br><span class="line">    response = <span class="string">&#x27;hello %s&#x27;</span> % escape(name)</span><br><span class="line">    <span class="keyword">if</span> session.get(<span class="string">&#x27;logged_in&#x27;</span>):</span><br><span class="line">        response += <span class="string">&#x27;[已登录]&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        response += <span class="string">&#x27;[请登录]&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/login/&lt;name&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">name</span>):</span></span><br><span class="line">    response = make_response(redirect(url_for(<span class="string">&#x27;hello&#x27;</span>)))</span><br><span class="line">    response.set_cookie(<span class="string">&#x27;name&#x27;</span>, name)</span><br><span class="line">    session[<span class="string">&#x27;logged_in&#x27;</span>] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/logout&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logout</span>():</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;logged_in&#x27;</span> <span class="keyword">in</span> session:</span><br><span class="line">        session.pop(<span class="string">&#x27;logged_in&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;hello&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在浏览器分别访问 - <code>localhost:5000/</code> - <code>localhost:5000/hello</code> - <code>localhost:5000/login/baichen</code> - <code>localhost:5000/logout</code></p>
]]></content>
      <categories>
        <category>flask学习笔记</category>
      </categories>
      <tags>
        <tag>flask</tag>
        <tag>cookies</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title>flask04-模板</title>
    <url>/2018/11/05/flask04/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>flask使用的默认模板引擎是<code>jinja2</code></p>
<h2 id="模板语法">模板语法</h2>
<h3 id="三种界定符">三种界定符</h3>
<ol type="1">
<li>语句，比如if、for</li>
</ol>

{% ... %} 

<ol start="2" type="1">
<li>表达式比如字符串，变量，函数调用</li>
</ol>

{{ ... }}

<ol start="3" type="1">
<li>注释</li>
</ol>

{# ... #}

<p>在jinja2使用<code>.</code>来获取变量的属性，比如user字典中的username键值通过<code>.</code>来获取j，即<code>user.username</code>, 等同于<code>user[username]</code></p>
<ol type="1">
<li>jinja2并不支持所有Python所有语法，使用处于效率和代码组织等方面考虑<strong>应该适度使用模板，仅把和输出控制有关的逻辑操作放到模板中</strong></li>
<li>Jinja2提供了多种控制结构来控制模板的输出，其中<code>for</code> 和 <code>if</code> 是最常用的两种，在语句结束时要添加 <strong>结束标签</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if user.bio %&#125;</span><br><span class="line">&lt;i&gt; &#123;&#123; user.bio &#125;&#125; &lt;&#x2F;i&gt;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">&lt;i&gt; This user has not provided a bio. &lt;&#x2F;i&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">&#123;% for movie in movies %&#125;</span><br><span class="line">&lt;li&gt; &#123;&#123; movie.name &#125;&#125; -- &#123;&#123; movie.year &#125;&#125; &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>
<h3 id="for循环特殊变量">for循环特殊变量</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">变量名</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">loop.index</td>
<td style="text-align: center;">当前迭代数（从1开始计数）</td>
</tr>
<tr class="even">
<td style="text-align: center;">loop.index()</td>
<td style="text-align: center;">当前迭代书（从0开始计数）</td>
</tr>
<tr class="odd">
<td style="text-align: center;">loop.revindex</td>
<td style="text-align: center;">当前反向迭代数（从1开始计数）</td>
</tr>
<tr class="even">
<td style="text-align: center;">loop.revindex()</td>
<td style="text-align: center;">当前反向迭代数（从0开始计数）</td>
</tr>
<tr class="odd">
<td style="text-align: center;">loop.first</td>
<td style="text-align: center;">如果时第一个元素则返回True</td>
</tr>
<tr class="even">
<td style="text-align: center;">loop.last</td>
<td style="text-align: center;">如果时最后一个元素则返回True</td>
</tr>
<tr class="odd">
<td style="text-align: center;">loop.previtem</td>
<td style="text-align: center;">上一迭代条目</td>
</tr>
<tr class="even">
<td style="text-align: center;">loop.nextitem</td>
<td style="text-align: center;">下一迭代条目</td>
</tr>
<tr class="odd">
<td style="text-align: center;">loop.length</td>
<td style="text-align: center;">序列包含的元素数量</td>
</tr>
</tbody>
</table>
<h3 id="渲染模板">渲染模板</h3>
<p>渲染一个模板就是执行模板中的代码，并传入所有在模板中使用的变量，渲染后的结果就是我们要返回客户端的HTML响应，在视图函数中我们并不直接使用Jinjia2提供的函数，而是使用Flask提供的渲染函数<code>render_template()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/watchlist&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">watchlist</span>():</span></span><br><span class="line"><span class="keyword">return</span> render_template(<span class="string">&quot;watchlist.html&quot;</span>, user=user, movies=movies)</span><br></pre></td></tr></table></figure>
<p>在<code>render_template()</code>函数中，第一个参数时模板的文件名, Flask会在程序根目录下的templates文件夹里寻找模板文件，所以这里传入的路径时相对于templates根目录的。以关键字的形式传入了模板中使用的变量值，其他类型的变量通过相同的方式传入，传入的变量值可以时字符串、列表和字典，也可以时函数、类和实例</p>
<p>如果想传入函数，在模板调用，那么需要传入函数对象本身，而不是函数调用（函数的返回值），使用仅写出函数名即可，传入模板后，在函数名称后面添加括号以调用，以可以在括号中传入参数</p>
<h2 id="模板辅助工具">模板辅助工具</h2>
<h3 id="上下文">上下文</h3>
<p>模板上下文包含了很多变量，其中包裹我们调用<code>render_template()</code>时传入的变量，除了在渲染时传入变量，也可以在模板中定义d变量，使用{% %}标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% set navigation &#x3D;[ (&#39;&#x2F;&#39;, &#39;Home&#39;), (&#39;&#x2F;about&#39;, &#39;About&#39;) ] %&#125;</span><br></pre></td></tr></table></figure>
<p>也可以将一部分模板数据定义为变量使用 <code>set</code>和<code>endset</code>来声明开始和结束 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% set navigation %&#125;</span><br><span class="line">&lt;li&gt;&lt;a href&#x3D;&quot;&#x2F;&quot;&gt;Home&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href&#x3D;&quot;&#x2F;about&quot;&gt;About&lt;&#x2F;li&gt;</span><br><span class="line">&#123;% endset %&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="内置上下文变量">内置上下文变量</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">变量</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">config</td>
<td style="text-align: center;">当前的配置对象</td>
</tr>
<tr class="even">
<td style="text-align: center;">request</td>
<td style="text-align: center;">当前的请求对象，在已激活的请求环境下可用</td>
</tr>
<tr class="odd">
<td style="text-align: center;">session</td>
<td style="text-align: center;">当前的会话对象，在已激活的请求环境下可用</td>
</tr>
<tr class="even">
<td style="text-align: center;">g</td>
<td style="text-align: center;">与请求绑定的全局变量，在已激活的请求环境下可用</td>
</tr>
</tbody>
</table>
<h4 id="自定义上下文">自定义上下文</h4>
<p>如果很多个模板都需要使用同一变量，那么可以设置一个模板全局变量避免在多个视图函数中重复传入。flask提供了一个<code>app.context_processor</code>装饰器，可以用来注册模板上下文处理函数，它可以帮我们完成统一传入变量的工作。模板上下文处理函数需要返回一个<strong>包含变量键值对的字典</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.context_processor()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inject_foo</span>():</span></span><br><span class="line">foo = <span class="string">&quot;I am foo&quot;</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">dict</span>(foo=foo)</span><br></pre></td></tr></table></figure>
<p>当我们调用<code>render_template()</code>函数渲染任意一个模板时，所有使用<code>app.context_processor</code>装饰器注册注册的模板上下文处理函数（包括flask内置的上下文处理函数）都会被执行，这些函数的返回值会被添加到模板中，因此我们可以直接在模板中使用<code>foo</code>变量</p>
<p>除了使用<code>app.context_processor</code>装饰器，也可以直接将其作为方法调用，传入模板上下文处理函数 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inject_foo</span>():</span></span><br><span class="line">foo = <span class="string">&quot;I am foo&quot;</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">dict</span>(foo=foo)</span><br><span class="line"></span><br><span class="line">app.context_processor(inject_foo)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="全局对象">全局对象</h2>
<p>全局对象是指在所有的模板中都可以直接使用的对象 ### 内置全局函数 Jinjia2在模板中默认提供了一些全局函数，常用的三个函数</p>
<table>
<colgroup>
<col style="width: 70%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">函数</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">range([start, ] stop[, step])</td>
<td style="text-align: left;">和python中range()用法相同</td>
</tr>
<tr class="even">
<td style="text-align: left;">lipsum(n=5, html=True, min=20, max=100)</td>
<td style="text-align: left;">生成随机文本，可以在测试时调用来填充页面，默认生成5段html文本，每段包含20～100个单词</td>
</tr>
<tr class="odd">
<td style="text-align: left;">dict(**items)</td>
<td style="text-align: left;">和python中dict()用法相同</td>
</tr>
</tbody>
</table>
<p>flask在模板中内置了两个全局函数</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">函数</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">url_for()</td>
<td style="text-align: left;">用于生成url</td>
</tr>
<tr class="even">
<td style="text-align: left;">get_flashed_messages()</td>
<td style="text-align: left;">获取flash消息</td>
</tr>
</tbody>
</table>
<p>url_for()传入视图端点 ### 自定义全局函数 我们可以使用<code>app.template_global</code>装饰器直接将函数注册为模板全局函数。默认使用函数名称传入模板，在<code>app.template_global()</code>装饰器中使用name参数可以指定一个自定义名称。</p>
<h2 id="过滤器">过滤器</h2>
<p>在jinja2中，过滤器是一些可以用来修改和过滤变量值的特殊函数，过滤器和变量之间用<code>|</code>隔开，需要参数的过滤器可以用括号进行传递</p>
<h4 id="例子1">例子1</h4>
<p><code>&#123;&#123;name|title&#125;&#125;</code> 这会将name变量的值标题化，相当于在Python中调用<code>name.title()</code> #### 例子2 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">另一种方法时将过滤器作用于一部分模板数据，使用&#96;filter&#96;和&#96;endfilter&#96;标签声明开始和结束</span><br><span class="line">&#96;&#96;&#96;jinjia2</span><br><span class="line">&#123;%filter upper%&#125;</span><br><span class="line">    This text will be uppercase.</span><br><span class="line">&#123;%endfilter%&#125;</span><br></pre></td></tr></table></figure> ### 内置过滤器 |过滤器|说明| |:------------------|:-----------| | default(value, default_value=u'', boolean=False) | 设置默认值，默认值作为参数传入，别名为d| |escape(s)|转移html文本，别名为e| |first(seq)|返回序列的第一个元素| |last(seq)|返回序列的最后一个元素| |length(object)|返回变量的长度| |random(seq)|返回序列中的随机元素| |safe(value)|将变量值标记为安全，避免转义| 更多过滤器请访问<a href="http://jinja.procc.org/docs/2.10/templates/#builtin-filters">http://jinja.procc.org/docs/2.10/templates/#builtin-filters</a></p>
<p>在使用过滤器时，列表中过滤器函数的第一个参数表示被过滤的变量值(value)或字符串(s)，即竖线符号左侧的值，其他参数可以通过添加括号传入，另外过滤器可以叠加使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;Hello, &#123;&#123;name|default(&#39;陌生人&#39;)|title&#125;&#125;!&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>
<h3 id="自定义过滤器">自定义过滤器</h3>
<p>使用<code>app.template_filter()</code>装饰器可以注册自定义过滤器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from flask import Markup</span><br><span class="line"></span><br><span class="line">@app.template_filter()</span><br><span class="line">def musical(s):</span><br><span class="line">    return s+Markup(&#39; &amp;#9835&#39;) # 在变量字符后添加一个音符图标，用markup将其标记为安全字符</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>和注册全局函数类似，可以在app.template_filter()中使用name关键字设置过滤器的名称，默认为函数名称。 </br> 过滤器需要接受被处理的值为输入，返回处理后的值。</p>
<h2 id="模板组织结构">模板组织结构</h2>
<h3 id="局部模板">局部模板</h3>
<p>在web程序中，我们通常会为每一页面编写一个独立的模板，比如主页模板，设置模板，这些模板可以<strong>直接在试图函数中渲染并作为html响应主体</strong></br> 除了这类模板我们还会用到另一类非独立模板，被称为<strong>局部模板或次模板</strong>，因为他们仅包含部分代码，使用不会再视图函数中直接渲染它，而是插入到其他独立模板中。</br> 为了避免重复，当多个独立模板中都会使用同一块html代码时，我们可以把这部分代码抽离出来，存储在局部模板中。比如多个页面都要在顶部显示一个提示条，这个横幅抗议定义在局部模板<code>_banner.html</code>中。</br> 使用 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% inlcude &#39;_banner.html&#39; %&#125;</span><br></pre></td></tr></table></figure> 来插入一个局部模板，这会吧局部模板的全部内容插在此标签的位置。 ### 宏 宏类似于python里的函数。使用宏可以把一部分模板代码封装到宏里，使用传递的参数来构建内容，最后返回构建后的内容。功能上和局部模板相似，都是为了方便代码块的重用。</br> 在创建宏时使用<code>macro</code>和<code>endmacro</code>标签声明宏的开始和结束，在开始标签中定义宏的名称和接收的参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% macro qux(amount&#x3D;1) %&#125;</span><br><span class="line">    &#123;% if amount &#x3D;&#x3D; 1 %&#125;</span><br><span class="line">        i am qux</span><br><span class="line">    &#123;% elif amount &gt;1 %&#125;</span><br><span class="line">        we are quxs</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&#123;% endmacro %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用示例</p>

{% from 'macros.html' import qux %}</br>
...</br>
{{ qux(amount=5) }}</br>

<h3 id="模板继承">模板继承</h3>
<p>当子模板继承基模板后，子模板会包含基模板的内容和结构，为了让子模板能插入或覆盖内容到基模板中，我们需要在<strong>基模板</strong>中定义block。在子模板中使用{% extend 'base.html' %}来声明扩展基模板。 <em>extend必须是子模板的第一个标签！</em></p>
<h4 id="覆盖内容">覆盖内容</h4>
<p>当在子模板里创建同名的块时，会用子块内容覆盖父块内容 #### 追加内容 如果想向基模板的块中追加内容，需要用<code>super()</code>函数声明</p>

{% block styles %}</br>
{{ super() }}</br>
<style></br>
    .foo{color:red}</br>
</style></br>
{% endblock %}</br>

<h2 id="加载静态文件">加载静态文件</h2>
<p>Flask中默认需要将静态文件存储在与主脚本（包含程序实例的脚本）同级目录的static文件夹中， 如果想在其他文件夹中储存静态文件，可以在在实例化Flask类是使用<code>static_folder</code>参数指定，静态文件的url路径中的static也会自动随着文件夹名称变化。</br> 为了在html文件中引用静态文件，需要用<code>url_for()</code>函数获取静态文件url。flask内置了用于获取静态文件的师徒函数，端点值为static，它的默认url规则为<code>static/&lt;path:filename&gt;</code>，url变量filename是相对于static文件夹根目录的文件路径。</p>
<h3 id="添加favicon网站头像">添加favicon（网站头像）</h3>
<p>在static文件夹下放入favicon文件，命名为favicon.ico，然后再html页面中声明favicon路径 
<link rel="icon" type="image/x-icon" href={{url_for('static', filename='favicon.ico')}}>
</p>
<h2 id="消息闪现">消息闪现</h2>
<p>flask提供的<code>flash()</code>函数发送消息储存在session中，在模板中使用全局函数<code>get_flashed_messages()</code>获取消息，并将其显示出来。 </br> 通过flash()函数发送的消息储存在session中，所以我们需要为程序设置密钥，可以通过<code>app.secret_key</code>属性或者配置环境变量<code>SECRET_KEY</code>设置</p>
<p>示例 
from flask import Flask, render_template, flash</br>

app = Flask(__name__)</br>
app.secret_key = 'secret string'</br>

@app.route('/flash')</br>
def just_flash():</br>
flash('i am flash')</br>
return redirect(url_for('index'))</br>
</p>
<p>在templates中的代码如下</p>

<main></br>
    {% for message in get_flashed_messages() %}</br>
        <div class="alert"> {{message}} </div></br>
    {% endfor %}</br>
    {% block content %} {% endblock %}</br>
</main></br>

<h2 id="自定义错误页面">自定义错误页面</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask, render_template</span><br><span class="line">...</span><br><span class="line">@app.errorhandler(404)</span><br><span class="line">def page_not_found(e):</span><br><span class="line">    return render_template(&#39;errors&#x2F;404.html&#39;), 404   </span><br></pre></td></tr></table></figure>
<p>错误处理函数接收异常对象为参数，异常对象提供了以下常用属性 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code  状态码</span><br><span class="line">name    原因短语</span><br><span class="line">description 错误描述</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>flask学习笔记</category>
      </categories>
      <tags>
        <tag>flask</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>flask05-表单</title>
    <url>/2018/11/22/flask05/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="表单">表单</h2>
<h2 id="html表单">html表单</h2>
<p>在html表单中，<code>&lt;input&gt;</code>标签表示各种输入字段，<code>&lt;label&gt;</code>标签则用文字来定义字段的标签文字。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">mehtod</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span>&gt;</span>Password<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;1414124&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;remenber&quot;</span> <span class="attr">id</span>=<span class="string">&quot;remember&quot;</span> <span class="attr">checked</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;remenber&quot;</span>&gt;</span>Remember me<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;login&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="wtforms">WTForms</h2>
<p>WTForms支持在python中使用<strong>类</strong>来定义表单，然后通过类定义生成对应的html代码，这种方式方面，易于重用，所以一般不会再模板中直接使用html编写表单。</p>
<h2 id="使用flask-wtf处理表单">使用Flask-WTF处理表单</h2>
<p>Flask-WTF集成了WTForms使用它可以在flask中更方便地使用WTFormss。Flask-WTF将表单数据解析，CSRF保护，文件上传等功能与flask集成，还增加了reCAPTCHA支持。</p>
<p>安装Flask-WTF及其依赖 <code>$ pipenv install flask-wtf</code></p>
<p>Flask-WTF默认为每个表单启用CSRF保护，他会为我们自动生成和验证CSRF令牌。默认情况使用程序密钥来对令牌进行签名，配置键<code>WTF_CSRF_ENABLED</code>来设置是否开启CSRF保护，默认为True。flask-wtf会自动在实例化表单类时添加一个包含CSRF令牌值的<em>隐藏字段</em>，字段名为<code>cstf_token</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.secret_key &#x3D; &#39;secret string&#39;</span><br></pre></td></tr></table></figure>
<h3 id="定义wtforms表单类">定义WTForms表单类</h3>
<p>当使用WTForms创建表单时，表单由python来表示，这个类继承从WTForms导入Form基类。一个表单由若干输入字段(Field)组成，字段由表单类的类属性表示。下面自定义了一个LoginForm类。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> wtforms <span class="keyword">import</span> Form, StringField, PasswordField, BooleanField, SubmitField</span><br><span class="line"><span class="keyword">from</span> wtfroms.validators <span class="keyword">import</span> DataRequired, Length</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginForm</span>(<span class="params">Form</span>):</span></span><br><span class="line">    username = StringField(<span class="string">&#x27;Username&#x27;</span>, validators=[DataRequired()])</span><br><span class="line">    password = PasswordField(<span class="string">&#x27;Password&#x27;</span>, validators=[DataRequired(), Length(<span class="number">8</span>, <span class="number">128</span>)])</span><br><span class="line">    remember = BooleanField(<span class="string">&#x27;Remember me&#x27;</span>)</span><br><span class="line">    submit = SubmitField(<span class="string">&#x27;Login&#x27;</span>)</span><br></pre></td></tr></table></figure> 每隔字段属性通过实例化WTForms提供的字段表示，字段属性的名称将作为对应input元素的name属性和id属性。</br> 字段名称大小写敏感，不能以下划线和validate开头。</p>
<h3 id="常用wtforms字段">常用WTForms字段</h3>
<p><img src="https://s1.ax1x.com/2018/11/22/FPNu9J.png" /></p>
<h3 id="实例化字段类常用参数">实例化字段类常用参数</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">参数</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">label</td>
<td style="text-align: center;">字段标签<label>的值，也就是渲染后显示在输入字段前的文字</td>
</tr>
<tr class="even">
<td style="text-align: left;">render_kw</td>
<td style="text-align: center;">一个字典，用来设置对应input标签的属性</td>
</tr>
<tr class="odd">
<td style="text-align: left;">valiadtors</td>
<td style="text-align: center;">一个列表，包含一系列验证器，会在表单提交后被逐一调用验证表单数据</td>
</tr>
<tr class="even">
<td style="text-align: left;">default</td>
<td style="text-align: center;">字符串或可调用对象，用来为表单字段设置默认值</td>
</tr>
</tbody>
</table>
<h3 id="常用wtforms验证器">常用WTForms验证器</h3>
<p><img src="https://s1.ax1x.com/2018/11/22/FPNQj1.png" /></p>
<p>验证器的第一个参数一般为促物体时消息，可以使用message参数传入错误消息来覆盖内置消息。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name &#x3D; StringField(&#39;Your name&#39;, validators&#x3D;[DataRequired(message&#x3D;u&quot;名字不能为空&quot;)])</span><br></pre></td></tr></table></figure> ### 使用Flask-WTF 使用Flask-WTF定义表单时，<strong>仍然使用WTForms提供的字段类和验证器</strong>，只不过表单类药继承Flask-WTF提供的FlaskForm类。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask-wtf import FlaskForm</span><br><span class="line">from wtforms import StringField, PasswordField, BooleanField, SubmitField</span><br><span class="line">from wtfroms.validators import DataRequired, Length</span><br><span class="line">class LoginForm(FlaskForm):</span><br><span class="line">    username &#x3D; StringField(&#39;Username&#39;, validators&#x3D;[DataRequired()])</span><br><span class="line">    password &#x3D; PasswordField(&#39;Password&#39;, validators&#x3D;[DataRequired(), Length(8, 128)])</span><br><span class="line">    remember &#x3D; BooleanField(&#39;Remember me&#39;)</span><br><span class="line">    submit &#x3D; SubmitField(&#39;Login&#39;)</span><br></pre></td></tr></table></figure></p>
<h2 id="输出html代码">输出html代码</h2>
<p>实例化表单类，然后将实例属性转换成字符串或直接调用获取表单字段对应的html代码 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; form &#x3D; LoginForm()</span><br><span class="line">&gt;&gt;&gt; form.username()</span><br><span class="line">u&#39;&lt;input id&#x3D;&quot;username&quot; name&#x3D;&quot;username&quot; type&#x3D;&quot;text&quot; value&#x3D;&quot;&quot;&gt;&#39;</span><br></pre></td></tr></table></figure> 字段的label元素的html代码可以通过<code>form.字段名.label</code>的形式获取</p>
<h3 id="为字段添加额外属性">为字段添加额外属性</h3>
<h4 id="使用render_kw属性">使用render_kw属性</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">username &#x3D; StringField(&#39;Username&#39;, render_kw&#x3D;&#123;&#39;placeholder&#39;:&#39;Your name&#39;&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="在调用字段时传入">在调用字段时传入</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">form.username(style&#x3D;&#39;width: 200px;&#39;, class_&#x3D;&#39;bar&#39;)</span><br></pre></td></tr></table></figure>
<p>用class_代替class，渲染后的input标签会获取正确的class属性。</p>
<h2 id="在模板中渲染表单">在模板中渲染表单</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from forms import LoginForm</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;basic&#39;)</span><br><span class="line">def basic():</span><br><span class="line">    form &#x3D; LoginForm()</span><br><span class="line">    return render_template(&#39;login.html&#39;, form&#x3D;form)</span><br></pre></td></tr></table></figure>
<p>在模板中通过调用属性获取字段对应的html代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">    &#123;&#123; form.csrf_token &#125;&#125;</span><br><span class="line">    &#123;&#123; form.username.label &#125;&#125;  &#123;&#123; from.username &#125;&#125;&lt;&#x2F;br&gt;</span><br><span class="line">    &#123;&#123; form.password.label &#125;&#125;  &#123;&#123; form.password &#125;&#125;&lt;&#x2F;br&gt;</span><br><span class="line">    &#123;&#123; form.remember &#125;&#125;  &#123;&#123;form.remember.label&#125;&#125;&lt;&#x2F;br&gt;</span><br><span class="line">    &#123;&#123; form.submit &#125;&#125;&lt;&#x2F;br&gt;</span><br><span class="line">    </span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>
<p>csrf_token在提交表单后会被自动验证，为了确保表单通过验证，必须在表单中手动渲染这个字段。</p>
<h2 id="处理表单数据">处理表单数据</h2>
<ol type="1">
<li>解析请求，获取表单数据</li>
<li>对数据进行必要的转换</li>
<li>验证数据和CSRF令牌</li>
<li>如果验证未通过则生成错误消息</li>
<li>如果通过验证则把数据保存到数据库或做进一步处理</li>
</ol>
<h3 id="提交表单">提交表单</h3>
<form>
<p>标签的提交行为主要由三个属性控制。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">属性</th>
<th style="text-align: center;">默认值</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">action</td>
<td style="text-align: center;">当前url</td>
<td style="text-align: left;">表单提交时发送请求的url</td>
</tr>
<tr class="even">
<td style="text-align: left;">method</td>
<td style="text-align: center;">get</td>
<td style="text-align: left;">提交方法，仅支持get和post</td>
</tr>
<tr class="odd">
<td style="text-align: left;">enctype</td>
<td style="text-align: center;">application/x-www-form-urlencoded</td>
<td style="text-align: left;">表单编码类型</td>
</tr>
</tbody>
</table>
<h3 id="验证表单数据">验证表单数据</h3>
<h4 id="wtforms验证机制">wtforms验证机制</h4>
<p>实例化表单类时传入表单数据，然后对表单实例调用<code>validate()</code>方法。这会对每个字段调用相应的验证器，返回验证结果的布尔值。如果验证失败，就把错误消息储存到表单实例的errors属性对应的字典中。</p>
<hr />
<p>注意：使用post方法提交的表单数据会被解析成一个字典，可以通过<code>request.form</code>获取。使用get方法提交的数据同样被解析成字典，通过<code>request.args</code>获取。</p>
<hr />
<h4 id="在视图函数中验证表单">在视图函数中验证表单</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if request.method&#x3D;&#x3D;&#39;POST&#39; and form.validate(): </span><br></pre></td></tr></table></figure>
<p>Flask-WTF提供的<code>validate_on_submit()</code>合并了这两个操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if form.validate_on_submit(): </span><br></pre></td></tr></table></figure>
<p>通过form.字段名.date获取对应字段的数据。</p>
<h4 id="postredirectget">Post/Redirect/Get</h4>
<p>在浏览器中，刷新/重载时的默认行为时发送上一个请求，如果上一个请求时post，那么就会弹出一个窗口，询问用户是否再次提交此表单，为了避免这个提示，我们尽量不要让post请求作为最后一个请求，所以我们在处理表单后返回一个重定向响应，让浏览器发送一个get请求到相应url。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">@app.route(&#39;&#x2F;basic&#39;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;])</span><br><span class="line">def basic():</span><br><span class="line">    form &#x3D; LoginForm()</span><br><span class="line">    if form.validate_on_submit():</span><br><span class="line">        username &#x3D; form.username.data</span><br><span class="line">        flash(&quot;Welcome Home %s&quot;, % username)</span><br><span class="line">        return redirect(url_for(&#39;index&#39;))</span><br><span class="line">    return render_template(&#39;basic.html&#39;, form&#x3D;form)</span><br></pre></td></tr></table></figure></p>
<h3 id="在模板中渲染错误消息">在模板中渲染错误消息</h3>
<p>我们一般会通过字段名来获取<strong>对应字段的错误消息列表</strong>，即<code>form.字段名.errors</code>。</p>
<h2 id="自定义验证器">自定义验证器</h2>
<h3 id="行内验证器">行内验证器</h3>
<p>当表单类中包含以<code>validate_字段属性名</code>形式命名的方法时，在验证字段数据时会同时调用这个方法来验证对应的字段。验证方法接收两个位置参数，以此为form和field，分别是表单类实例和字段对象。验证出错跑出从<code>wtforms.validators</code>模块导入的<code>ValidatorError</code>异常。</p>
<p>注：不需要传入参数时使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from wtforms import IntegetField, SubmitField</span><br><span class="line">from wtforms.validators import ValidationError</span><br><span class="line"></span><br><span class="line">class FourtyTwoForm(FlaskForm):</span><br><span class="line">    answer &#x3D; IntegerField(&#39;The Number&#39;)</span><br><span class="line">    submit &#x3D; SubmitField()</span><br><span class="line">    </span><br><span class="line">    def validate_answer(form, field):</span><br><span class="line">        if field.data !&#x3D; 42:</span><br><span class="line">            raise VlidationError(&quot;Must be 42&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="全局验证器">全局验证器</h3>
<p>如果想定义一个可重用的验证器，可以通过一个函数实现。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def is_42(message&#x3D;None):</span><br><span class="line">    if message is None:</span><br><span class="line">        message &#x3D; &#39;Must be 42&#39;</span><br><span class="line">    def _is_42(form, field):</span><br><span class="line">        if field.data !&#x3D; 42:</span><br><span class="line">            raise ValidationError(message)</span><br><span class="line">    </span><br><span class="line">    return _is_42</span><br><span class="line">            </span><br></pre></td></tr></table></figure></p>
<p>注意：自定义验证器要返回可调用对象</p>
]]></content>
      <categories>
        <category>flask学习笔记</category>
      </categories>
      <tags>
        <tag>flask</tag>
        <tag>表单</tag>
        <tag>forms</tag>
      </tags>
  </entry>
  <entry>
    <title>flask06-数据库</title>
    <url>/2018/11/24/flask06/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="orm">ORM</h3>
<p>在web应用里使用原声sql语句操作数据库主要存在以下两类问题:</p>
<ol type="1">
<li>手动编写sql语句乏味，而且会降低代码易读性。还会出现安全问题</li>
<li>常见的开发模式时在开发时使用简单的SQLite，在部署时切换到MySQL等更健壮的DBMS。但是对于不同的DMBS，我们需要使用不同的python借口库，这让DBMS切换不那么容易。</li>
</ol>
<table style="width:7%;">
<colgroup>
<col style="width: 6%" />
</colgroup>
<tbody>
<tr class="odd">
<td>尽管使用ORM可以避免sql注入问题，但你仍然需要对传入的查询参数进行验证。另外在执行原生SQL语句时也要注意避免使用字符串拼接或字符串格式化的方式传入参数。</td>
</tr>
</tbody>
</table>
<p>使用ORM可以很大程度上结局这些问题：</p>
<ol type="1">
<li>自动处理查询参数的转义，避免sql注入。</li>
<li>为不同dbms提供统一接口，让切换工作变得简单。</li>
<li>ORM将python语言转换成dbms能够读懂的sql指令，能让我们利用python操控数据库。</li>
</ol>
<h4 id="orm的三层映射关系">ORM的三层映射关系</h4>
<ul>
<li>表 --&gt; Python类</li>
<li>字段(列) --&gt; 类属性</li>
<li>记录(行) --&gt; 类实例</li>
</ul>
<h2 id="使用flask-sqlalchemy管理数据库">使用Flask-SQLAlchemy管理数据库</h2>
<p>安装Flask-SQLAlchemy及其依赖 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pipenv install flask-sqlalchemy</span><br></pre></td></tr></table></figure></p>
<p>实例化Flask-SQLAlchemy提供的SQLAlchemy类，传入程序实例完成初始化，吧实例化扩展类的对象命名为db，这个db对象代表我们的数据库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from flask_sqlalchemy import SQLAlchemy</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line"></span><br><span class="line">db &#x3D; SQLAlchemy(app)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="连接数据库服务器">连接数据库服务器</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">DBMS</th>
<th style="text-align: center;">URI</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">MySQL</td>
<td style="text-align: center;">mysql://username:password@host/databasename</td>
</tr>
<tr class="even">
<td style="text-align: left;">SQLite(Unix)</td>
<td style="text-align: center;">sqlite:////absolute/path/to/foo.db</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SQLite(Windows)</td>
<td style="text-align: center;">sqlite:///absolute\path\to\foo.db</td>
</tr>
<tr class="even">
<td style="text-align: left;">SQLite(内存型)</td>
<td style="text-align: center;">sqlite:///或sqlite:///:memory</td>
</tr>
</tbody>
</table>
<p>在Flask-SQLAlchemy中，数据库的URI通过配置变量SQLALCHEMY_DATABASE_URI设置，默认为SQLite内存型数据库。 SQLite是基于文件的dbms，不需要设置数据库服务器，只需要制定数据库文件的绝对路径。使用app.root_path来定位数据库文件的绝对路径，并将数据库文件命名为data.py。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">...</span><br><span class="line">app.config[&#39;SQLALCHEMY_DATABASE_URI&#39;] &#x3D; os.getenv(&#39;DATABASE_URL&#39;, &#39;sqlite:&#x2F;&#x2F;&#x2F;&#39; + </span><br><span class="line">    os.path.jpin(app.root_path, &#39;data.db&#39;))</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p><code>os.getenv(key, default)</code> Return the value of the environment variable key if it exists, or default if it doesn’t.</p>
<p>安装并初始化Flask-SQLAlchemy后，启动程序会看到命令行有一段警告信息。这是因为Flask-SQLAlchemy建议你设置<code>SQLALCHEMY_TRACK_MODIFICATIONS</code>配置变量，这个配置决定是否追踪对象的修改，这用语Flask-SQLAlchemy的事件通知系统，如果没有特殊需求设置为False，来关闭警告信息： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.config[&#39;SQLALCHEMY_TRACK_MODIFICATIONS&#39;] &#x3D; False</span><br></pre></td></tr></table></figure></p>
<h3 id="定义数据库模型">定义数据库模型</h3>
<p>用来映射到数据库表的python类被称为数据库模型(models)。一个数据库模型类对应数据库中的一个表，所有的模型类都需要继承Flask-SQLAlchemy提供的db.Model基类。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Note</span>(<span class="params">db.model</span>):</span></span><br><span class="line">    <span class="built_in">id</span> = db.Colum(db.integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    body = db.Colum(db.Text)</span><br><span class="line"></span><br></pre></td></tr></table></figure> <strong>SQLAlchemy常用字段类型</strong> <img src="https://s1.ax1x.com/2018/11/24/FFhmPe.png" /> 字段类型一般直接声明，如果要传入参数，也可以添加括号。</p>
<hr />
<p>默认情况下，Flask-SQLAlchemy会根据模型类的名称生成一个名称，生成规则如下: - 单个单词转换为小写 - 多个单词转换为小写并使用下划线分割</p>
<p>如果想自己指定表名称，可以通过定义__tablename__属性来实现。</p>
<p><strong>实例化字段类常用的字段参数</strong> <img src="https://s1.ax1x.com/2018/11/24/FFhsaT.png" /></p>
<p>实例化字段类时，通过把参数<code>primary_key</code>设为True将其定义为主键。主键是每一条记录独一无二的标识，也是模型类中必须定义的字段。</p>
<h3 id="创建数据库和表">创建数据库和表</h3>
<p>创建模型类后，我们需要手动创建数据库和对应的表。这通过db对象的<code>create_all()</code>方法实现。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from app import db</span><br><span class="line"></span><br><span class="line">db.create_all()</span><br><span class="line"></span><br></pre></td></tr></table></figure> ---- 数据库和表一旦建立后，之后对模型的改动不会自动作用到实际的表中。比如在模型类中添加或删除字段，修改字段的名称和类型，这时再次调用<code>create_all()</code>方法也不会更新表结构。如果要使改动生效，最简单的方式是调用<code>db.drop_all()</code>方法删除数据库和表，然后再用<code>create_all()</code>方法创建。</p>
<hr />
<h3 id="数据库操作">数据库操作</h3>
<p>SQLAlchemy使用<em>数据库会话/事务(transaction)</em>来管理数据库操作，Flask-SQLAlchemy自动帮我们创建绘画，可以通过<code>db.session</code>属性来获取。这里的会话对象和Flask中的session无关。</p>
<p>数据库中的会话代表一个临时储存去，你对数据库做的改动都在这里，只有对session对象调用<code>commit()</code>方法时，改动才会被提交到数据库。会话也支持回滚操作，当调用<code>rollback()</code>方法是，添加到会话中且未提交的改动都将被撤销。</p>
<h3 id="curd">CURD</h3>
<h4 id="create">Create</h4>
<p>添加一条新记录到数据库主要分为三步 1. 实例化模型类作为一条记录 2. 添加新创建的记录到数据库会话 3. 提交数据库会话 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> app <span class="keyword">import</span> db, Note</span><br><span class="line"></span><br><span class="line">note1 = Note(body=<span class="string">&quot;text one&quot;</span>)</span><br><span class="line">note2 = Note(body=<span class="string">&quot;text two&quot;</span>)</span><br><span class="line">note3 = Note(body=<span class="string">&quot;text three&quot;</span>)</span><br><span class="line">db.session.add(note1)</span><br><span class="line">db.session.add(note2)</span><br><span class="line">db.session.add(note3)</span><br><span class="line"></span><br><span class="line">db.session.commit()</span><br><span class="line"></span><br></pre></td></tr></table></figure> Note类继承自db.Model类，db.Model基类会为Note类提供一个构造函数，接收匹配类属性名称的参数值，并赋值给对应的类属性。</p>
<h3 id="read">Read</h3>
<p>使用模型的query属性<strong>附加调用</strong>各种过滤方法及查询方法可以从数据库中取出数据。 一般来说，一个完整的查询模式遵循下面的模式。</p>
<p><模型类>.query.<过滤方法>.<查询方法></p>
<p>常用的SQLAlchemy查询方法</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">查询方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">all()</td>
<td>返回包含所有查询记录的列表</td>
</tr>
<tr class="even">
<td style="text-align: left;">first()</td>
<td>返回查询的第一条记录，如果未找到，则返回None</td>
</tr>
<tr class="odd">
<td style="text-align: left;">one()</td>
<td>返回第一条记录，若记录数量!=1则抛出错误</td>
</tr>
<tr class="even">
<td style="text-align: left;">get(indent)</td>
<td>传入主键值作为参数，返回指定主键值的记录，如果未找到，则返回None</td>
</tr>
<tr class="odd">
<td style="text-align: left;">count()</td>
<td>返回查询结果的数量</td>
</tr>
<tr class="even">
<td style="text-align: left;">one_or_none()</td>
<td>如果结果数量不唯一，则返回None</td>
</tr>
<tr class="odd">
<td style="text-align: left;">first_or_404</td>
<td>返回第一条，如果未找到则返回404错误响应</td>
</tr>
<tr class="even">
<td style="text-align: left;">get_or_404(indent)</td>
<td>传入主键值作为参数，返回对应主键值的记录，如果未找到，则返回404错误响应</td>
</tr>
<tr class="odd">
<td style="text-align: left;">paginate</td>
<td>返回一个Pagination对象，可以对记录进行分页处理</td>
</tr>
<tr class="even">
<td style="text-align: left;">with_parent(instance)</td>
<td>传入模型实例作为参数，返回和这个实例相关联的对象</td>
</tr>
</tbody>
</table>
<p>SQLAlchemy还提供了许多过滤方法，可以获取更精确的查询。因为对Query对象调用过滤方法将返回一个更精确的Query对象，使用过滤器可以叠加使用。</p>
<p>常用的SQLAlchemy过滤方法</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">查询过滤器</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">filter()</td>
<td style="text-align: left;">使用指定的规则过滤记录，返回新产生的查询对象</td>
</tr>
<tr class="even">
<td style="text-align: left;">filter_by()</td>
<td style="text-align: left;">使用指定规则过滤记录，返回新的查询对象</td>
</tr>
<tr class="odd">
<td style="text-align: left;">order_by</td>
<td style="text-align: left;">根据指定条件对记录进行排序，返回新产生的查询对象</td>
</tr>
<tr class="even">
<td style="text-align: left;">limit(limit)</td>
<td style="text-align: left;">根据指定的值限制原查询返回的记录数量，返回新产生的查询对象</td>
</tr>
<tr class="odd">
<td style="text-align: left;">group_by()</td>
<td style="text-align: left;">根据指定的值对记录进行分组，返回新产生的查询对象</td>
</tr>
<tr class="even">
<td style="text-align: left;">offset(offset)</td>
<td style="text-align: left;">使用指定的值偏移原查询结果，返回新产生的查询对象</td>
</tr>
</tbody>
</table>
<p><code>Note.query.filter(Note.body=='note one').first()</code> 其他常用查询操作符： <strong>LIKE</strong> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filter(Note.body.like(&#39;%foo%&#39;))</span><br></pre></td></tr></table></figure></p>
<p><strong>IN</strong> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filter(Note.body.in([&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;]))</span><br></pre></td></tr></table></figure></p>
<p><strong>NOT IN</strong> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filter(~Note.body.in([&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;]))</span><br></pre></td></tr></table></figure></p>
<p><strong>AND</strong> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from sqlalchemy import and_</span><br><span class="line"># 使用and_()</span><br><span class="line">filter(and_(Note.body&#x3D;&#x3D;&#39;bar&#39;, Note.title&#x3D;&#x3D;&#39;foo&#39;))</span><br><span class="line"></span><br><span class="line"># 使用逗号分隔</span><br><span class="line">filter(Note.body&#x3D;&#x3D;&#39;bar&#39;, Note.title&#x3D;&#x3D;&#39;foo&#39;)</span><br><span class="line"></span><br><span class="line"># 叠加使用过滤方法</span><br><span class="line">filter(...).filter(...)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><strong>OR</strong> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from sqlalchemy import or_</span><br><span class="line">filter(or_(Note.body&#x3D;&#x3D;&#39;foo&#39;, Note.title&#x3D;&#x3D;&#39;bar&#39;))</span><br></pre></td></tr></table></figure></p>
<h3 id="upate">Upate</h3>
<p>直接赋值给模型类的字段属性就可以改变字段值，然后调用<code>commit()</code>方法提交会话即可。</p>
<h3 id="delete">delete</h3>
<p>和添加记录类似，不过要用<code>delete()</code>方法，最后调用<code>commit()</code>方法提交修改。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; note &#x3D; Note.query(2)  # 主键为2</span><br><span class="line">&gt;&gt;&gt; db.session.delete(note)</span><br><span class="line">&gt;&gt;&gt; db.commit()</span><br></pre></td></tr></table></figure></p>
<h2 id="在视图函数中操作数据库">在视图函数中操作数据库</h2>
<h3 id="create-1">Create</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@app.route(&#39;&#x2F;new&#39;, methods&#x3D;[&#39;POST&#39;, &#39;GET&#39;])</span><br><span class="line">def new_note():</span><br><span class="line">    form &#x3D; NewNoteForm()</span><br><span class="line">    if form.validate_on_submit():</span><br><span class="line">        body &#x3D; form.body.data</span><br><span class="line">        note &#x3D; Note(body&#x3D;body)</span><br><span class="line">        db.session.add(note)</span><br><span class="line">        db.session.commit()</span><br><span class="line">        flash(&#39;your note is saved&#39;)</span><br><span class="line">        return redirect(url_for(&#39;index&#39;))</span><br><span class="line">    return render_template(&#39;new_note.html&#39;, form&#x3D;form)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h3 id="read-1">Read</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@app.route(&#39;&#x2F;&#39;)</span><br><span class="line">def index():</span><br><span class="line">    form.DeleteForm()</span><br><span class="line">    notes &#x3D; Note.query.all()</span><br><span class="line">    return render_template(&#39;index.html&#39;, notes&#x3D;notes, form&#x3D;form)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="update">Update</h3>
<p>和create相似 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@app.route(&#39;&#x2F;edit&#x2F;&lt;int:note_id&gt;&#39;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;])</span><br><span class="line">def edit_note(note_id):</span><br><span class="line">    form &#x3D; EditNoteForm()</span><br><span class="line">    note &#x3D; Note.query.get(note_id)</span><br><span class="line">    if form.validate_on_submit():</span><br><span class="line">        note.body &#x3D; form.body.data</span><br><span class="line">        db.session.commit()</span><br><span class="line">        flash(&#39;note is updated&#39;)</span><br><span class="line">        return redirect(url_for(&#39;index&#39;))</span><br><span class="line">    form.body.data &#x3D; note.body</span><br><span class="line">    return render_template(&#39;edit_note.html&#39;, form)</span><br></pre></td></tr></table></figure></p>
<h3 id="delete-1">Delete</h3>
<p>不能添加一个指向删除视图的链接，因为有CSRF攻击的风险，像删除这类修改数据的操作绝对不能通过get请求实现，<strong>正确的做法</strong>是为删除操作创建一个表单。如下 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeleteNoteForm</span>(<span class="params">FlaskForm</span>):</span></span><br><span class="line">    submit = SubmitField(<span class="string">&#x27;Delete&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@app.route(&#39;&#x2F;delete&#x2F;&lt;int:note_id&gt;&#39;, methods&#x3D;[&#39;POST&#39;])</span><br><span class="line">def delete_note(note_id):</span><br><span class="line">    form &#x3D; DeleteNoteForm()</span><br><span class="line">    if form.validate_on_submit():   # 主要是验证CSRF令牌，要在模板中手动渲染form.csrf_token</span><br><span class="line">        note &#x3D; Note.query.get(note_id)</span><br><span class="line">        db.session.delete(note)</span><br><span class="line">        db.session.commit()</span><br><span class="line">        flash(&#39;note is deleted&#39;)</span><br><span class="line">    else:</span><br><span class="line">        abort(400)</span><br><span class="line">    return redirect(url_for(&#39;index&#39;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="定义关系">定义关系</h2>
<h3 id="一对多">一对多</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Author(db.Model):</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    phone</span><br><span class="line"></span><br><span class="line">class Article(db.Model):</span><br><span class="line">    id</span><br><span class="line">    title</span><br><span class="line">    body</span><br></pre></td></tr></table></figure>
<p>目的是在Author类中添加一个articles属性，当对特定的Author对象调用articles属性会返回相关Article对象。 #### 一、定义外键 外键是在表A存储表B的<em>主键值</em>，以便和表B建立联系的关系字段。因为怪键只能存储单一数据（标量），使用外键总是在“多”的一侧定义，多篇文章属于一个作者，所以我们需要在文章添加外键，存储作者的主键值以指向对应的作者。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Article(db.Model):</span><br><span class="line">    ...</span><br><span class="line">    author_id &#x3D; db.Colum(db.Interger, db.ForeignKey(&#39;author.id&#39;))</span><br></pre></td></tr></table></figure> 外键字段的命名没有限制，但传入ForeignKey类的参数<code>author.id</code>中，author指的是表名，id是字段名。默认为类的名称的小写形式，多个单词通过下划线分割。可以通过<code>__tablename__</code>属性指定。</p>
<h4 id="二定义关系属性">二、定义关系属性</h4>
<p>定义关系的第二部是使用关系函数定义关系属性。<strong>关系属性在关系的出发侧定义</strong> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Author(db.Model):</span><br><span class="line">    ...</span><br><span class="line">    articles &#x3D; db.relationship(&#39;Aticle&#39;)</span><br></pre></td></tr></table></figure> 这个属性并没有使用Column类来声明为列，而是使用了<code>db.relationship()</code>定义为关系属性。因为这个关系属性返回多条记录，我们称之为<em>集合关系属性</em>。 relationship()函数的第一个参数为关系另一侧模型的名称，他会告诉SQLAlchemy将Author类与Article类建立关系。当这个关系被调用时，SQLAlchemy会找到关系另一侧的外键字段(author_id)，然后反响查询article表中所有author_id值为当前主键值(author.id)的记录。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; foo &#x3D; Author(name&#x3D;&#39;foo&#39;)</span><br><span class="line">&gt;&gt;&gt; spam &#x3D; Aticle(title&#x3D;&#39;spam&#39;)</span><br><span class="line">&gt;&gt;&gt; ham &#x3D; Article(title&#x3D;&#39;ham&#39;)</span><br><span class="line">&gt;&gt;&gt; db.session.add(foo)</span><br><span class="line">&gt;&gt;&gt; db.session.add(spam)</span><br><span class="line">&gt;&gt;&gt; db.session.add(ham)</span><br><span class="line"></span><br></pre></td></tr></table></figure> ### 三、建立关系 有两种方式，第一种是为外键赋值。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; spam.author_id &#x3D; 1</span><br><span class="line">&gt;&gt;&gt; db.session.commit()</span><br></pre></td></tr></table></figure> 将spam的author_id设为1，会和id为1的Author建立关系。</p>
<p>另一种方式是通过操作关系属性，将关系属性赋值给实际的对象即可建立关系。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; foo.articles.append(spam)</span><br><span class="line">&gt;&gt;&gt; foo.articles.append(ham)</span><br><span class="line">&gt;&gt;&gt; db.session.commit()</span><br></pre></td></tr></table></figure> 使用<code>remove()</code>方法可以解除关系，<code>pop()</code>方法可以与关系属性列表的最后一个对象解除关系并返回该对象。</p>
<p>常用的SQLAlchemy关系函数参数</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">参数名</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">back_populates</td>
<td style="text-align: left;">定义反向引用，用于建立双向关系，在关系的另一侧也必须现实定义关系属性</td>
</tr>
<tr class="even">
<td style="text-align: left;">backref</td>
<td style="text-align: left;">添加反向引用，自动在另一侧建立关系属性</td>
</tr>
<tr class="odd">
<td style="text-align: left;">lazy</td>
<td style="text-align: left;">指定如何加载相关记录</td>
</tr>
<tr class="even">
<td style="text-align: left;">useklist</td>
<td style="text-align: left;">指定是否使用列表形式加载记录</td>
</tr>
<tr class="odd">
<td style="text-align: left;">cascade</td>
<td style="text-align: left;">设置级联操作</td>
</tr>
<tr class="even">
<td style="text-align: left;">order_by</td>
<td style="text-align: left;">指定家在相关记录时的排序方式</td>
</tr>
<tr class="odd">
<td style="text-align: left;">secondary</td>
<td style="text-align: left;">在多对多关系中指定关联表</td>
</tr>
<tr class="even">
<td style="text-align: left;">primaryjoin</td>
<td style="text-align: left;">指定多对多关系中的一级联结条件</td>
</tr>
<tr class="odd">
<td style="text-align: left;">secondaryjoin</td>
<td style="text-align: left;">指定多对多关系中的二级联结条件</td>
</tr>
</tbody>
</table>
<p>常用的SQLAlchemy关系记录加载方式(lazy参数可选值)</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">关系加载方式</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">select</td>
<td style="text-align: left;">在必要时一次性加载疾苦，返回包含记录的列表，等同于lazy=True</td>
</tr>
<tr class="even">
<td style="text-align: left;">joined</td>
<td style="text-align: left;">和父查询一样加载记录，但使用联结，等同于lazy=False</td>
</tr>
<tr class="odd">
<td style="text-align: left;">immediate</td>
<td style="text-align: left;">一旦父查询加载就加载</td>
</tr>
<tr class="even">
<td style="text-align: left;">subquery</td>
<td style="text-align: left;">类似joined，不过使用自查询</td>
</tr>
<tr class="odd">
<td style="text-align: left;">dymamic</td>
<td style="text-align: left;">不知加载记录，而是返回一个包含相关记录的query对象</td>
</tr>
</tbody>
</table>
<h3 id="建立双向关系">建立双向关系</h3>
<p>两侧都添加关系属性获取对方记录的关系为双向关系。双向关系的建立很简单，通过在关系的另一侧也创建一个relationship()函数，我们就可以在两个表之间建立双向关系。</p>
]]></content>
      <categories>
        <category>flask学习笔记</category>
      </categories>
      <tags>
        <tag>flask</tag>
        <tag>数据库</tag>
        <tag>ORM</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>窗口大小、有效数据率、信道利用率计算</title>
    <url>/2021/08/06/flow-control-cal/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="窗口大小">窗口大小</h2>
<h3 id="停止等待协议">停止等待协议</h3>
<p><span class="math inline">\(W_T = W_R = 1\)</span></p>
<h3 id="gbn协议">GBN协议</h3>
<p><span class="math inline">\(W_T \ge 1, W_R = 1\)</span></p>
<p><strong>若用n个bit对帧序列进行编号，$W_T ^{n}-1 $​</strong></p>
<h3 id="选择重传协议">选择重传协议</h3>
<p>$ W_T , W_R $</p>
<p><span class="math inline">\(W_T \ge W_R\)</span>，否则接收窗口永远不满，无意义</p>
<p>若用n个bit对帧序列进行编号，<span class="math inline">\(W_T + W_R \le 2^n\)</span></p>
<p>一般情况下<span class="math inline">\(W_R = W_T\)</span>，所以最大值为<span class="math inline">\(W_{Tmax} = W_{Rmax} = 2^{n-1}\)</span></p>
<h2 id="有效数据率">有效数据率</h2>
<p>首先要知道<em>发送周期</em>指的是：<strong>T=发送延时+RTT</strong>，若在T时间内发送mbit数据，则有效数据率<span class="math inline">\(V=\frac{m}{T}\)</span>​</p>
<p>设：</p>
<ul>
<li><p>帧大小：L</p></li>
<li><p>两主机间单向传播时间：t，则RTT为2t</p></li>
<li><p>信道带宽/数据传输率：M</p></li>
<li><p>发送周期：<span class="math inline">\(T = \frac{L}{M} + 2t + 确认帧发送时间\)</span>​​</p>
<blockquote>
<p>如果题目忽略确认帧发送时间就不算括号内的，如果题目中说确认帧由数据帧捎带，意思是确认帧的发送时间和数据帧发送时间一样为<span class="math inline">\(\frac{L}{M}\)</span>​, 王道P81</p>
</blockquote></li>
</ul>
<h3 id="停止等待协议-1">停止等待协议</h3>
<p>由于必须收到确认才能再次发送，所以一个发送周期之内发送一帧，所以 <span class="math display">\[
V=\frac{L}{T} = \frac{L}{\frac{L}{M}+2t}
\]</span></p>
<h3 id="gbn协议-1">GBN协议</h3>
<p>设窗口大小为n</p>
<p>在收到确认前可以发送n个帧，所以 <span class="math display">\[
V = \frac{nL}{T} = \frac{nL}{\frac{L}{M}+2t}
\]</span></p>
<h3 id="选择重传协议-1">选择重传协议</h3>
<p>同上</p>
<h2 id="信道利用率">信道利用率</h2>
<p><span class="math display">\[
信道利用率=\frac{数据传输时间}{发送数据周期}=\frac{\frac{nL}{M}}{T}
\]</span></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>流量控制</tag>
      </tags>
  </entry>
  <entry>
    <title>go func</title>
    <url>/2019/06/13/go-func/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="特点">特点</h2>
<ol type="1">
<li>多个返回值</li>
<li>参数传递都是值传递</li>
<li>函数可以作为变量值</li>
<li>函数可以作为参数和返回值</li>
</ol>
<h2 id="可变参数">可变参数</h2>
<p>参数数量可变 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(ops ...<span class="keyword">int</span>)</span><span class="title">int</span></span> &#123;</span><br><span class="line">  res = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> _, op := <span class="keyword">range</span> ops &#123;</span><br><span class="line">    res += op</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="defer">defer</h2>
<ol type="1">
<li>defer会在函数执行完成后调用</li>
<li>panic不会影响defer的执行</li>
</ol>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title>go net/http使用方法</title>
    <url>/2019/08/13/go-http/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="get-post">get, post</h2>
<h3 id="基本用法">基本用法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">&quot;http://example.com/&quot;</span>)</span><br><span class="line"></span><br><span class="line">resp, err := http.Post(<span class="string">&quot;http://example.com/upload&quot;</span>, <span class="string">&quot;image/jpeg&quot;</span>, &amp;buf)</span><br><span class="line"></span><br><span class="line">resp, err := http.PostForm(<span class="string">&quot;http://example.com/form&quot;</span>,</span><br><span class="line">	url.Values&#123;<span class="string">&quot;key&quot;</span>: &#123;<span class="string">&quot;Value&quot;</span>&#125;, <span class="string">&quot;id&quot;</span>: &#123;<span class="string">&quot;123&quot;</span>&#125;&#125;)</span><br><span class="line">	</span><br><span class="line"><span class="comment">// 使用完respone后要关闭连接</span></span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取响应中的内容</span></span><br><span class="line">b, _ := ioutil.ReadAll(resp.Body) <span class="comment">// b 为[]byte类型 需要类型转换</span></span><br><span class="line">s := <span class="keyword">string</span>(b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Post方法参数分别为 url, content-type, data。data要和content-type对应。<a href="https://zhuanlan.zhihu.com/p/129057481">具体看这里</a></p>
<h2 id="client">client</h2>
<p>要管理HTTP客户端的头域、重定向策略和其他设置，创建一个Client： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">	Transport RoundTripper</span><br><span class="line">  CheckRedirect <span class="function"><span class="keyword">func</span><span class="params">(req *Request, via []*Request)</span> <span class="title">error</span></span></span><br><span class="line">  Jar CookieJar <span class="comment">// 给client插入cookie，每次请求都会带上它</span></span><br><span class="line">  Timeout time.Duration <span class="comment">// 说明每次请求的最大时间</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="header">header</h2>
<p>使用 <code>func NewRequest(method, urlStr string, body io.Reader) (*Request, error)</code>创建一个request 后，可以管理header <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数：请求方法，url，请求数据</span></span><br><span class="line"> req, _ := http.NewRequest(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;http://blacston.com&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"> req.Header.Add(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="cookies">cookies</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">jar := cookiejar.Jar&#123;&#125;</span><br><span class="line">jar.SetCookies(<span class="string">&quot;url&quot;</span>, cookies)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cookie <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="keyword">string</span></span><br><span class="line">	Value <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	Path       <span class="keyword">string</span>    <span class="comment">// optional</span></span><br><span class="line">	Domain     <span class="keyword">string</span>    <span class="comment">// optional</span></span><br><span class="line">	Expires    time.Time <span class="comment">// optional</span></span><br><span class="line">	RawExpires <span class="keyword">string</span>    <span class="comment">// for reading cookies only</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// MaxAge=0 means no &#x27;Max-Age&#x27; attribute specified.</span></span><br><span class="line">	<span class="comment">// MaxAge&lt;0 means delete cookie now, equivalently &#x27;Max-Age: 0&#x27;</span></span><br><span class="line">	<span class="comment">// MaxAge&gt;0 means Max-Age attribute present and given in seconds</span></span><br><span class="line">	MaxAge   <span class="keyword">int</span></span><br><span class="line">	Secure   <span class="keyword">bool</span></span><br><span class="line">	HttpOnly <span class="keyword">bool</span></span><br><span class="line">	SameSite SameSite</span><br><span class="line">	Raw      <span class="keyword">string</span></span><br><span class="line">	Unparsed []<span class="keyword">string</span> <span class="comment">// Raw text of unparsed attribute-value pairs</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="example">Example</h2>
<ul>
<li><p>header</p>
<p>content-type: application/json</p></li>
<li><p>body:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;username&quot;</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;password&quot;</span>: <span class="string">&quot;passowrd&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    client := http.DefaultClient</span><br><span class="line">    reqUrl := <span class="string">&quot;http://121.36.63.57:8888/user/login&quot;</span></span><br><span class="line">    data := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">    data[<span class="string">&quot;username&quot;</span>] = <span class="string">&quot;admin&quot;</span></span><br><span class="line">    data[<span class="string">&quot;password&quot;</span>] = <span class="string">&quot;password&quot;</span></span><br><span class="line"></span><br><span class="line">    jsonData, err := json.Marshal(data)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req, _ := http.NewRequest(http.MethodPost, reqUrl, strings.NewReader(<span class="keyword">string</span>(jsonData)))</span><br><span class="line"></span><br><span class="line">    req.Header.Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">    resp, _ := client.Do(req)</span><br><span class="line">    b, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/AdrianDuan/CCSL/blob/master/utils/password.go">ShuLogin</a></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>go map</title>
    <url>/2019/06/13/go-map/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="声明赋值初始化">声明赋值初始化</h2>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">b[<span class="string">&quot;age&quot;</span>] = <span class="number">1</span></span><br><span class="line">c = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">10</span>) <span class="comment">// 10为容量</span></span><br></pre></td></tr></table></figure>
<h2 id="遍历">遍历</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">  fmt.Println(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他要注意的地方">其他要注意的地方</h2>
<h3 id="访问不存在的key会返回0值">访问不存在的key会返回0值</h3>
<p>不能通过判断是否为nil来判断是否存在 如何判断是0还是不存在？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">if</span> v, ok := a[<span class="number">3</span>]; ok &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%d&#x27;s value exists&quot;</span>, v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%d&#x27;s value does not exists&quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="map的value可以是一个方法">map的value可以是一个方法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMap</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(op <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;&#125;</span><br><span class="line">  m1 := <span class="function"><span class="keyword">func</span><span class="params">(op <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> op &#125;</span><br><span class="line">  m2 := <span class="function"><span class="keyword">func</span><span class="params">(op <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> op*op &#125;</span><br><span class="line">  m[<span class="string">&quot;one&quot;</span>] = m1</span><br><span class="line">  m[<span class="string">&quot;two&quot;</span>] = m2</span><br><span class="line">  fmt.Println(m[<span class="string">&quot;one&quot;</span>](<span class="number">4</span>), m[<span class="string">&quot;two&quot;</span>](<span class="number">4</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用map实现set">用map实现set()</h3>
<ol type="1">
<li>元素唯一 <code>map[type] bool</code></li>
<li>添加 <code>m[1]=true</code></li>
<li>判断存在 <code>if m[1]</code></li>
<li>删除 <code>delete(m, 1)</code></li>
<li>个数 <code>len(m)</code></li>
</ol>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>go 面向对象</title>
    <url>/2019/06/13/go-object/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="封装数据和方法">封装数据和方法</h2>
<h3 id="结构体">结构体</h3>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID    <span class="keyword">int</span></span><br><span class="line">  Name  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化: <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">e := Employee(<span class="number">1</span>, <span class="string">&quot;bob&quot;</span>)</span><br><span class="line">e1 := Employee(ID: <span class="number">2</span>, Name: <span class="string">&quot;bob&quot;</span>)</span><br><span class="line">e2 := <span class="built_in">new</span>(Employee) <span class="comment">// 这里返回的是指针</span></span><br><span class="line">e2.ID = <span class="number">3</span>  <span class="comment">// 指针可以直接用.访问属性</span></span><br></pre></td></tr></table></figure></p>
<h4 id="结构体可以内嵌">结构体可以内嵌</h4>
<ul>
<li>可以内嵌，而且只有字段的类型是必须的</li>
<li>内嵌的结构体可以直接访问其成员变量 结构体实例访问任意一级的嵌入结构体成员时都只用给出字段名，而无须像传统结构体字段一样，通过一层层的结构体字段访问到最终的字段。例如，ins.a.b.c的访问可以简化为ins.c。</li>
<li>内嵌结构体的字段名是它的类型名</li>
<li><a href="http://c.biancheng.net/view/74.html">初始化</a></li>
</ul>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Base <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	Base</span><br><span class="line">  	Name  <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">	e := &amp;Employee&#123;Base: Base&#123;ID: <span class="string">&quot;12313&quot;</span>&#125;, Name: <span class="string">&quot;bob&quot;</span>, <span class="keyword">int</span> :<span class="number">4</span>&#125;</span><br><span class="line">	e1 := <span class="built_in">new</span>(Employee)</span><br><span class="line">	e1.ID = <span class="string">&quot;123&quot;</span></span><br><span class="line">	e1.Name = <span class="string">&quot;Amy&quot;</span></span><br><span class="line">	fmt.Println(e)</span><br><span class="line">	fmt.Println(e.<span class="keyword">int</span>)</span><br><span class="line">	fmt.Println(e1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现方法">实现方法</h3>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;ID: %d - Name: %s&quot;</span>, e.ID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;ID: %d - Name: %s&quot;</span>, e.ID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一种定义的方法在调用的时候会复制实例对象, 为了避免内存拷贝选择第二种</p>
<h3 id="interface">interface</h3>
<ul>
<li><p>因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。</p></li>
<li><p>如果一个任意类型 T 的方法集为一个接口类型的方法集的超集，则我们说类型 T 实现了此接口类型。T 可以是一个非接口类型，也可以是一个接口类型。实现关系在Go语言中是隐式的。两个类型之间的实现关系不需要在代码中显式地表示出来</p></li>
<li><p>接口类型命名一般以er结尾</p></li>
<li><p>定义函数的时候参数定义成 interface，调用函数的时候就可以做到非常的灵活以。</p></li>
<li><p>函数的参数为interface时，调用函数要传入strcut的指针类型的原因是，*S实现了方法，而不是S。</p></li>
<li><p>尽可能依赖较小的接口，这样才能在更多的地方复用。</p></li>
</ul>
<p>以下代码中，file struct实现了WriteData方法，所以file类型也是DataWriter类型，所以才可以 <code>writer = f</code></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个数据写入器</span></span><br><span class="line"><span class="keyword">type</span> DataWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    WriteData(data <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义文件结构，用于实现DataWriter</span></span><br><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现DataWriter接口的WriteData方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *file)</span> <span class="title">WriteData</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟写入数据</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;WriteData:&quot;</span>, data)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化file</span></span><br><span class="line">    f := <span class="built_in">new</span>(file)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个DataWriter的接口</span></span><br><span class="line">    <span class="keyword">var</span> writer DataWriter</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将接口赋值f，也就是*file类型</span></span><br><span class="line">    writer = f</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用DataWriter接口进行数据写入</span></span><br><span class="line">    writer.WriteData(<span class="string">&quot;data&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。</li>
<li>多个嵌套结构体实现共同实现一个接口，使用者并不关心某个接口的方法是通过一个类型完全实现的，还是通过多个结构嵌入到一个结构体中拼凑起来共同实现的。</li>
</ul>
<h4 id="类型断言">类型断言</h4>
<p><a href="https://juejin.im/post/6844904153056034823">类型断言</a></p>
<h4 id="空接口">空接口</h4>
<p>因为所有类型都实现了空接口的方法，所以所有类型都是空接口类型。 可以给空接口随意赋值，但不可以随意取出（要进行类型断言） <a href="http://c.biancheng.net/view/84.html">http://c.biancheng.net/view/84.html</a></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>object oriented</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>go-切片</title>
    <url>/2019/06/13/go-slice/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://segmentfault.com/a/1190000012326168">数组和切片区别</a> 数组容量固定，不可伸缩，相同维数和长度的数组可以比较，但是切片不可比较</p>
<h2 id="切片">切片</h2>
<h3 id="声明">声明</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">fmt.<span class="built_in">println</span>(a == <span class="literal">nil</span>)</span><br><span class="line">fmt.<span class="built_in">println</span>(b == <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为<code>true, false</code></p>
<p>原因是: 1. 声明但是未使用的切片默认值是nil 2. 已经给b分配了内存空间，所以不为空</p>
<h3 id="使用make构造切片">使用make()构造切片</h3>
<p>make函数的原型是<code>make([]T, size, cap)</code> <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line">d := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">fmt.Println(c == <span class="literal">nil</span>, d == <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure> 输出结果肯定是false, false 因为使用make函数一定发生了内存分配</p>
<h3 id="扩容">扩容</h3>
<p>Go 语言的内建函数 append() 可以为切片动态添加元素。当空间不能容纳足够多的元素时，切片就会进行“扩容”。“扩容”操作往往发生在 append() 函数调用时。 容量的扩展规律按容量的 2 倍数扩充，例如 1、2、4、8、16……，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    numbers = <span class="built_in">append</span>(numbers, i)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;len: %d  cap: %d pointer: %p\n&quot;</span>, <span class="built_in">len</span>(numbers), <span class="built_in">cap</span>(numbers), numbers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">len: 1  cap: 1 pointer: 0xc0420080e8</span><br><span class="line">len: 2  cap: 2 pointer: 0xc042008150</span><br><span class="line">len: 3  cap: 4 pointer: 0xc04200e320</span><br><span class="line">len: 4  cap: 4 pointer: 0xc04200e320</span><br><span class="line">len: 5  cap: 8 pointer: 0xc04200c200</span><br><span class="line">len: 6  cap: 8 pointer: 0xc04200c200</span><br><span class="line">len: 7  cap: 8 pointer: 0xc04200c200</span><br><span class="line">len: 8  cap: 8 pointer: 0xc04200c200</span><br><span class="line">len: 9  cap: 16 pointer: 0xc042074000</span><br><span class="line">len: 10  cap: 16 pointer: 0xc042074000</span><br></pre></td></tr></table></figure></p>
<p>切片的cap大小取决于原数组，比如： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">b := a[<span class="number">2</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure> b的cap不是4-2, 而是从原数组2的位置到末尾，所以cap应该是5-2=3</p>
<h3 id="append函数">append()函数</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> car []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个元素</span></span><br><span class="line"><span class="built_in">append</span>(car, <span class="string">&quot;Ice&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加多个元素</span></span><br><span class="line"><span class="built_in">append</span>(car, <span class="string">&quot;BMW&quot;</span>, <span class="string">&quot;Monk&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接两个切片</span></span><br><span class="line">x := []<span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">y := []<span class="keyword">int</span> &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(car)</span><br><span class="line">fmt.Println(appebd(x, y...))</span><br></pre></td></tr></table></figure>
<h3 id="复制切片内容">复制切片内容</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">	c[i] = i*i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接赋值只是引用而不是复制</span></span><br><span class="line">refData := c</span><br><span class="line"><span class="built_in">println</span>(refData[<span class="number">2</span>])</span><br><span class="line">c[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">println</span>(refData[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;----------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用copy函数</span></span><br><span class="line">copyData := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">9</span>)</span><br><span class="line"><span class="built_in">copy</span>(copyData, c)</span><br><span class="line">c[<span class="number">3</span>] = <span class="number">0</span></span><br><span class="line"><span class="built_in">println</span>(copyData[<span class="number">3</span>])</span><br><span class="line"><span class="comment">// println(copyData[9]) 报错</span></span><br></pre></td></tr></table></figure>
<ol type="1">
<li>直接赋值只是引用而不是复制</li>
<li>copy函数并不会自动使copyData扩容</li>
</ol>
<h3 id="删除切片元素">删除切片元素</h3>
<p>Go 语言并没有对删除切片元素提供专用的语法或者接口，需要使用切片本身的特性来删除元素。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">// 删除3</span></span><br><span class="line">index := <span class="number">2</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:index], a[index+<span class="number">1</span>:]...)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%X&quot;</span>, a)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>切片</tag>
      </tags>
  </entry>
  <entry>
    <title>go string</title>
    <url>/2019/06/13/go-string/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="定义赋值初始化">定义赋值初始化</h2>
<p>string是不可变的只读的[]byte类型 unicode是一种字符集 UTF-8是unicode的一种实现，是变长编码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">&quot;中国&quot;</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;中国&quot;</span></span><br></pre></td></tr></table></figure>
<p>len(str)获取的是字节数，不一定是字符数</p>
<p>通过下标访问得到的是字节，需要进行转换或者格式化打印 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">&quot;世界&quot;</span></span><br><span class="line">    <span class="comment">//方法一：格式化打印</span></span><br><span class="line">    <span class="keyword">for</span> _, ch1 := <span class="keyword">range</span> str &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%q&quot;</span>,ch1) <span class="comment">//单引号围绕的字符字面值，由go语法安全的转义</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法二：转化输出格式</span></span><br><span class="line">    <span class="keyword">for</span> _, ch2 := <span class="keyword">range</span> str &#123;</span><br><span class="line">        fmt.Println(<span class="keyword">string</span>(ch2))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="strings包">strings包</h2>
<p><a href="https://golang.org/pkg/strings/">strings</a></p>
<h2 id="strconv包">strconv包</h2>
<p><a href="https://golang.org/pkg/strconv/#example_AppendBool">strconv</a></p>
<h2 id="string常见用法">string常见用法</h2>
<p><a href="http://c.biancheng.net/view/17.html">http://c.biancheng.net/view/17.html</a></p>
<h2 id="rune-和-byte-区别">rune 和 byte 区别</h2>
<p><a href="https://www.cnblogs.com/wanghui-garcia/p/10568354.html">https://www.cnblogs.com/wanghui-garcia/p/10568354.html</a></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>gocv的使用</title>
    <url>/2019/08/07/gocv/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="gocv">gocv</h1>
<h3 id="读取图片">读取图片</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">img := gocv.IMRead(<span class="string">&quot;test.png&quot;</span>, gocv.IMReadColor)</span><br><span class="line">win := gocv.NewWindow(<span class="string">&quot;hi&quot;</span>)</span><br><span class="line">win.IMShow(img)</span><br><span class="line">win.WaitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="创建纯色图片">创建纯色图片</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateImgByBGR</span><span class="params">(sizex <span class="keyword">int</span>, sizey <span class="keyword">int</span>, b <span class="keyword">float64</span>, g <span class="keyword">float64</span>, r <span class="keyword">float64</span>)</span> <span class="title">gocv</span>.<span class="title">Mat</span></span> &#123;</span><br><span class="line">	img := gocv.NewMatWithSizeFromScalar(gocv.NewScalar(b, g, r, <span class="number">255</span>), sizex, sizey, gocv.MatTypeCV8UC3)</span><br><span class="line">	<span class="keyword">return</span> img</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="转换">转换</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">img := gocv.IMRead(<span class="string">&quot;test.png&quot;</span>, gocv.IMReadColor)</span><br><span class="line">dst := gocv.NewMat()</span><br><span class="line">gocv.CvtColor(img, &amp;dst, gocv.ColorBGRToHSV)</span><br><span class="line">win := gocv.NewWindow(<span class="string">&quot;hi&quot;</span>)</span><br><span class="line">win.IMShow(dst)</span><br><span class="line">win.WaitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="inrange">inRange</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	img := gocv.IMRead(<span class="string">&quot;test.png&quot;</span>, gocv.IMReadColor)</span><br><span class="line">	lb := gocv.NewScalar(<span class="number">68</span>, <span class="number">84</span>, <span class="number">153</span>, <span class="number">255</span>)</span><br><span class="line">	ub := gocv.NewScalar(<span class="number">80</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>)</span><br><span class="line">	hsv := gocv.NewMat()</span><br><span class="line">	mask := gocv.NewMat()</span><br><span class="line">	gocv.CvtColor(img, &amp;hsv, gocv.ColorBGRToHSV)</span><br><span class="line">	gocv.InRangeWithScalar(hsv, lb, ub, &amp;mask)</span><br><span class="line">	win := gocv.NewWindow(<span class="string">&quot;hi&quot;</span>)</span><br><span class="line">	win.IMShow(mask)</span><br><span class="line">	win.WaitKey(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="替换绿幕">替换绿幕</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	</span><br><span class="line">	<span class="string">&quot;gocv.io/x/gocv&quot;</span></span><br><span class="line">	<span class="string">&quot;image&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateImg create a solid image based on params</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateImgByBGR</span><span class="params">(sizex <span class="keyword">int</span>, sizey <span class="keyword">int</span>, b <span class="keyword">float64</span>, g <span class="keyword">float64</span>, r <span class="keyword">float64</span>)</span> <span class="title">gocv</span>.<span class="title">Mat</span></span> &#123;</span><br><span class="line">	img := gocv.NewMatWithSizeFromScalar(gocv.NewScalar(b, g, r, <span class="number">255</span>), sizex, sizey, gocv.MatTypeCV8UC3)</span><br><span class="line">	<span class="keyword">return</span> img</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Convert</span><span class="params">(srcPath <span class="keyword">string</span>, dstPath <span class="keyword">string</span>, r, g, b <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lb := gocv.NewScalar(<span class="number">68</span>, <span class="number">84</span>, <span class="number">153</span>, <span class="number">255</span>)</span><br><span class="line">	ub := gocv.NewScalar(<span class="number">80</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>)</span><br><span class="line"></span><br><span class="line">	hsv := gocv.NewMat()</span><br><span class="line">	<span class="keyword">defer</span> hsv.Close()</span><br><span class="line">	mask := gocv.NewMat()</span><br><span class="line">	<span class="keyword">defer</span> mask.Close()</span><br><span class="line">	mask_inv := gocv.NewMat()</span><br><span class="line">	<span class="keyword">defer</span> mask.Close()</span><br><span class="line">	frame := gocv.NewMat()</span><br><span class="line">	<span class="keyword">defer</span> frame.Close()</span><br><span class="line">	person := gocv.NewMat()</span><br><span class="line">	<span class="keyword">defer</span> frame.Close()</span><br><span class="line">	kernel := gocv.GetStructuringElement(gocv.MorphRect, image.Pt(<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">	<span class="keyword">defer</span> kernel.Close()</span><br><span class="line">	<span class="comment">//result := gocv.NewMat()</span></span><br><span class="line">	<span class="comment">//defer frame.Close()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	capt, err := gocv.VideoCaptureFile(<span class="string">&quot;video.mp4&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> capt.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//count := capt.Get(gocv.VideoCaptureFrameCount)</span></span><br><span class="line"></span><br><span class="line">	fps := capt.Get(gocv.VideoCaptureFPS)</span><br><span class="line">	width := <span class="keyword">int</span>(capt.Get(gocv.VideoCaptureFrameWidth))</span><br><span class="line">	height := <span class="keyword">int</span>(capt.Get(gocv.VideoCaptureFrameHeight))</span><br><span class="line">	writer, err := gocv.VideoWriterFile(<span class="string">&quot;output.mp4&quot;</span>, <span class="string">&quot;avc1&quot;</span>, fps, width, height, <span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">defer</span> writer.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ok := capt.Read(&amp;frame); ok &#123;</span><br><span class="line">			gocv.CvtColor(frame, &amp;hsv, gocv.ColorBGRToHSV)</span><br><span class="line">			gocv.InRangeWithScalar(hsv, lb, ub, &amp;mask)</span><br><span class="line"></span><br><span class="line">			gocv.BitwiseNot(mask, &amp;mask_inv)</span><br><span class="line">			gocv.Erode(mask_inv, &amp;mask, kernel)</span><br><span class="line">			gocv.BitwiseAndWithMask(frame, frame, &amp;person, mask_inv)</span><br><span class="line"></span><br><span class="line">			err = writer.Write(person)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Printf(<span class="string">&quot;err occur when write frame: %s&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>golang</category>
        <category>flask学习笔记</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>毕设笔记</title>
    <url>/2021/04/21/graduate-paper/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="论文">论文</h2>
<p>我的毕设论文题目是：<em>科学文献中曲线信息自动提取算法</em>，简单来说就是写一个算法能够从统计图中提取出曲线的信息(包括说明文字)，以及曲线每个点的对应的值。</p>
<h3 id="基本思路">基本思路</h3>
<h4 id="目标提取">目标提取</h4>
<ol type="1">
<li>读取一张图片</li>
</ol>
<p><img src="https://raw.githubusercontent.com/baichen99/pics/master/img/test_img.png" /></p>
<ol start="2" type="1">
<li><p>canny边缘检测+霍夫直线检测检测出水平线和竖直线。</p>
<p><img src="https://raw.githubusercontent.com/baichen99/pics/master/img/lines.png" style="zoom:33%;" /></p></li>
<li><p>提取出最长的两根，根据这两条线求外接矩形得把图像分为<strong>象限内</strong>和<strong>象限外</strong>两部分</p>
<p><img src="https://raw.githubusercontent.com/baichen99/pics/master/img/getAxisCoords.png" style="zoom:33%;" /></p></li>
<li><p>然后使用MSER算法和NMS算法，分别检测X轴，Y轴外侧的文字。</p>
<p><a href="https://zhuanlan.zhihu.com/p/66789730">MSER NMS</a></p></li>
</ol>
<p><img src="https://raw.githubusercontent.com/baichen99/pics/master/img/xyboxes.png" /></p>
<pre><code>1. 可以看到X轴下方有文字和数字两类，数字总是在靠近坐标轴一侧。因此我们从上往下扫描，碰到的第一行检测框即为数字，剩下的为描述文字。根据此方法过滤出数字和描述文字。</code></pre>
<p><img src="https://raw.githubusercontent.com/baichen99/pics/master/img/withdrawNums1.png"/></p>
<p><img src="https://raw.githubusercontent.com/baichen99/pics/master/img/withdrawNums2.png"  /></p>
<h4 id="字符识别算法">字符识别算法</h4>
<p>CRNN+CTC</p>
<p><a href="https://zhuanlan.zhihu.com/p/43534801">参考资料</a></p>
<h4 id="确定曲线上一点的坐标值">确定曲线上一点的坐标值</h4>
<p>这个方法基于文字检测和文字识别算法。</p>
<p><img src="https://raw.githubusercontent.com/baichen99/pics/master/img/%E6%88%AA%E5%B1%8F2021-04-26%20%E4%B8%8B%E5%8D%885.01.49.png" /></p>
<p>工作流程如上图：</p>
<ol type="1">
<li>通过数字识别算法识别出每个方框内的数值nums，并获取检测框中间点的坐标pixels</li>
<li>剔除误差较大的点，并进行线性回归</li>
<li>预测任意一点坐标</li>
</ol>
<p>因为识别结果可能不准确，这样会造成较大误差，所以要先对数据进行清洗。</p>
<p><img src="https://raw.githubusercontent.com/baichen99/pics/master/img/%E6%88%AA%E5%B1%8F2021-04-26%20%E4%B8%8B%E5%8D%885.00.10.png" style="zoom:50%;" /></p>
<p><a href="https://zhuanlan.zhihu.com/p/36301702">随机抽样一致RANSAC: Random Sample Consensus</a></p>
<p><a href="https://blog.csdn.net/mago2015/article/details/84295425">线性回归及RANSAC异常值清除算法案例</a></p>
<h4 id="曲线提取">曲线提取</h4>
<ol type="1">
<li>去噪</li>
<li>otsu二值化</li>
<li>确定曲线位置getAxisCoords</li>
<li>霍夫直线检测去除直线</li>
<li>形态学变换 得到细线</li>
<li>三次样条插值</li>
</ol>
<h2 id="形态学操作">形态学操作</h2>
<p>https://blog.csdn.net/zizi7/article/details/50907949</p>
<h2 id="rnn">RNN</h2>
<h3 id="基本概念">基本概念</h3>
<p><img src="https://raw.githubusercontent.com/baichen99/pics/master/img/rnn-net.png" /></p>
<p><span class="math inline">\(a^{\langle t \rangle} = f(w_a[a^{t-1}, x^{t}])\)</span></p>
<p><span class="math inline">\(y^{\langle t \rangle} = g(w_ya^{t}+b_y)\)</span></p>
<blockquote>
<p><span class="math inline">\(w_a, w_y\)</span>实现了权值共享，另外有的图中<span class="math inline">\(a^{\langle t \rangle}\)</span>也写作<span class="math inline">\(s_{t}\)</span>，表示时间步t的单元状态。</p>
</blockquote>
<p>定义某个时间步t的损失函数（交叉熵损失函数）：</p>
<p><span class="math inline">\(L^{\langle t \rangle}(\hat{y}^{\langle t \rangle}, y^{\langle t \rangle}) = -y^{\langle t \rangle}log\hat{y}^{\langle t \rangle} - (1-y^{\langle t \rangle})log(1-y^{\langle t \rangle})\)</span></p>
<p><span class="math inline">\(y的结果是0或1，\hat y是预测值范围在0到1\)</span></p>
<p>由此可以定义整个网络的损失函数</p>
<p><span class="math inline">\(L(\hat{y}, y) = \sum_{t=1}^{T_y} L^{\langle t \rangle}(\hat{y}^{\langle t \rangle}, y^{\langle t \rangle})\)</span></p>
<p>最后通过反向传播算法求权重。</p>
<h3 id="不同类型的rnn">不同类型的RNN</h3>
<p>上面的例子<span class="math inline">\(T_x = T_y\)</span>，也就是输入x的长度和y相同，我们称之为多对多结构。但实际情况中有不一定是x，y有相同长度。比如有多对一结构：<span class="math inline">\(T_y = 1\)</span> <img src="https://raw.githubusercontent.com/baichen99/pics/master/img/%E6%88%AA%E5%B1%8F2021-04-18%20%E4%B8%8B%E5%8D%884.50.13.png" style="zoom:50%;" /> 一对多结构，比如音频序列生成：<span class="math inline">\(T_x = \varnothing\)</span></p>
<p><img src="https://raw.githubusercontent.com/baichen99/pics/master/img/%E6%88%AA%E5%B1%8F2021-04-18%20%E4%B8%8B%E5%8D%884.49.31.png" style="zoom:50%;" /></p>
<p>多对多结构：比如机器翻译，输入输出的长度都不等</p>
<p><img src="https://raw.githubusercontent.com/baichen99/pics/master/img/%E6%88%AA%E5%B1%8F2021-04-18%20%E4%B8%8B%E5%8D%884.51.00.png" style="zoom:50%;" /></p>
<p><img src="https://raw.githubusercontent.com/baichen99/pics/master/img/%E6%88%AA%E5%B1%8F2021-04-18%20%E4%B8%8B%E5%8D%884.52.09.png" style="zoom:50%;" /></p>
<h3 id="rnn单元">RNN单元</h3>
<p><img src="https://raw.githubusercontent.com/baichen99/pics/master/img/v2-de5ad673d74a07ea40a24f916956e675_b.webp.gif" /></p>
<h3 id="gru简化版">GRU(简化版)</h3>
<p>由于存在梯度消失，前面的状态很难影响到后面的预测。举个例子： <code>the cat, which already ate..., was ...</code></p>
<p>在这个例子中cat是单数，所以后面用was，如果cat是负数则用were。但梯度消失会导致无法根据cat的形式决定be动词形式。</p>
<p>在GRU中 <span class="math inline">\(c^{\langle t \rangle} = a^{\langle t \rangle}\)</span>，然后用<span class="math inline">\(\tilde c^{\langle t \rangle} = tanh(w_c[c^{\langle t-1 \rangle}, x^{\langle t \rangle}])\)</span>替代老的记忆单元。</p>
<p><span class="math inline">\(\Gamma_u\)</span>决定更新与否。<span class="math inline">\(\Gamma_u = sigmoid(w_u[c^{\langle t-1 \rangle}, x^{&lt;t}]+b_u), \Gamma_u\in(0, 1)\)</span></p>
<p><span class="math inline">\(c^{\langle t \rangle} = \Gamma_u * {\tilde c}^{\langle t \rangle} + (1-\Gamma_u)*c^{\langle t-1 \rangle}\)</span></p>
<blockquote>
<p>因为对于大部分输入sigmoid的输出要么非常接近0，要么非常接近1。为了方便理解直接把它的输出看错0或1两个离散值。那么当<span class="math inline">\(\Gamma_u=1时，c^{\langle t \rangle}\)</span>就要更新。=0时保持原来的值不变。</p>
</blockquote>
<p>实例说明：</p>
<p>对于<code>the cat, which already ate..., was ...</code>这个例子设cat对应的t=2， was对应的t=10。</p>
<p>那么假设<span class="math inline">\(c^{2}=1, \Gamma_u=1\)</span> 中间的<span class="math inline">\(\Gamma_u\)</span>都设置为0，那么就有<span class="math inline">\(c^{2}=c^{3}=c^{4} ... =c^{10}=1\)</span>，这样就能让<span class="math inline">\(c^{10}\)</span>保持和<span class="math inline">\(c^{2}\)</span>相同都为1。这样就能根据cat的形式决定be动词的形式了。</p>
<h3 id="lstm">LSTM</h3>
<p>有三个门：<span class="math inline">\(\Gamma_u\)</span>更新门，<span class="math inline">\(\Gamma_f\)</span>遗忘门，<span class="math inline">\(\Gamma_o\)</span>输出门。</p>
<p><span class="math inline">\(\tilde c^{\langle t \rangle} = tanh(w_c[a^{\langle t-1 \rangle}, x^{\langle t \rangle}] + b_c)\)</span></p>
<p><span class="math inline">\(\Gamma_u = sigmod(w_u[a^{\langle t \rangle}, x^{\langle t \rangle}] + b_u)\)</span></p>
<p><span class="math inline">\(\Gamma_o = sigmod(w_o[a^{\langle t \rangle}, x^{\langle t \rangle}] + b_o)\)</span></p>
<p><span class="math inline">\(c^{\langle t \rangle} = \Gamma_u * \tilde c^{\langle t \rangle} + \Gamma_f * c^{\langle t \rangle}\)</span></p>
<p><span class="math inline">\(a^{\langle t \rangle} = \Gamma_o * tanh(c^{\langle t \rangle})\)</span></p>
]]></content>
      <categories>
        <category>毕设</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo中的坑</title>
    <url>/2021/08/09/hexo-bug/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://blog.csdn.net/zhouhangzooo/article/details/90234581">Hexo不显示本地图片解决方案</a></p>
<p>图片路径为<code>xxx.png</code> 不能加文件夹名字，这样本地就看不到图片了</p>
<p><a href="[如何正确的使用 GitHub Actions 实现 Hexo 博客的 CICD | 喵了个咪 (hdj.me">用git actions自动部署</a>](<a href="https://hdj.me/github-actions-hexo-cicd/">https://hdj.me/github-actions-hexo-cicd/</a>))</p>
<p><a href="https://roro4ever.github.io/2019/12/01/hexo-Next主题渲染-latex-公式的配置方法/hexo-next主题渲染-latex-公式的配置方法/">Hexo Next主题渲染 Latex 公式的配置方法 | 桑园巷 (roro4ever.github.io)</a></p>
<p><a href="https://blog.csdn.net/weixin_49884065/article/details/118928018">next主题点击侧边栏的文章目录无法实现跳转的一种情况的解决方法_邈山的博客-CSDN博客</a></p>
<p>不显示摘要</p>
<p><a href="https://github.com/chekun/hexo-excerpt">chekun/hexo-excerpt: Automatic excerpt generator for Hexo (github.com)</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>408考题中常见的隐含条件</title>
    <url>/2021/08/27/implied-term/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="计算机网络">计算机网络</h2>
<h3 id="端口号">端口号</h3>
<table>
<thead>
<tr class="header">
<th>FTP数据链接</th>
<th>FTP控制链接</th>
<th>TELNET</th>
<th>smtp</th>
<th>HTTP</th>
<th>POP3</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>TCP</td>
<td>TCP</td>
<td>TCP</td>
<td>TCP</td>
<td>TCP</td>
<td>TCP</td>
<td></td>
</tr>
<tr class="even">
<td>20</td>
<td>21</td>
<td>23</td>
<td>25</td>
<td>80</td>
<td>110</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>DNS</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>TCP</td>
</tr>
<tr class="even">
<td>20</td>
</tr>
</tbody>
</table>
<blockquote>
<p>FTP数据传输时，服务器的端口时20，客户端的端口可以是其他</p>
</blockquote>
<h3 id="各层协议格式">各层协议格式</h3>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="header">
<th>层</th>
<th>格式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>IP分组</td>
<td>首部固定20B，最大60B<br />总长度1、片偏移8、首部长度4（一种8片首饰）<br />TTL生存时间，经过路由器-1<br />首部校验和只校验首部<br />总长度包括数据和首部<br />源地址和目的地址长度4B</td>
</tr>
<tr class="even">
<td>UDP数据报</td>
<td>首部8B，由4个2B字段组成<br />长度字段包含首部和数据<br />检验和检验首部+数据部分</td>
</tr>
<tr class="odd">
<td>TCP报文段</td>
<td>首部固定20B，最大60B（同IP）<br />源/目的端口占2B(<span class="math inline">\(2^{16}-1=65535\)</span>)<br />序号和确认号各占4B<br /></td>
</tr>
<tr class="even">
<td>MAC帧</td>
<td>前同步码8B<br />MAC地址张度6B<br />最短帧长64B</td>
</tr>
</tbody>
</table>
<p>以太网帧 <strong>18B首部尾部</strong></p>
<p>以太网最小帧64B（最小帧长=总线传播时延x数据传输率x2）</p>
<p>以太网数据最多1500B, 以太网最大1518B，数据最少46B</p>
<h3 id="abc类网络">ABC类网络</h3>
<p>现推方法：</p>
<p>A类：0，网络号为前8位，因此网络号:1~126</p>
<p>B类：10，网络号为前16位，因此网络号:128.1~191.255</p>
<p>C类：110，网络号为前24位，因此网络号:192.0.1~223.255.255</p>
<p>D类：1110</p>
<p>E类：1111</p>
<h3 id="私有网段地址">私有网段地址</h3>
<p>给出私有网段地址，推出可能使用了NAT技术</p>
<table>
<thead>
<tr class="header">
<th>网段数量</th>
<th>类型</th>
<th>地址</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>A</td>
<td><strong>10</strong>.0.0.0～<strong>10</strong>.255.255.255.255</td>
</tr>
<tr class="even">
<td>16</td>
<td>B</td>
<td><strong>172.16</strong>.0.0～<strong>172.31</strong>.255.255</td>
</tr>
<tr class="odd">
<td>256</td>
<td>C</td>
<td><strong>192.168.0</strong>.0～<strong>192.168.255</strong>.255</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C类最重要</p>
</blockquote>
<h3 id="链路层介质">链路层介质</h3>
<p>100BASE-T：100表示传送速度位100Mb/s，BASE表示基带传输，T表示双绞线，如果为F表示光纤</p>
<h2 id="组成原理">组成原理</h2>
<h3 id="c语言数据类型大小">C语言数据类型大小</h3>
<p>long:64</p>
<p>double:64</p>
<p>int: 32</p>
<p>float:32</p>
<p>short: 16</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>c++文件操作</title>
    <url>/2018/10/23/iocaozuo/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="文本类型">文本类型</h2>
<p>文件的类型分为文本文件和二进制文件， <span id="more"></span> 文本文件又称为ASCII文件，它的每个字节存放一个ASCII码，代表一个字符。 二进制文件则是把内存中的数据，按照其在内存中的存储形式原样写在磁盘上存放。 比如一个 short 类型的整数20000，在内存中占用2个字节，而按文本形式输出则占5个字节。 因此在以文本形式输出时，一个字节对应一个字符，因而便于字符的输出，缺点则是占用存储空间较多。 用二进制形式输出数据，节省了转化时间和存储空间，但不能直接以字符的形式输出。</p>
<h2 id="c中的文件操作类">c++中的文件操作类</h2>
<ul>
<li>fstream（输入输出文件流）：支持文件的输入与输出操作；</li>
<li>ifstream（输入文件流）：支持从文件中输入操作；</li>
<li>ofstream（输出文件流）：支持向文件写入的操作；</li>
</ul>
<h2 id="文件的打开和关闭">文件的打开和关闭</h2>
<h3 id="文件的打开">文件的打开</h3>
<p>打开文件有两种方式： 1. 利用构造函数: 在实例化时传入参数<code>ofstream fs(path);</code> 2. 利用open方法: <code>fs.open(path);</code></p>
<p>open方法有很多哥参数，第二个参数指明打开模式 - ios::in 打开文件以便读取 - ios::out 打开文件以便写入 - ios::ate 初始位置：文件尾 - ios::app 所有输出附加在文件末尾 - ios::trunc 如果文件已存在则先删除该文件 - ios::binary 二进制方式</p>
<p>这些方式可以组合使用，使用"|"符号连接 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ofstream fs;  </span><br><span class="line">fs.open(&quot;123.txt&quot;, ios::in|ios::out|ios::binary);</span><br></pre></td></tr></table></figure> #### 默认值 <strong>ofstream、ifstream、fstream 的open函数或者构造函数都有默认的打开文件的方式</strong></p>
<p><code>ofstream fs1("123.txt", ios::out);</code></p>
<p><code>ifstream fs2("123.txt", ios::in);</code></p>
<p><code>fstream fs3("123.txt", ios::in|ios::out);</code></p>
<h4 id="判断文件是否打开成功">判断文件是否打开成功</h4>
<ol type="1">
<li>直接 if 判断 fs 对象； <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ofstream fs(&#39;123.txt&#39;);</span><br><span class="line">if(!fs)</span><br><span class="line">    fs.close();</span><br></pre></td></tr></table></figure></li>
<li>用 is_open 方法判断； fs.is_open() 打开成功返回1，否则返回0</li>
<li>用 good 方法判断； 用法同上</li>
<li>用 fail 方法判断； 返回值和good相反</li>
</ol>
<h3 id="文件流的关闭">文件流的关闭</h3>
<p><code>fs.close();</code></p>
<h2 id="读写操作">读写操作</h2>
<h3 id="文本类型-1">文本类型</h3>
<h4 id="读-get-getline">读 &gt;&gt; get() getline()</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;fstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    var &#x3D; 3000;</span><br><span class="line">    </span><br><span class="line">    ifstream fs_in;</span><br><span class="line">    fs_in.open(&quot;d:\\123.txt&quot;);</span><br><span class="line">    if (!fs_in) return 0;</span><br><span class="line">    fs_in &gt;&gt; var;</span><br><span class="line">    char ch &#x3D; fs_in.get();</span><br><span class="line">    fs_in.close();</span><br><span class="line">    return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>getline()函数原型</li>
</ul>
<p><code>istream&amp; getline (char* s, streamsize n );</code> s 为一个字符数组，不能是string，n为获取字符的长度, 若读取的行数不为最后一行则返回true，使用可以<code>利用while(fs.getline(ch, n)); 来遍历文件的每一行</code> #### 写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;fstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    short var &#x3D; 20000;</span><br><span class="line">    ofstream fs;</span><br><span class="line">    fs.open(&quot;d:\\123.txt&quot;);</span><br><span class="line">    if (!fs) return 0;</span><br><span class="line"></span><br><span class="line">    fs &lt;&lt; var &lt;&lt; endl;</span><br><span class="line">    fs &lt;&lt; &quot;真的是你吗？&quot; &lt;&lt; endl;</span><br><span class="line">    fs.put(&#39;Y&#39;);   &#x2F;&#x2F; 只能输出**单个字符**到文件</span><br><span class="line">    fs.close();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二进制类型">二进制类型</h3>
<p>使用write()方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;fstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    short var &#x3D; 20000;</span><br><span class="line">    ofstream fs;</span><br><span class="line">    fs.open(&quot;d:\\123.txt&quot;);</span><br><span class="line">    if (!fs) return 0;</span><br><span class="line">    </span><br><span class="line">    fs.write((char*)&amp;var, sizeof(var));</span><br><span class="line">    fs.close();</span><br><span class="line">    return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="section"></h3>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>文件操作</tag>
        <tag>C++</tag>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title>ISO/OSI模型、TCP模型</title>
    <url>/2021/08/02/isoosi-tcp/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">层</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">协议</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">应用层</td>
<td style="text-align:center">用户和网络的界面</td>
<td style="text-align:center">smtp/pop3/dns/BGP(TCP)， DHCP，Ping（ICMP）,RIP(UDP), MIME, HTTP,</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">表示层</td>
<td style="text-align:center">数据格式变换、加密解密、数据压缩恢复</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">会话层</td>
<td style="text-align:center">建立同步、校验点恢复通信</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">传输层</td>
<td style="text-align:center">差错控制、流量控制、提供端到端通信、复用分用</td>
<td style="text-align:center">TCP, UDP</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">网络层</td>
<td style="text-align:center">差错控制、路由选择、流量控制、拥塞控制</td>
<td style="text-align:center">IP，ARP，ICMP, OSPF(IP)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">数据链路层</td>
<td style="text-align:center">差错控制、流量控制、传输管理</td>
<td style="text-align:center">PPP, CSMA, HDLC</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">物理层</td>
<td style="text-align:center">定义接口特性</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>通信子网是下面三层，实现点到点的传输，资源子网是上面三层，实现端到端的传输，传输层是中介</p>
</blockquote>
<h2 id="两个模型网络层和传输层差别"><a href="#两个模型网络层和传输层差别" class="headerlink" title="两个模型网络层和传输层差别"></a>两个模型网络层和传输层差别</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">ISO/OSI</th>
<th style="text-align:center">TCP/IP</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">传输层</td>
<td style="text-align:center">面向连接</td>
<td style="text-align:center">无连接+面向连接</td>
</tr>
<tr>
<td style="text-align:center">网络层</td>
<td style="text-align:center">无连接+面向连接</td>
<td style="text-align:center">面向连接</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>无连接意味着不可靠传输，面向连接意味着可靠传输</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>进程</title>
    <url>/2018/06/15/jincheng/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="单核如何实现多任务">单核如何实现多任务?</h3>
<p>依次轮流执行, 看上去像是同时进行</p>
<h3 id="并发与并行">并发与并行?</h3>
<p><strong>并发</strong>是看上去一起执行,任务数大于CPU核心数 <strong>并行</strong>是真正的一起执行, 任务数小于CPU核心数 <span id="more"></span> ### 线程与进程 . 线程：是程序执行流的最小单元，是系统独立调度和分配CPU（独立运行）的基本单位 . 进程：是资源分配的基本单位。一个进程包括多个线程。 对于操作系统而言, 一个任务就是一个进程</p>
<p><strong>区别</strong>： 1. 线程与资源分配无关，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。</p>
<ol start="2" type="1">
<li><p>每个进程都有自己一套独立的资源（数据），供其内的所有线程共享。</p></li>
<li><p>不论是大小，开销线程要更“轻量级”</p></li>
<li><p>一个进程内的线程通信比进程之间的通信更快速，有效。（因为共享变量）</p></li>
</ol>
<h3 id="实现多任务的方式">实现多任务的方式</h3>
<ol type="1">
<li>多进程模式</li>
<li>多线程模式</li>
<li>协程模式</li>
<li>多进程+多线程模式</li>
</ol>
<h3 id="单任务现象">单任务现象</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    print(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">&#x27;bye&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>
<p><strong>这样不会执行run(), 只有上面的while循环结束后才可以执行</strong></p>
<h3 id="实现多任务">实现多任务</h3>
<p><strong>multiprocessing库</strong> --跨平台的多进程模块 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">&quot;hello---%s&quot;</span>%os.getpid()) <span class="comment"># os.getpid()获取当前进程id号, os.getppid()获取当前进程的父进程的id号</span></span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(<span class="string">&quot;主(父)进程启动---%s&quot;</span>%os.getpid())</span><br><span class="line">    <span class="comment"># 创建子进程</span></span><br><span class="line">    p = Process(target=run)   <span class="comment"># 创建进程是为了执行函数, 需要传入两个参数 target=函数和arg=() 传入的参数必须元组, 如果元组只有一个元素后面必须加个逗号, 这样才构成元组</span></span><br><span class="line">    <span class="comment"># 启动进程</span></span><br><span class="line">    p.start()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">&#x27;bye&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">    run() </span><br></pre></td></tr></table></figure></p>
<h3 id="父子进程的先后顺序">父子进程的先后顺序</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">    print(<span class="string">&quot;子进程启动&quot;</span>)</span><br><span class="line">    sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">&quot;子进程结束&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(<span class="string">&quot;父进程启动&quot;</span>)</span><br><span class="line">    p = Process(target=run, args=(<span class="string">&quot;nice&quot;</span>,))</span><br><span class="line">    p.start()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;父进程结束&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">父进程启动</span><br><span class="line">父进程结束</span><br><span class="line">子进程启动</span><br><span class="line">子进程结束</span><br></pre></td></tr></table></figure> <strong>父进程的结束不影响子进程, 怎么让父进程等大子进程结束再执行父进程?</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">    print(<span class="string">&quot;子进程启动&quot;</span>)</span><br><span class="line">    sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">&quot;子进程结束&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(<span class="string">&quot;父进程启动&quot;</span>)</span><br><span class="line">    p = Process(target=run, args=(<span class="string">&quot;nice&quot;</span>,))</span><br><span class="line">    p.start()</span><br><span class="line">    </span><br><span class="line">    p.join() <span class="comment"># 等待进程结束</span></span><br><span class="line">    print(<span class="string">&quot;父进程结束&quot;</span>)</span><br></pre></td></tr></table></figure> ### 全局变量在多个进程中不能共享 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">num = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    print(<span class="string">&quot;子进程开始&quot;</span>)</span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">    print(<span class="string">&quot;子进程结束--%d&quot;</span> % num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(<span class="string">&quot;父进程开始&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建子进程</span></span><br><span class="line">    p = Process(target=run)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join() <span class="comment"># 等待进程结束</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;父进程结束--%s&quot;</span>%num)</span><br></pre></td></tr></table></figure> 执行结果 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">父进程开始</span><br><span class="line">子进程开始</span><br><span class="line">子进程结束--101</span><br><span class="line">父进程结束--100</span><br></pre></td></tr></table></figure> - 在子进程中修改全局变量对父进程全局变量没有影响, 因为在创建子进程时对全局变量做了一个备份, 父进程和子进程的变量独立 - 每个进程都有自己的代码段, 堆栈段, 数据段</p>
<p>如果再创建一个子进程 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建子进程</span></span><br><span class="line">p2 = Process(target=run)</span><br><span class="line">p2.start()</span><br><span class="line">p2.join()  <span class="comment"># 等待进程结束</span></span><br></pre></td></tr></table></figure> 变量依然独立</p>
<h3 id="启动大量子进程">启动大量子进程</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">name</span>):</span></span><br><span class="line">    print(<span class="string">&quot;子进程%s启动--%s&quot;</span> % (name, os.getpid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.choice[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">&quot;子进程%s结束--%s--耗时%.2f&quot;</span> % (name, os.getpid(), end - start))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(<span class="string">&quot;父进程启动&quot;</span>)</span><br><span class="line">    <span class="comment"># 创建多个进程使用进程池</span></span><br><span class="line">    pp = Pool(<span class="number">2</span>) <span class="comment"># 表示可以同时执行的进程数, 默认值是CPU核心数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="comment"># 创建进程, 放入进程池, 同一管理</span></span><br><span class="line">        pp.apply_async(run, args=(i,))</span><br><span class="line">    <span class="comment"># 使用进程池时,在调用之前必须先调用close(), 调用close之后就不能添加新的进程了 </span></span><br><span class="line">    pp.close() </span><br><span class="line">    <span class="comment"># 等待进程池中所有子进程结束再去执行父进程</span></span><br><span class="line">    pp.join()</span><br><span class="line">    print(<span class="string">&quot;父进程结束&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="进程间通信">进程间通信</h3>
<p>进程间通过队列通信, 队列相当于一个中间人的角色 Process之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据。</p>
<p>我们以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写数据进程执行的代码:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">q</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;Process to write: %s&#x27;</span> % os.getpid())</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]:</span><br><span class="line">        print(<span class="string">&#x27;Put %s to queue...&#x27;</span> % value)</span><br><span class="line">        q.put(value)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读数据进程执行的代码:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">q</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;Process to read: %s&#x27;</span> % os.getpid())</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        value = q.get(<span class="literal">True</span>)</span><br><span class="line">        print(<span class="string">&#x27;Get %s from queue.&#x27;</span> % value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 父进程创建Queue，并传给各个子进程：</span></span><br><span class="line">    q = Queue()</span><br><span class="line">    pw = Process(target=write, args=(q,))</span><br><span class="line">    pr = Process(target=read, args=(q,))</span><br><span class="line">    <span class="comment"># 启动子进程pw，写入:</span></span><br><span class="line">    pw.start()</span><br><span class="line">    <span class="comment"># 启动子进程pr，读取:</span></span><br><span class="line">    pr.start()</span><br><span class="line">    <span class="comment"># 等待pw结束:</span></span><br><span class="line">    pw.join()</span><br><span class="line">    <span class="comment"># pr进程里是死循环，无法等待其结束，只能强行终止:</span></span><br><span class="line">    pr.terminate()</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>jwt-go的使用</title>
    <url>/2019/07/26/jwt-go/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="go-jwt">go jwt</h1>
<h2 id="什么是jwt">什么是jwt</h2>
<p>JSON Web Token通常用于 Oauth 2中的<code>Bearer</code> tokens</p>
<p>一个token分成三个部分，用<code>.</code>连接，前两个部分是用base64url编码的json对象，最后一部分是签名，使用相同的编码方式编码。</p>
<ol type="1">
<li><p>第一部分叫header，包含JWT和签名算法比如HMAC, SHA256, RSA <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span>,</span><br><span class="line"><span class="string">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>第二部分叫Playload(Claims)，存储数据 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;userId&quot;</span>: <span class="string">&quot;23581935-afsakngh12i-asdfaf&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> JWT规定了7个官方字段 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iss (issuer)：签发人</span><br><span class="line">exp (expiration time)：过期时间</span><br><span class="line">sub (subject)：主题</span><br><span class="line">aud (audience)：受众</span><br><span class="line">nbf (Not Before)：生效时间</span><br><span class="line">iat (Issued At)：签发时间</span><br><span class="line">jti (JWT ID)：编号</span><br></pre></td></tr></table></figure></p></li>
<li><p>Signature signature是对前两部分的签名，首先需要指定一个算法，按照下面的公式产生 HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)</p></li>
</ol>
<h2 id="jwt使用方式">jwt使用方式</h2>
<p>客户端收到服务器的JWT后，可以放在cookie里和localstorage里，但是这样不能跨域，更好的方法是放在请求头信息。 以后每次客户端与服务器通信都要带上jwt <code>Authorization: Bearer &lt;token&gt;</code> 另一种做法是跨域的时候，jwt放在post数据体中</p>
<h2 id="对称加密方法">对称加密方法</h2>
<p>比如HSA使用单个密钥，所以任意<code>[]byte</code>类型都可以当作一个合法的密钥。对称加密在双方都被信任的情况下最好用。因为签名和验证使用相同的算法，所以不能简单地分发key来验证。</p>
<h2 id="非对称加密方法">非对称加密方法</h2>
<p>非对称加密方法，比如RSA使用不同的key来签名和验证token，这就可以用private key产生token，再允许使用者用public key来验证。</p>
<p>每种签名方法使用不同的类型来签名。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The HMAC signing method (HS256,HS384,HS512) expect []byte values for signing and validation</span><br><span class="line"></span><br><span class="line">The RSA signing method (RS256,RS384,RS512) expect *rsa.PrivateKey for signing and *rsa.PublicKey for validation</span><br><span class="line"></span><br><span class="line">The ECDSA signing method (ES256,ES384,ES512) expect *ecdsa.PrivateKey for signing and *ecdsa.PublicKey for validation</span><br></pre></td></tr></table></figure></p>
<h3 id="hmac方法演示">HMAC方法演示</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/dgrijalva/jwt-go&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateToken</span><span class="params">(mc *jwt.MapClaims, secret []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="comment">// 使用HS256算法(输入HMAC,是对称加密算法)</span></span><br><span class="line">	token := jwt.NewWithClaims(jwt.SigningMethodHS256, mc)</span><br><span class="line">	<span class="comment">// 签名并且获得完整的字符串</span></span><br><span class="line">	tokenString, err := token.SignedString(secret)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;GenerateToken err: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tokenString</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseToken</span><span class="params">(tokenString <span class="keyword">string</span>, secret []<span class="keyword">byte</span>)</span> <span class="params">(jwt.MapClaims ,error)</span></span>  &#123;</span><br><span class="line">	token, err := jwt.Parse(tokenString, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 验证加密算法</span></span><br><span class="line">		<span class="keyword">if</span> _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;Unexpected signing method: %v&quot;</span>, token.Header[<span class="string">&quot;alg&quot;</span>])</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> secret, <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 类型</span></span><br><span class="line">	<span class="keyword">if</span> claims, ok := token.Claims.(jwt.MapClaims); ok &amp;&amp; token.Valid &#123;</span><br><span class="line">		<span class="keyword">return</span> claims, <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	secret := []<span class="keyword">byte</span>(<span class="string">&quot;secret_key&quot;</span>)</span><br><span class="line">	mc := jwt.MapClaims&#123;</span><br><span class="line">		<span class="string">&quot;foo&quot;</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">		<span class="string">&quot;issat&quot;</span>: time.Now().Unix(),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 打印token</span></span><br><span class="line">	tokenString := GenerateToken(&amp;mc, secret)</span><br><span class="line">	fmt.Println(tokenString)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 验证token</span></span><br><span class="line">	claims, err := ParseToken(tokenString, secret)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v&quot;</span>, claims)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="rsa加密方法演示">rsa加密方法演示</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/rsa&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;path/filepath&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/dgrijalva/jwt-go&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GenerateToken receive MapClaims and return a tokenString</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateToken</span><span class="params">(mc jwt.MapClaims, privateKey *rsa.PrivateKey)</span> <span class="params">(tokenString <span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">	token := jwt.NewWithClaims(jwt.SigningMethodRS256, mc)</span><br><span class="line">	tokenString, err = token.SignedString(privateKey)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ParseToken parse the token and return a MapClaims</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseToken</span><span class="params">(tokenString <span class="keyword">string</span>, publicKey *rsa.PublicKey)</span> <span class="params">(claims jwt.MapClaims, err error)</span></span> &#123;</span><br><span class="line">	token, err := jwt.Parse(tokenString, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 验证加密方法是否符合</span></span><br><span class="line">		<span class="keyword">if</span> _, ok := token.Method.(*jwt.SigningMethodRSA); !ok &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unexpected signing method: %v&quot;</span>, token.Header[<span class="string">&quot;alg&quot;</span>])</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> publicKey, <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> claims, ok := token.Claims.(jwt.MapClaims); ok &amp;&amp; token.Valid &#123;</span><br><span class="line">		<span class="keyword">return</span> claims, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	path, err := filepath.Abs(<span class="string">&quot;./demo.rsa&quot;</span>)</span><br><span class="line">	privateByte, err := ioutil.ReadFile(path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	path, err = filepath.Abs(<span class="string">&quot;./demo.rsa.pub&quot;</span>)</span><br><span class="line">	publicByte, err := ioutil.ReadFile(path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	privateKey, _ := jwt.ParseRSAPrivateKeyFromPEM(privateByte)</span><br><span class="line">	publicKey, _ := jwt.ParseRSAPublicKeyFromPEM(publicByte)</span><br><span class="line"></span><br><span class="line">	mc := jwt.MapClaims&#123;</span><br><span class="line">		<span class="string">&quot;name&quot;</span>: <span class="string">&quot;baichen&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tokenString, err := GenerateToken(mc, privateKey)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;GenerateToken error: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	claims, err := ParseToken(tokenString, publicKey)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;ParseToken error: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v&quot;</span>, claims)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2>
<p><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">JWT</a> <a href="http://web.chacuo.net/netrsakeypair">公钥密钥生成</a> <a href="https://blog.csdn.net/skh2015java/article/details/78954293">go读取文本内容</a></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>jwt</tag>
      </tags>
  </entry>
  <entry>
    <title>考研数学：极限中拆不拆的问题</title>
    <url>/2021/04/06/limit/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="原则">原则</h2>
<p>如果分子消不了，就可以拆。</p>
<p>具体来说，设<span class="math inline">\(\alpha \sim \alpha&#39;, \beta \sim \beta&#39;\)</span></p>
<p><span class="math inline">\(lim\frac{\alpha}{\beta} = C\)</span></p>
<p>若 <span class="math inline">\(C\ne-1\)</span> 则<span class="math inline">\(\alpha + \beta \sim \alpha&#39; + \beta&#39;\)</span></p>
<p>若 <span class="math inline">\(C\ne1\)</span> 则<span class="math inline">\(\alpha - \beta \sim \alpha&#39; - \beta&#39;\)</span></p>
<h2 id="例子">例子</h2>
<p><span class="math inline">\(limit_{x \rightarrow 0}\frac{tan2x^2 - x^2}{sinx^2+3x^2}\)</span></p>
<p>当<span class="math inline">\(x \rightarrow 0\)</span>时，<span class="math inline">\(\frac{tan2x^2}{x^2}=2\ne1, \frac{sinx^2}{3x^2}=\frac1 3\ne-1\)</span></p>
<p>所以原式= <span class="math inline">\(\frac 1 4\)</span></p>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>极限</tag>
        <tag>高数</tag>
        <tag>考研数学</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习：线性回归笔记</title>
    <url>/2021/01/25/linner_regression/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><object data="./linner_regression.pdf " type="application/pdf" width="100%" height="900px">
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>线性回归</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常见问题</title>
    <url>/2020/08/17/linux/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="ps--elf">ps -elf</h2>
<p>-e 显示所有进程</p>
<p>-f full format 完整格式</p>
<p>-l long formart</p>
<p>UID： 说明该程序被谁拥有 PID：就是指该程序的 ID PPID： 就是指该程序父级程序的 ID C： 指的是 CPU 使用的百分比 STIME： 程序的启动时间 TTY： 指的是登录终端 TIME : 指程序使用掉 CPU 的时间 CMD： 下达的指令</p>
<h2 id="软硬链接-ln">软硬链接 ln</h2>
<p>软链接：ln -s target linkname 硬链接：ln target linkname</p>
<p>硬链接 不占用空间，源文件和硬链接实际上是同一个文件，当两个文件都删除时，这个文件才会被删除，不能对目录进行链接</p>
<p>软链接相当于一个快捷方式，指向源文件，修改一个文件另一个文件也会跟着改变，但是删除源文件后，软链接就会失效，可以对目录进行链接</p>
<h2 id="复制-cp--r">复制 cp [-r]</h2>
<p>cp src target</p>
<p>cp -r src target // 复制文件夹</p>
<h2 id="删除-rm--r">删除 rm [-r]</h2>
<p>rm -r dir // 递归删除</p>
<p>##chmod</p>
<p>https://blog.csdn.net/pythonw/article/details/80263428</p>
<p>修改文件权限</p>
<p>chomod 用户 操作符 权限 filename</p>
<p>用户有 u(文件所有者), g(文件所隶属的用户组), o(其他用户), a(全部用户)</p>
<p>权限分为w, r, x 分别是只读 只写 可执行</p>
<p>7 = 4 + 2 + 1 读写运行权限</p>
<p>5 = 4 + 1 读和运行权限</p>
<p>4 = 4 只读权限</p>
<p><code>chmod a=rwx main.go</code> 给所有用户读写执行main.go的权限</p>
<p><code>chmod 777 main.go</code> 三个7分别给文件所有者、群组用户、其他用户权限</p>
<h2 id="grep">grep</h2>
<p>匹配正则表达式</p>
<p><code>ps -ef | grep pid</code>查找特定进程</p>
<h2 id="查看命令历史-history">查看命令历史 history</h2>
<p>hitory</p>
<h2 id="查看磁盘使用状况">查看磁盘使用状况</h2>
<p><code>df -hl</code></p>
<h2 id="查看修改主机名2">查看/修改主机名2</h2>
<p><code>hostname</code></p>
<p>显示： ecs-sn3-medium-2-linux-20200107151549</p>
<p>修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim &#x2F;etc&#x2F;sysconfig&#x2F;network</span><br><span class="line"></span><br><span class="line">NETWORKING&#x3D;yes</span><br><span class="line">HOSTNAME&#x3D;centos6.5-1</span><br></pre></td></tr></table></figure>
<p>##进程状态</p>
<p>running 可执行状态，只有在该状态的进程才可能在CPU上运行。</p>
<p>sleeping 中断 在等待某个条件的形成或接收到信号</p>
<p>stopped</p>
<p>zombie 进程已终止，但进程描述还在，等到父进程调用wait后释放</p>
<h2 id="top">top</h2>
<p>性能分析工具，能够实时显示系统中各个进程的资源占用状况</p>
<p>shift+f可以设置排序, 显示字段等选项</p>
<h2 id="devnull">2&gt; /dev/null</h2>
<p><a href="https://www.zhihu.com/question/53295083">shell程序中 2&gt; /dev/null 代表什么意思？</a></p>
<h2 id="环境变量">环境变量</h2>
<p>如果要新增一条环境变量<code>/home/pi/.local/bin</code>可以使用<code>export PATH=$PATH:/home/pi/.local/bin</code> 其中<code>$PATH</code>是当前环境变量，各个环境由:分割，所以这里其实是把以前的环境变量和新增的拼接后重新赋值</p>
<p><a href="https://www.cnblogs.com/youyoui/p/10680329.html">Linux环境变量配置全攻略 - 悠悠i - 博客园 (cnblogs.com)</a></p>
<h2 id="重定向符">&gt;, &lt;, &gt;&gt;, &lt;&lt; 重定向符</h2>
<p><a href="https://www.runoob.com/linux/linux-shell-io-redirections.html">Shell 输入/输出重定向 | 菜鸟教程 (runoob.com)</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络的维数</title>
    <url>/2021/04/15/network-dimension/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="深度神经网络">深度神经网络</h2>
<p><a href="https://zhuanlan.zhihu.com/p/24801814">通俗理解BP</a></p>
<p><img src="network.png" /></p>
<h3 id="定义符号">定义符号</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">符号</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(a^{[l]}\)</span></td>
<td style="text-align: center;">l层的输入</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(w^{l}\)</span></td>
<td style="text-align: center;">l层的权重</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(n^{[l]}\)</span></td>
<td style="text-align: center;">l层的维数</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(z^{[l]}\)</span></td>
<td style="text-align: center;">l层的输出</td>
</tr>
</tbody>
</table>
<h3 id="单个样本">单个样本</h3>
<p><span class="math inline">\(z^{[l]} = w^{[l]}a^{[l]}+b^{[l]}\)</span></p>
<p><span class="math inline">\(a^{[l+1]} = g(z^{[l]})\)</span></p>
<p>对于单个样本，每个<strong>神经元</strong>输出是一个标量</p>
<table>
<thead>
<tr class="header">
<th>符号</th>
<th>维数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(a^{[0]} = x\)</span></td>
<td><span class="math inline">\((n\times1)\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(a^{[l]}\)</span></td>
<td><span class="math inline">\((n^{[l]}\times1)\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(z^{[l]}\)</span></td>
<td><span class="math inline">\((n^{[l]}\times1)\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(w^{[l]}\)</span></td>
<td><span class="math inline">\((n^{[l]}\times n^{[l-1]})\)</span></td>
</tr>
</tbody>
</table>
<h3 id="m个样本">m个样本</h3>
<table>
<thead>
<tr class="header">
<th>符号</th>
<th>维数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(A^{[0]} = X\)</span></td>
<td><span class="math inline">\((n\times m)\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(A^{[l]}\)</span></td>
<td><span class="math inline">\((n^{[l]}\times m)\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(Z^{[l]}\)</span></td>
<td><span class="math inline">\((n^{[l]}\times m)\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(W^{[l]}\)</span></td>
<td><span class="math inline">\((n^{[l]}\times n^{[l-1]})\)</span></td>
</tr>
</tbody>
</table>
<h3 id="section"></h3>
]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>flask+gunicorn+nginx部署</title>
    <url>/2019/12/29/nginx%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ol type="1">
<li><p>买服务器</p></li>
<li><p>ubuntu系统</p></li>
<li><p>开启80 8080端口 <a href="https://www.cnblogs.com/codeman-hf/p/10535923.html">教程</a></p></li>
<li><p>安装nginx</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt upgrade</span><br><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure></li>
<li><p>测试nginx</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service nginx restart</span><br></pre></td></tr></table></figure>
<p>然后访问ip地址 <a href="https://blog.csdn.net/ssssSFN/article/details/89501469">如何查看公网ip</a></p></li>
<li><p>安装docker <a href="https://www.runoob.com/docker/ubuntu-docker-install.html">docker安装教程</a></p></li>
<li><p>编写dockerfile文件</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.8</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /home/web &amp;&amp; <span class="built_in">cd</span> /home/web</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /home/web</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./backend/* /home/web/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -r ./requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple/  \</span></span><br><span class="line"><span class="bash">    &amp;&amp; pip install gunicorn</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">&quot;gunicorn&quot;</span>, <span class="string">&quot;-w&quot;</span>, <span class="string">&quot;5&quot;</span>,  <span class="string">&quot;api:app&quot;</span>]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build . flask:0.1</span><br><span class="line">docker save [image_id] &gt; docker.tar</span><br></pre></td></tr></table></figure></li>
<li><p>在服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker load -i docker.tar</span><br></pre></td></tr></table></figure></li>
<li><p><code>npm run build &amp;&amp; scp dist/* root@ip:path/</code></p></li>
<li><p>编写nginx配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">	server_name  ipAddr;</span><br><span class="line"></span><br><span class="line">	location &#x2F; &#123;</span><br><span class="line">		root &#x2F;root&#x2F;app;</span><br><span class="line">		index index.html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">	listen       8081;</span><br><span class="line">	server_name  ipAddr;</span><br><span class="line"></span><br><span class="line">	location &#x2F; &#123;</span><br><span class="line">		proxy_pass  http:&#x2F;&#x2F;127.0.0.1:8080</span><br><span class="line">		proxy_set_header Host $host;</span><br><span class="line">		proxy_set_header X-Forwarded-For</span><br><span class="line">		$proxy_add_x_forwarded_for;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>docker run -d -p 8080:8080 image_id gunicorn -w 4 api:app</code></p>
<p>报错说明端口占用</p>
<p><code>ps aux | grep 8080</code></p>
<p><code>ps -ef | grep 8080</code></p></li>
</ol>
<h2 id="参考内容">参考内容</h2>
<ol type="1">
<li><a href="https://www.cnblogs.com/doocool/p/8847288.html">Vue+Flask部署到阿里云服务器</a></li>
</ol>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>flask</tag>
        <tag>vue</tag>
        <tag>nginx</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title>opencv 笔记</title>
    <url>/2021/01/16/opencv%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="opencv-笔记">opencv 笔记</h1>
<p><a href="http://codec.wang/">opencv教程</a></p>
<p><a href="https://www.runoob.com/numpy/numpy-ndarray-object.html">numpy教程</a></p>
<span id="more"></span>
<ul>
<li><p><a href="https://blog.csdn.net/weixin_44049693/article/details/106271643">cv2.waitKey用法</a></p></li>
<li><p><a href="https://blog.csdn.net/xbinworld/article/details/65660665">线性插值，双线性插值</a></p></li>
<li><p><a href="http://codec.wang/#/opencv/start/extra-02-high-quality-save-and-matplotlib">使用matplotlib.pyplot显示彩色图</a> <code>img = img[:, :, ::-1]</code></p></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>dip</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>指针,引用和常量</title>
    <url>/2018/09/13/pointer-reference-constant/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="常量指针和指针常量">常量指针和指针常量</h3>
<p><strong>常量指针</strong>是指向常量的指针，如：<code>const int* p</code> 其中p是一个指针，指向了一个常量，也就是<code>*p</code>不能修改，而p的值可以修改</p>
<p><strong>指针常量</strong>是个常量，如：<code>int *const p</code> p是个指针，p（指针的指向）不能修改，但是<code>*p</code>可以修改</p>
<p><strong>指向常量的指针常量</strong>，如：<code>const int const* p</code> p是个指针常量，而且指向的值也是个常量 <span id="more"></span></p>
<h4 id="应用举例">应用举例</h4>
<p>字符串处理函数的函数的声明。它们的参数一般声明为常量指针。例如，字符串比较函数的声明是这样的： <code>int strcmp(const char *str1, const char *str2);</code> 这样做的目的是，函数的参数声明用了常量指针的形式，保证了在函数内部，那个常量不被更改， 可以接受<strong>非常量</strong>的字符串，这是因为变量可以当作常量，而常量不可以当作变量，比如下面这段代码就是错误的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int a &#x3D; 5;</span><br><span class="line">int* p &#x3D; &amp;a;</span><br></pre></td></tr></table></figure>
<h3 id="引用和常量引用">引用和常量引用</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a &#x3D;10;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;&quot;b:&quot;&lt;&lt;endl;</span><br><span class="line">const int&amp; b &#x3D; a;</span><br><span class="line">cout&lt;&lt;b&lt;&lt;&#39; &#39;;</span><br><span class="line">a &#x3D; 20;</span><br><span class="line">cout&lt;&lt;b&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;&quot;c: &quot;&lt;&lt;endl;</span><br><span class="line">const int&amp; c &#x3D; a*2;</span><br><span class="line">cout&lt;&lt;c&lt;&lt;&#39; &#39;;</span><br><span class="line">a&#x3D;30;</span><br><span class="line">cout&lt;&lt;c&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b:</span><br><span class="line">10 20</span><br><span class="line">c: </span><br><span class="line">40 40</span><br></pre></td></tr></table></figure>
<p>可以看出来，当常量引用的初始值是变量时，可以通过变量修改常量，当初始值是const时是不能修改的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double val &#x3D; 3.14;</span><br><span class="line">const int &amp;r4 &#x3D; val;</span><br><span class="line">std::cout &lt;&lt; &quot;r4 &#x3D; &quot; &lt;&lt; r4 &lt;&lt; std::endl;</span><br><span class="line">val &#x3D; 5.2;</span><br><span class="line">std::cout &lt;&lt; &quot;r4 &#x3D; &quot; &lt;&lt; r4 &lt;&lt; &quot;     val &#x3D; &quot; &lt;&lt; val &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">r4 &#x3D;3</span><br><span class="line">r4 &#x3D; 3       val &#x3D; 5.2</span><br></pre></td></tr></table></figure>
<p>这种情况似乎与r2一样，但是仔细观察就会发现val是<code>double</code>型，而r4是<code>int</code>型， 所以我们可以知道：当常量引用的类型和它的初始值的类型不同时，无法通过变量修改引用值。</p>
<h4 id="使用引用常量传递参数">使用引用常量传递参数</h4>
<p>如果不想让函数修改原来的变量，可以使用传值和传入常量引用的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upper(char* a);</span><br><span class="line">upper(char* const &amp;a);</span><br></pre></td></tr></table></figure>
<p>这两种方法那个更好呢？答案是使用常量引用，因为使用传值会在函数内部创建一个副本，这样会降低效率。</p>
<h3 id="参考资料">参考资料</h3>
<p><a href="https://www.cnblogs.com/FlyGee/p/7424852.html">常量指针与指针常量的区别-flyge</a><br> <a href="https://blog.csdn.net/liupeng1985/article/details/23534485">尽量使用“引用常量”传递函数参数</a><br> <a href="https://www.cnblogs.com/yang666/p/6546966.html">对const的引用(常量引用)</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>指针</tag>
        <tag>引用</tag>
        <tag>常量</tag>
      </tags>
  </entry>
  <entry>
    <title>python数据处理笔记</title>
    <url>/2021/02/03/pydataprocessing/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="pandas">Pandas</h2>
<h3 id="dataframe.locindex-column">dataframe.loc[index, column]</h3>
<p>根据index, column来返回对应数据。index为行，column为列。</p>
<p><a href="https://blog.csdn.net/chenKFKevin/article/details/62049060">ioc使用</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">7</span>, <span class="number">8</span>]], index=[<span class="string">&#x27;cobra&#x27;</span>, <span class="string">&#x27;viper&#x27;</span>, <span class="string">&#x27;sidewinder&#x27;</span>], columns=[<span class="string">&#x27;max_speed&#x27;</span>, <span class="string">&#x27;shield&#x27;</span>])</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">&#x27;-&#x27;</span>*<span class="number">20</span>)</span><br><span class="line">print(df.loc[<span class="string">&#x27;cobra&#x27;</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            max_speed  shield</span><br><span class="line">cobra               1       2</span><br><span class="line">viper               4       5</span><br><span class="line">sidewinder          7       8</span><br><span class="line">--------------------</span><br><span class="line">max_speed    1</span><br><span class="line">shield       2</span><br><span class="line">Name: cobra, dtype: int64</span><br></pre></td></tr></table></figure>
<h3 id="dataframe.drop">dataframe.drop</h3>
<p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.drop.html">官方文档</a></p>
<p>drop会将数据删除一列，并返回一个副本</p>
<h2 id="numpy">Numpy</h2>
<p><a href="https://blog.csdn.net/lxlong89940101/article/details/84314703">reshape(-1, 1)</a></p>
<h3 id="numpy.argmaxa-axisnone-outnone">numpy.argmax(a, axis=None, out=None)</h3>
<p>Parameters: a : <em>array_like</em> 数组 axis : <em>int, 可选</em> 默认情况下，索引的是平铺的数组，否则沿指定的轴。 out : <em>array, 可选</em> 如果提供，结果以合适的形状和类型被插入到此数组中。 Returns: index_array : <em>ndarray of ints</em> 索引数组。它具有与a.shape相同的形状，其中axis被移除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; np.arange(6).reshape(2,3)</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">array([[0, 1, 2],</span><br><span class="line">       [3, 4, 5]])</span><br><span class="line">&gt;&gt;&gt; np.argmax(a)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; np.argmax(a, axis&#x3D;0)#0代表列</span><br><span class="line">array([1, 1, 1])</span><br><span class="line">&gt;&gt;&gt; np.argmax(a, axis&#x3D;1)#1代表行</span><br><span class="line">array([2, 2])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; b &#x3D; np.arange(6)</span><br><span class="line">&gt;&gt;&gt; b[1] &#x3D; 5</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">array([0, 5, 2, 3, 4, 5])</span><br><span class="line">&gt;&gt;&gt; np.argmax(b) # 只返回第一次出现的最大值的索引</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="ndarray-from-ragged-nested-sequences">ndarray from ragged nested sequences)</h3>
<p><a href="https://stackoverflow.com/questions/63097829/debugging-numpy-visibledeprecationwarning-ndarray-from-ragged-nested-sequences">Numpy VisibleDeprecationWarning (ndarray from ragged nested sequences)</a></p>
<h2 id="tensorflow">tensorflow</h2>
<h3 id="pil-image-tensor转换">PIL, Image, Tensor转换</h3>
<p><a href="https://oldpan.me/archives/pytorch-tensor-image-transform">Pytorch中Tensor与各种图像格式的相互转化</a></p>
<h3 id="one-hot编码">one-hot编码</h3>
<p>keras.utils.to_categorical(y, num_classes=None, dtype='float32')</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; labels</span><br><span class="line">array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>])</span><br><span class="line"><span class="comment"># `to_categorical` 将其转换为具有尽可能多表示类别数的列的矩阵。</span></span><br><span class="line"><span class="comment"># 行数保持不变。</span></span><br><span class="line">&gt; to_categorical(labels)</span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]], dtype=float32)</span><br></pre></td></tr></table></figure>
<h3 id="tensorflow多维张量计算">tensorflow多维张量计算</h3>
<p><a href="tensorflow多维张量计算">https://blog.csdn.net/weixin_42445581/article/details/82791811</a></p>
<h3 id="load-model">load model</h3>
<p><a href="https://github.com/tensorflow/tensorflow/issues/43498">当model中有自定义层的时候 load出错</a></p>
<h3 id="section"></h3>
<h2 id="sklearn">Sklearn</h2>
<ul>
<li><a href="https://blog.csdn.net/lanchunhui/article/details/72870358">pandas 下的 one hot encoder 及 pd.get_dummies() 与 sklearn.preprocessing 下的 OneHotEncoder 的区别</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据处理</tag>
        <tag>pandas</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>pyenv使用</title>
    <url>/2021/02/07/pyenv/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://juejin.cn/post/6844903861979709453#heading-9">参考文章</a></p>
<p>以下操作都针对mac</p>
<h2 id="安装pyenv">安装pyenv</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew install pyenv</span><br></pre></td></tr></table></figure>
<h2 id="安装pyenv-virtualenv">安装pyenv-virtualenv</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew install pyenv-virtualenv</span><br></pre></td></tr></table></figure>
<p>在.zshrc或者.bash_profile中写入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pyenv-virtualenv</span></span><br><span class="line"><span class="keyword">if</span> which pyenv-virtualenv-init &gt; /dev/null;</span><br><span class="line">  then <span class="built_in">eval</span> <span class="string">&quot;$(pyenv virtualenv-init -)&quot;</span>;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~&#x2F;.zshrc</span><br><span class="line"># or</span><br><span class="line">source ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure>
<h2 id="安装python">安装python</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv install 3.8.0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在mac big sur 11.2可能出现安装失败的情况</p>
<p><a href="https://dev.to/kojikanao/install-python-3-8-0-via-pyenv-on-bigsur-4oee">[Unable to build Python on macOS Big Sur](https://github.com/pyenv/pyenv/issues/1643)</a></p>
<p>使用如下指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set -ex</span><br><span class="line"></span><br><span class="line">export CFLAGS&#x3D;&quot;-I$(brew --prefix openssl)&#x2F;include -I$(brew --prefix readline)&#x2F;include -I$(xcrun --show-sdk-path)&#x2F;usr&#x2F;include&quot;</span><br><span class="line">export LDFLAGS&#x3D;&quot;-L$(brew --prefix openssl)&#x2F;lib -L$(brew --prefix readline)&#x2F;lib -L$(xcrun --show-sdk-path)&#x2F;usr&#x2F;lib -L&#x2F;usr&#x2F;local&#x2F;opt&#x2F;zlib&#x2F;lib&quot;</span><br><span class="line">export CPPFLAGS&#x3D;&quot;-I&#x2F;usr&#x2F;local&#x2F;opt&#x2F;zlib&#x2F;include&quot;</span><br><span class="line">export PKG_CONFIG_PATH&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;zlib&#x2F;lib&#x2F;pkgconfig&quot;</span><br><span class="line"></span><br><span class="line">pyenv install --patch 3.5.9 &lt; &lt;(curl -sSL https:&#x2F;&#x2F;github.com&#x2F;python&#x2F;cpython&#x2F;commit&#x2F;8ea6353.patch)</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="创建虚拟环境">创建虚拟环境</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv virtualenv 3.8.0 ML</span><br></pre></td></tr></table></figure>
<p>切换到项目文件夹后，输入<code>pyenv local ML</code> ，之后这个目录的python版本就是ML对应的环境。也可以<code>pyenv activate ML</code>暂时激活</p>
<h2 id="解决下载速度慢的问题">解决下载速度慢的问题</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version&#x3D;&quot;3.7.4&quot;; echo $version; wget &quot;https:&#x2F;&#x2F;mirrors.huaweicloud.com&#x2F;python&#x2F;$version&#x2F;Python-$version.tar.xz&quot; -P ~&#x2F;.pyenv&#x2F;cache&#x2F;;pyenv install $version</span><br></pre></td></tr></table></figure>
<h2 id="疑难杂症">疑难杂症</h2>
<p><a href="https://blog.csdn.net/krais_wk/article/details/103741854">ubuntu16.06用pyenv安装python时出现BUILD FAILED</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>env</tag>
      </tags>
  </entry>
  <entry>
    <title>python问题导航</title>
    <url>/2021/02/19/pynotes/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="教程">教程</h2>
<p><a href="http://python.iswbm.com/en/latest/index.html">python中文指南</a></p>
<h2 id="web">WEB</h2>
<p><a href="http://www.pythondoc.com/flask-restful/first.html">使用 Python 和 Flask 设计 RESTful API — Designing a RESTful API with Python and Flask 1.0 documentation</a></p>
<h3 id="python">python</h3>
<ul>
<li><a href="https://www.cnblogs.com/yrxns/p/7727471.html">digest()和hexdigest()区别</a></li>
<li><a href="http://www.cnblogs.com/s502/archive/2013/03/22/2975187.html">原始字符串</a></li>
<li><a href="https://www.cnblogs.com/shaosks/p/5614630.html">python 获取文件大小，创建时间和访问时间</a></li>
<li><a href="https://www.cnblogs.com/dacc123/tag/特征选择/">特征选择 - 标签 - Shendu.CC - 博客园</a></li>
<li><a href="https://www.cnblogs.com/aguncn/p/5912712.html">python列表分组的技巧 - aguncn - 博客园</a></li>
<li><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p02_unpack_elements_from_iterables.html">python cookbook</a></li>
<li>[python <a href="https://blog.csdn.net/u014159143/article/details/80319587">:-1] [::-1]</a></li>
</ul>
<h2 id="环境配置">环境配置</h2>
<p><a href="https://juejin.cn/post/6844903861979709453">Mac 安装和管理多个 Python 版本</a></p>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p>
<p><a href="https://blog.csdn.net/yxys01/article/details/103204531">Python3安装完全攻略 Mac篇</a></p>
<h3 id="pypi镜像设置">pypi镜像设置</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pip -U</span><br><span class="line">pip config set global.index-url https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="运维">运维</h2>
<h2 id="其他">其他</h2>
<p><a href="https://blog.csdn.net/Gpwner/article/details/53140016">Git教程之一个团队如何在github上协作开发 - CSDN博客</a></p>
<p><a href="https://blog.csdn.net/uncledou/article/details/8693499">Linux中enca命令及文件编码问题 - UncleDou的专栏 - CSDN博客</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python 深浅拷贝 值传递 引用传递</title>
    <url>/2021/01/14/python-copy/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="可变对象-不可变对象"><a href="#可变对象-不可变对象" class="headerlink" title="可变对象 不可变对象"></a>可变对象 不可变对象</h2><p>参考内容:</p>
<p> <a href="https://zhuanlan.zhihu.com/p/34395671">python可变对象与不可变对象</a></p>
<p><a href="http://winterttr.me/2015/10/24/python-passing-arguments-as-value-or-reference/">Python的函数参数传递：传值？引用？</a></p>
<p>可变对象：list dict set<br>不可变对象：tuple string int float bool</p>
<p>可变对象修改后地址不会改变，不可变对象修改后地址会改变。因为修改不可变对象时，原来的对象被丢弃，变量指向新的对象。修改可变对象时，比如修改列表中的第一个元素，是有一个新的对象被指定给列表对象的第一个元素，但是列表本身没有变化，只是内容发生了变化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nfoo = <span class="number">1</span></span><br><span class="line">nfoo = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">lstFoo = [<span class="number">1</span>]</span><br><span class="line">lstFoo[<span class="number">0</span>] = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>代码第2行中，内存中原始的1对象因为不能改变，于是被“抛弃”，另nfoo指向一个新的int对象，其值为2</p>
<p>代码第5行中，更改list中第一个元素的值，因为list是可改变的，所以，第一个元素变更为2。其实应该说，lstFoo指向一个<code>包含一个对象的数组</code>。赋值所发生的事情，是有一个新int对象被指定给lstFoo所指向的数组对象的第一个元素，但是对于lstFoo本身来说，所指向的数组对象并没有变化，只是数组对象的内容发生变化了。这个看似void*的变量所指向的对象仍旧是刚刚的那个有一个int对象的list。</p>
<p><img data-src="https://i.loli.net/2021/01/14/RkraAjZYH2gJtKq.jpg" alt=""></p>
<p>所以函数传参的时候不要传可变对象，否则可能会影响传入对象的值。</p>
<p>深浅拷贝的例子都可以在<a href="http://pythontutor.com/">这个网站</a>上可视化编程，非常直观。</p>
<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>赋值是将一个对象的地址赋值给一个变量，让变量指向该地址。<br>修改不可变对象（int, str、tuple）需要开辟新的空间<br>修改可变对象（list等）不需要开辟新的空间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">b = a</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>a和b两个变量指向的内存空间完全相同，此时对a修改会影响b的值。<br><img data-src="https://i.loli.net/2021/01/14/qQBzXxC2iUbEsYo.png" alt=""></p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>浅拷贝是在另一块地址中创建一个新的变量或容器，但是容器内的元素的地址均是源对象的元素的地址的拷贝。也就是说新的容器中指向了旧的元素（ 新瓶装旧酒 ）。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">b = a.copy()</span><br></pre></td></tr></table></figure><br><img data-src="https://i.loli.net/2021/01/14/EqosgdjKfwL6Tva.png" alt=""></p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>深拷贝完全拷贝了一个副本，容器内部元素地址都不一样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">b = copy.deepcopy(a)</span><br></pre></td></tr></table></figure>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/sdcv8K.png" alt=""></p>
<h2 id="python传参"><a href="#python传参" class="headerlink" title="python传参"></a>python传参</h2><p>Python 的函数是怎么传递参数的？ - 1ang的回答 - 知乎 <a href="https://www.zhihu.com/question/20591688/answer/128044544">https://www.zhihu.com/question/20591688/answer/128044544</a></p>
<p>既不是引用也不是值。如果对象是可变的，那么操作是在传入对象上操作的，如果是不可变的，那么相当于这个标识符指向了另一个对象。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>深拷贝</tag>
        <tag>浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>python数组初始化问题</title>
    <url>/2021/06/11/python-list-init/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="引言">引言</h2>
<p>在一个项目中，我想初始化一个mxn的二维数组，于是我使用这段代码初始化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = [[] * <span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<p>但发现arr的值为<code>[[]]</code>，并不是我们期望的<code>[[], [], ..., []]</code>，这是为什么呢？</p>
<p>对照一维数组的初始化方式，于是我换了一种初始化的方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = [[]] * <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>结果为<code>[[], [], [], [], [], [], [], [], [], []]</code>正如我们预料的那样。</p>
<p>于是我们创建一个5x3的列表试试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = [[<span class="number">0</span>] * <span class="number">3</span>] * <span class="number">5</span></span><br><span class="line">arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>修改第一个值后却发现其他值也改变了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; arr</span><br><span class="line">[[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]]</span><br></pre></td></tr></table></figure>
<p>这是为什么呢？</p>
<p>这是因为这样操作的意思实际上是对于<code>[0] * 5</code>的一维列表复制了5次。也就是说，当我更改其中的任意一个的时候，其实是对b列表中的5个子列表全部修改了。</p>
<h2 id="解释">解释</h2>
<p>这涉及到深拷贝和浅拷贝的问题，参看之前的笔记。</p>
<p>在<a href="http://pythontutor.com/live.html#mode=edit">这个网站</a>上可以可视化列表在内存中的储存形式。</p>
<p>我们对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr1 = [<span class="number">0</span>] * <span class="number">5</span></span><br><span class="line">arr2 = [[<span class="number">0</span>]*<span class="number">5</span>]*<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>进行可视化:</p>
<p><img src="https://raw.githubusercontent.com/baichen99/pics/master/img/%E6%88%AA%E5%B1%8F2021-06-11%20%E4%B8%8B%E5%8D%881.41.55.png" /></p>
<p>这样就很清晰了。</p>
<h2 id="参考">参考</h2>
<p><a href="https://blog.csdn.net/weixin_43216017/article/details/89683873">二维列表(list)初始化</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派安装系统</title>
    <url>/2020/11/05/raspberry-os/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="官方系统">官方系统</h2>
<p><a href="https://www.raspberrypi.org/downloads/raspberry-pi-os/">系统镜像下载地址</a></p>
<ol type="1">
<li>插上读卡器</li>
<li>查看存储设备 <code>df -h</code></li>
<li>卸载sd卡: <code>sudo diskutil unmount /Volumes/BOOT</code></li>
<li>烧录系统 <code>sudo dd if=/Users/chenbai/Downloads/2020-08-20-raspios-buster-armhf.img of=/dev/rdisk2 bs=128m</code></li>
<li>根目录创建空ssh文件，以及<code>wpa_supplicant.conf</code>配置文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">country&#x3D;CN</span><br><span class="line">ctrl_interface&#x3D;DIR&#x3D;&#x2F;var&#x2F;run&#x2F;wpa_supplicant GROUP&#x3D;netdev</span><br><span class="line">update_config&#x3D;1</span><br><span class="line">network&#x3D;&#123;</span><br><span class="line">    ssid&#x3D;&quot;624net&quot;</span><br><span class="line">    psk&#x3D;&quot;imsosorry&quot;</span><br><span class="line">    priority&#x3D;1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6" type="1">
<li>sd卡插入树莓派 启动</li>
<li>获取ip 用ssh连接</li>
</ol>
<h2 id="ubuntu-server系统">ubuntu server系统</h2>
<p><a href="%5BRaspberry%20Pi%20安装%20Ubuntu%20Server%2020.04%20LTS%20(无显示器,%20无网线)%20–%20极夜喵%20(h-xie.ren)%5D(https://h-xie.ren/2020/raspberry-pi-安装-ubuntu-server-20-04-lts-无显示器-无网线/)">Raspberry Pi 安装 Ubuntu Server 20.04 LTS (无显示器, 无网线)</a></p>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>烧录</tag>
      </tags>
  </entry>
  <entry>
    <title>数据交换时间</title>
    <url>/2021/08/02/send-delay/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="分组交换">分组交换</h2>
<p>发送时间+传播时间</p>
<p>假设，分组长度为p，中间节点有k个，数据传输速率为b，分组个数为n，分组转发的过程可抽象为：<strong>第一个节点从开始到接收的延时+其他节点从最后一个节点到接收的延时</strong></p>
<p>则发送延时为：<span class="math inline">\(\frac{p}{b}\times(k+1) + (n-1)\times \frac{p}{b}\)</span>​</p>
<blockquote>
<p>k+1是因为发送端也有发送延时</p>
</blockquote>
<p>例题在P9 第4题，P45 第37题</p>
<h2 id="报文交换">报文交换</h2>
<p>不分组，整块直接发送。</p>
<h2 id="电路交换">电路交换</h2>
<p>电路建立时间+传播时间+发送时间</p>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie处理(requests库)</title>
    <url>/2018/06/25/shu-cookies/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>以登录上海大学教务处并获取课程表为例, 分析cookie处理 ### cookie与session session机制采用的是在服务器端保持状态的方案，而cookie机制则是在客户端保持状态的方案，cookie又叫会话跟踪机制。打开一次浏览器到关闭浏览器算是一次会话。说到这里，讲下HTTP协议，前面提到，HTTP协议是一种无状态协议，在数据交换完毕后，服务器端和客户端的链接就会关闭，每次交换数据都需要建立新的链接。此时，服务器无法从链接上跟踪会话。cookie可以跟踪会话，弥补HTTP无状态协议的不足。 <span id="more"></span> ### 具体步骤 1. 首先创建一个session对象<code>s = requests.session()</code> 2. 使用session的get方法, <code>s.get(url, headers)</code>, 获取验证码并保存在本地,此时已经获得cookie, 然后使用post方法提交表单数据 3. 上一步的cookie已经保留, 所以再使用s的get方法, 请求课程表的url地址 url是'http://cj.shu.edu.cn/StudentPortal/CtrlStudentSchedule'</p>
<h3 id="全部代码">全部代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">s = requests.session()</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.168 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r = s.get(<span class="string">&#x27;http://cj.shu.edu.cn/User/GetValidateCode?+%20GetTimestamp()&#x27;</span>, headers=headers)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;verify.png&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(r.content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">form_data = &#123;</span><br><span class="line">    <span class="string">&#x27;url&#x27;</span>:<span class="string">&#x27;&#x27;</span> ,</span><br><span class="line">    <span class="string">&#x27;txtUserNo&#x27;</span>: <span class="string">&#x27;17121122&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;txtPassword&#x27;</span>: <span class="string">&#x27;xxxxxx&#x27;</span>, <span class="comment"># 这里填密码</span></span><br><span class="line">    <span class="string">&#x27;txtValidateCode&#x27;</span>: <span class="built_in">input</span>(<span class="string">&#x27;verify: &#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://cj.shu.edu.cn/&#x27;</span></span><br><span class="line">result = s.post(url, headers=headers, data=form_data)</span><br><span class="line"></span><br><span class="line">sche = s.post(<span class="string">&#x27;http://cj.shu.edu.cn/StudentPortal/CtrlStudentSchedule&#x27;</span>, headers=headers, data=&#123;<span class="string">&#x27;academicTermID&#x27;</span> : <span class="string">&#x27;20173&#x27;</span>&#125;)</span><br><span class="line">print(sche.text)</span><br></pre></td></tr></table></figure>
<h3 id="注意事项">注意事项</h3>
<p>1- 验证码图片和课程表地址是通过chrome浏览器的Network获得的 2- <code>academicTermID' : '20173'</code> 中的20173是学期的代码</p>
]]></content>
      <categories>
        <category>spider</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>spider</tag>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>go 排序算法</title>
    <url>/2020/08/17/sort-go/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="冒泡">冒泡</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稳定</span></span><br><span class="line"><span class="comment">// 时间复杂度 O(n^2)</span></span><br><span class="line"><span class="comment">// 空间复杂度 O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BubbleSort</span><span class="params">(arr []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// n个元素只要走n-1趟</span></span><br><span class="line">	n := <span class="built_in">len</span>(arr)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;n-i<span class="number">-1</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>] &#123;</span><br><span class="line">				arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> arr = []<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>&#125;</span><br><span class="line">	BubbleSort(arr)</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="插入">插入</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本思想 不断地将尚未排好序的数插入到已经排好序的部分</span></span><br><span class="line"><span class="comment">// 稳定</span></span><br><span class="line"><span class="comment">// 时间复杂度 O(n^2)</span></span><br><span class="line"><span class="comment">// 空间复杂度 O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Insertionsort</span><span class="params">(arr []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(arr)</span><br><span class="line">	<span class="comment">// 第一个认为是有序的，从第二个元素开始，一共n-1次插入</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j:=i+<span class="number">1</span>; j&gt;<span class="number">0</span>; j-- &#123;</span><br><span class="line">			<span class="keyword">if</span> arr[j] &lt; arr[j<span class="number">-1</span>] &#123;</span><br><span class="line">				arr[j], arr[j<span class="number">-1</span>] = arr[j<span class="number">-1</span>], arr[j]</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> arr = []<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>&#125;</span><br><span class="line">	Insertionsort(arr)</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="选择">选择</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本思想 在每次遍历后，把未排序的最小的元素放到前面</span></span><br><span class="line"><span class="comment">// 不稳定  eg  3 2 3 1 第一个3和1交换  破坏了稳定性</span></span><br><span class="line"><span class="comment">// 时间复杂度O(n^2)</span></span><br><span class="line"><span class="comment">// 空间复杂度 O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SelectionSort</span><span class="params">(arr []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(arr)</span><br><span class="line">	<span class="keyword">var</span> minIndex <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j:=i+<span class="number">1</span>; j&lt;n; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> arr[j] &lt; arr[minIndex] &#123;</span><br><span class="line">				minIndex = j</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> minIndex != i &#123;</span><br><span class="line">			arr[i], arr[minIndex] = arr[minIndex], arr[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> arr = []<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>&#125;</span><br><span class="line">	SelectionSort(arr)</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="希尔">希尔</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本思想 希尔排序是按照不同步长对元素进行插入排序</span></span><br><span class="line"><span class="comment">// 不稳定  eg  5 2 2 步长为2时，5和第二个2交换，破坏稳定性</span></span><br><span class="line"><span class="comment">// 时间复杂度O(n^2)</span></span><br><span class="line"><span class="comment">// 空间复杂度 O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShellSort</span><span class="params">(arr []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(arr)</span><br><span class="line">	<span class="comment">// 遍历间隔</span></span><br><span class="line">	<span class="keyword">for</span> gap:=n/<span class="number">2</span>; gap&gt;<span class="number">0</span>; gap/=<span class="number">2</span> &#123;</span><br><span class="line">		<span class="comment">// 从第gap个开始</span></span><br><span class="line">		<span class="keyword">for</span> i:=gap; i&lt;n; i++ &#123;</span><br><span class="line">			<span class="comment">// 之前的分组都要过一遍，比如gap=2时，42比较，21比较</span></span><br><span class="line">			<span class="keyword">for</span> j:=i; j-gap&gt;=<span class="number">0</span> &amp;&amp; arr[j-gap] &gt; arr[j]; j -= gap&#123;</span><br><span class="line">				arr[j-gap], arr[j] = arr[j], arr[j-gap]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> arr = []<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;</span><br><span class="line">	ShellSort(arr)</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="归并">归并</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本思想 一开始先把数组从中间划分成两个子数组，一直递归地把子数组划分成更小的子数组，直到子数组里面只有一个元素，这个时候才开始排序，排序的方法就是按照大小顺序合并两个元素，接着依次按照递归的返回顺序，不断地合并排好序的子数组，直到最后把整个数组的顺序排好。</span></span><br><span class="line"><span class="comment">// 稳定</span></span><br><span class="line"><span class="comment">// 时间复杂度 O(nlogn)  进行logn层切分, 每层合并复杂度都是O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度 O(n)	结果需要用一个O(n)的数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Merge</span><span class="params">(left []<span class="keyword">int</span>, right []<span class="keyword">int</span>)</span> <span class="params">(res []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">	res = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	m, n := <span class="built_in">len</span>(left), <span class="built_in">len</span>(right)</span><br><span class="line">	i, j:=<span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> ; i&lt;m &amp;&amp; j&lt;n;  &#123;</span><br><span class="line">		<span class="keyword">if</span> left[i] &lt; right[j] &#123;</span><br><span class="line">			res = <span class="built_in">append</span>(res, left[i])</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			res = <span class="built_in">append</span>(res, right[j])</span><br><span class="line">			j += <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> i == m &#123;</span><br><span class="line">		res = <span class="built_in">append</span>(res, right[j:]...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> j == n &#123;</span><br><span class="line">		res = <span class="built_in">append</span>(res, left[i:]...)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MergeSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> <span class="params">(res []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> arr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	i := <span class="built_in">len</span>(arr) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">	left := MergeSort(arr[<span class="number">0</span>:i])</span><br><span class="line">	right := MergeSort(arr[i:])</span><br><span class="line"></span><br><span class="line">	result := Merge(left, right)</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> arr = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>&#125;</span><br><span class="line">	res := MergeSort(arr)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="快速排序">快速排序</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本思想 一开始先把数组从中间划分成两个子数组，一直递归地把子数组划分成更小的子数组，直到子数组里面只有一个元素，这个时候才开始排序，排序的方法就是按照大小顺序合并两个元素，接着依次按照递归的返回顺序，不断地合并排好序的子数组，直到最后把整个数组的顺序排好。</span></span><br><span class="line"><span class="comment">// 不稳定  eg 1 2 2* 3 把2*作为key 那么2将会放在2*后</span></span><br><span class="line"><span class="comment">// 时间复杂度O(nlogn) logn次分解，每次都要进行n次比较  最佳情况：每次选出来的数都是中间值  最坏：数组为逆序</span></span><br><span class="line"><span class="comment">// 空间复杂度 O(logn)	递归次数为logn, 每次都需要额外的O(1)空间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(arr []<span class="keyword">int</span>, start <span class="keyword">int</span>, end <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> start &gt;= end &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	i, j := start, end</span><br><span class="line">	key := arr[(start+end)/<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i &lt;= j &#123;</span><br><span class="line">		<span class="keyword">for</span> arr[i] &lt; key  &#123;</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> arr[j] &gt; key &#123;</span><br><span class="line">			j--</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> i &lt;= j &#123;</span><br><span class="line">			arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">			i++</span><br><span class="line">			j--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> start &lt; j &#123;</span><br><span class="line">		QuickSort(arr, start, j)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> i &lt; end &#123;</span><br><span class="line">		QuickSort(arr, i, end)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> arr = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>&#125;</span><br><span class="line">	QuickSort(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span>)</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="堆排序">堆排序</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapAdjust</span><span class="params">(arr []<span class="keyword">int</span>, k, length <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// k为父节点，i为左子节点</span></span><br><span class="line">		i := <span class="number">2</span>*k+<span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> i &gt;= length &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 选择左右节点中最大的, 如果没有有右节点就是左节点最大</span></span><br><span class="line">		<span class="keyword">if</span> i+<span class="number">1</span> &lt; length &amp;&amp; arr[i] &lt; arr[i+<span class="number">1</span>] &#123;</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 父节点和最大的子节点交换</span></span><br><span class="line">		<span class="keyword">if</span> arr[k] &lt; arr[i] &#123;</span><br><span class="line">			arr[k], arr[i] = arr[i], arr[k]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 继续调整子节点</span></span><br><span class="line">		k = i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapSort</span><span class="params">(arr []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(arr)</span><br><span class="line">	<span class="comment">// 自底向上调整</span></span><br><span class="line">	<span class="keyword">for</span> i:=n/<span class="number">2</span>; i&gt;=<span class="number">0</span>; i-- &#123;</span><br><span class="line">		HeapAdjust(arr, i, n)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">		arr[n<span class="number">-1</span>], arr[<span class="number">0</span>] = arr[<span class="number">0</span>], arr[n<span class="number">-1</span>]</span><br><span class="line">		n--</span><br><span class="line">		HeapAdjust(arr, <span class="number">0</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> arr = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">24</span>, <span class="number">14</span>, <span class="number">124</span>&#125;</span><br><span class="line">	HeapSort(arr)</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>sort</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序效率</title>
    <url>/2021/08/23/sort-notes/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>稳定的算法：插、归、基、冒泡  <a href="https://www.bilibili.com/read/cv12699857?from=articleDetail&amp;spm_id_from=333.976.b_726561645265636f6d6d656e64496e666f.4">巧记稳定的排序</a></p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>选泡插：$O(n^2)$</p>
<p>快归堆：$O(nlog_2{n})$</p>
<p>基：$O(d(n+r))$</p>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>快排：$O(log2_n)$</p>
<p>2归：$O(n)$</p>
<p>基数：$O(r)$</p>
<h3 id="每趟确定一个元素位置"><a href="#每趟确定一个元素位置" class="headerlink" title="每趟确定一个元素位置"></a>每趟确定一个元素位置</h3><p>插入排序不能，因为每次讲一个元素插入已经有序的列表，之后的元素还可能影响有序表元素的位置。</p>
<p>希尔排序不能，每次只能保证一个组内相对有序</p>
<p>归并排序不能，每次只能保证组内有序</p>
<p>基数排序：不能</p>
<p>下面是能确定的：（选堆快泡）</p>
<ul>
<li>冒泡</li>
<li>选择排序（选择最小的放在前面）</li>
<li>堆排序</li>
<li><strong>快排比较特殊！</strong> 如果选择枢轴在边界，第二趟确定2个元素位置，如果在中间，第二趟确定3个</li>
</ul>
<p>​    <img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/Screen%20Shot%202021-11-15%20at%2015.37.39.png" alt=""></p>
<h3 id="排序效率与初始状态关系"><a href="#排序效率与初始状态关系" class="headerlink" title="排序效率与初始状态关系"></a>排序效率与初始状态关系</h3><p>选择排序、堆排序、归并排序与原状态无关</p>
<ul>
<li>冒泡，若顺序，一趟过后flag==True，退出循环</li>
<li>快排，每次平均划分效率最高，如果有序或逆序，时间复杂度为$O(n^2)$，空间复杂度为$O(n)$</li>
<li>插入排序，有序最好，逆序最坏</li>
</ul>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入"><a href="#直接插入" class="headerlink" title="直接插入"></a>直接插入</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(A[i] &lt; A[i<span class="number">-1</span>]) &#123;   <span class="comment">// 后面&gt;=前面时，不用继续比较</span></span><br><span class="line">      temp = A[i];</span><br><span class="line">      <span class="comment">// 在有序列表中从后往前比</span></span><br><span class="line">      <span class="comment">// 因为i-1处无序了，所以将这个数插入到前面比他小的后面</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>; j&gt;=<span class="number">0</span> &amp;&amp; temp &lt; A[j]; j--)  <span class="comment">// 要找到比temp小的 或 相等的</span></span><br><span class="line">        A[j+<span class="number">1</span>] = A[j]</span><br><span class="line">      A[j+<span class="number">1</span>] = temp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>思想：</strong>每次将一个记录插入有序序列中</p>
<p><strong>空间复杂度</strong>：因为只用到了temp额外变量，所以空间复杂度为<strong>O(1)</strong></p>
<p><strong>时间复杂度：</strong> 比较次数*移动次数</p>
<ul>
<li>最坏：逆序，比较总次数为$1+2+…+n-1 = \frac{n(n-1)}{2}$，移动总次数为$2+3+…+n = \frac{(n-1)(n+2)}{2}$，时间复杂度为$O(n^2)$</li>
<li>最好：顺序，比较总次数为$1+1+…+1=n-1$，不需要移动，所以时间复杂度为$O(n)$</li>
<li>平均：$O(n^2)$</li>
</ul>
<blockquote>
<p>适用于<strong>链式存储</strong>(注意)、顺序存储</p>
</blockquote>
<h3 id="折半插入"><a href="#折半插入" class="headerlink" title="折半插入"></a>折半插入</h3><p><strong>思想：</strong>直接插入排序是顺序找到有序表的插入位置，折半插入则是用折半查找</p>
<p><strong>空间复杂度：</strong>O(1)</p>
<p><strong>时间复杂度：</strong> 和直接插入的<strong>唯一区别在于</strong>减少了比较次数，移动次数未改变，因为折半查找的复杂度为$O(log_{2}n)$，所以折半插入的时间复杂度为$O(nlog_{2}n)$</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p><strong>思想：</strong>选定步长d，对每个子序列$[i, i+d, …, i+kd]$进行<strong>直接插入排序</strong>，不断缩小d直到为1，即可完成排序。</p>
<p><strong>空间复杂度：</strong>本质上是多次直接插入排序，所以为$O(1)$</p>
<p><strong>时间复杂度：</strong>很难计算，最坏情况为d=1，即直接插入排序，$O(n^2)$</p>
<p><strong>不稳定！！！</strong></p>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><strong>思想：</strong>两个两个比较，每趟确定一个最小/大值</p>
<p><strong>空间复杂度：</strong>O(1)</p>
<p><strong>时间复杂度:</strong> </p>
<ul>
<li><strong>最好：</strong>本身有序，需要比较n-1次，移动0次，所以O(n)</li>
<li><strong>最坏:</strong> 逆序，需要进行n-1躺排序，每趟比较次数为$n-1, n-2, …, 1$，且每次比较移动次数为3（temp=a, a=b, b=temp），比较次数为$1+2+…+n-1 = \frac{n(n-1)}{2}$，移动次数为$\frac{3n(n-1)}{2}$</li>
</ul>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pivot = A[low];  <span class="comment">// 第一个为枢轴</span></span><br><span class="line">  <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; A[high] &gt;= pivot) high--;</span><br><span class="line">    A[low] = A[hight];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; A[low] &lt;= pivot) low--;</span><br><span class="line">    A[high] = A[low];</span><br><span class="line">  &#125;</span><br><span class="line">  A[low] = pivot;</span><br><span class="line">  <span class="keyword">return</span> low;   <span class="comment">// 返回枢轴的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuikSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pivot_pos = Partition(A, low, high);</span><br><span class="line">  QuickSort(A, low, pivot_pos<span class="number">-1</span>);</span><br><span class="line">  QuickSort(A, pivot_pos+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>思想：</strong>分治，是<strong>内部排序</strong>算法中<strong>平均性能</strong>最好的</p>
<p><strong>空间复杂度：</strong>快排是递归的，因此需要借助栈，栈的深度与调用深度一致</p>
<ul>
<li><strong>最好：</strong>每次都分一半，即$2^h &gt;= n, h=log_2n$，因此$O(log_2n)$</li>
<li><strong>最坏：</strong>每次都取到最大值，要调用n-1次，$O(n)$</li>
</ul>
<p><strong>时间复杂度：</strong><a href="https://blog.csdn.net/weshjiness/article/details/8660583">快速排序最好，最坏，平均复杂度分析</a></p>
<ul>
<li><strong>最好：</strong> $O(nlog_2n)$</li>
<li><strong>最坏：</strong>$O(n)$</li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> min=i;  <span class="comment">// min指向最小元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">      <span class="keyword">if</span>(A[j] &lt; A[min])</span><br><span class="line">        min=j;</span><br><span class="line">   	<span class="keyword">if</span>(min!=i)</span><br><span class="line">      swap(A[i], A[min])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>思想：</strong>每次找到关键字最小的放在有序子序列</p>
<p><strong>空间复杂度：</strong>O(1)</p>
<p><strong>时间复杂度：</strong></p>
<p>一共进行n-1趟比较， <strong>比较次数与初始状态无关</strong>为$n-1+n-2+…+1 = \frac{n(n-1)}{2}$，在有序情况下交换次数为0，最坏为$3(n-1)$，因此时间复杂度为$O(n^2)$</p>
<p>因为比较过程中进行了交换，<strong>不稳定</strong></p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><strong>空间复杂度：</strong>O(1)</p>
<p><strong>时间复杂度：</strong>：<code>buildHeap</code>复杂度为O(n)，每次<code>heapify</code>需要调整$O(h)=O(log_2{n})$次，所以时间复杂度为$O(nlog_2{n})$</p>
<p>顺序存储的二叉树，若从0开始编号，对于节点i有以下性质：</p>
<ul>
<li><p>双亲节点编号为 (i-1)/2</p>
</li>
<li><p>左孩子编号为2i+1</p>
</li>
<li>右孩子编号为2i+2</li>
</ul>
<h4 id="建立最大堆"><a href="#建立最大堆" class="headerlink" title="建立最大堆"></a>建立最大堆</h4><p>假设数组长度为n</p>
<p><strong>调整条件</strong>：</p>
<ul>
<li>当前节点大于两个孩子时，不调整</li>
<li>当前节点小于孩子时，将其与更大的孩子交换</li>
</ul>
<p>我们可以写一个<code>heapify</code>函数，来对<strong>一个</strong>节点进行调整，<strong>要递归向下调整</strong>，调整<strong>较大</strong>的那个分支</p>
<blockquote>
<p>若是最小堆，调整较小的那个分支</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// O(log2n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 对第i个节点调整</span></span><br><span class="line">  <span class="keyword">if</span>(i &gt;= n)   <span class="comment">// 越界</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> c1 = <span class="number">2</span>*i + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> c2 = <span class="number">2</span>*i + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> max = i;    <span class="comment">// 记录最大的索引</span></span><br><span class="line">  <span class="comment">// 左孩子比父节点大</span></span><br><span class="line">  <span class="keyword">if</span>(c1 &lt; n &amp;&amp; arr[c1] &gt; arr[max]) &#123;  <span class="comment">// c1 &lt; n 防止越界，也就是没有左孩子的情况</span></span><br><span class="line">    max = c1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 右孩子比父节点和左节点大</span></span><br><span class="line">  <span class="keyword">if</span>(c2 &lt; n &amp;&amp; arr[c2] &gt; arr[max]) &#123;</span><br><span class="line">    max = c2;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(max != i) &#123;</span><br><span class="line">    swap(arr[i], arr[max]);</span><br><span class="line">    heapify(arr, n, max)   <span class="comment">// 递归向下调整，调整较大的那个分支</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了调整一个节点的函数，我们可以遍历调用，则可完成对所有节点调整</p>
<p>因为<strong>叶子节点不需要调整</strong>，我们只需要从<strong>最后一个分支节点</strong>开始调整，也就是<strong>最后一个节点的父节点</strong>，其坐标为(n-1-1)/2</p>
<p>从后往前依次进行调整：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// O(n) * O(log2n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span> arr[], n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> last = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> last_parent = (last<span class="number">-1</span>)/<span class="number">2</span>;   <span class="comment">// 第一个分支节点</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=last_parent; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    heapify(arr, n, i);    <span class="comment">// 对每个分支进行调整</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h4><p>建立了堆就可以<strong>堆排序</strong>了，步骤为：</p>
<ol>
<li><p>将根节点与最后一个节点交换，拿出最后一个节点（最大值）</p>
</li>
<li><p>对根节点进行调整</p>
</li>
</ol>
<p>代码为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  buildHeap(arr, n);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">    swap(arr[<span class="number">0</span>], arr[i]);  <span class="comment">// 跟节点和最后一个节点交换 然后取出删除最后一个</span></span><br><span class="line">    heapify(arr, i, <span class="number">0</span>);  <span class="comment">// 因为堆大小在减少，i为剩余堆大小</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入、删除的调整（比较过程）"><a href="#插入、删除的调整（比较过程）" class="headerlink" title="插入、删除的调整（比较过程）"></a>插入、删除的调整（比较过程）</h4><p><strong>插入</strong></p>
<p>插入元素，即把元素放在最后，然后从第一个分支节点开始调整，接下来递归调整其父节点。调整次数就是层数-1，时间复杂度为$O(log_{2}n)$</p>
<p>可以看作是<strong>结点上浮</strong>的过程。</p>
<p><strong>删除</strong></p>
<p>删除根元素，即把根元素与最后一个元素交换，然后移除最后一个元素。接下来对根节点调用<code>heapify(arr, n-1, 0)</code>。（整个过程就是堆排序的过程）。时间复杂度为$O(log_{2}n)$</p>
<p>可以看作是<strong><em>堆的最后一个结点的下沉</em></strong></p>
<p>若小根堆，节点i与两个孩子<strong>都比较</strong>，选择更小的交换</p>
<p>eg：8，15，10，21，34，16，12。删除8之后重建堆</p>
<ol>
<li>12， 15， 10， 21， 34， 16</li>
<li>调整根节点：15与10比较，10更小，10与12比较，10更小，所以10和12交换：10，15，12，21，34，16</li>
<li>调整12节点：只有一个孩子，所以12与16比较，12更小，所以不动</li>
</ol>
<p>例题：</p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/%E6%88%AA%E5%B1%8F2021-10-06%20%E4%B8%8B%E5%8D%884.03.30.png" alt=""></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>合并有序列表。二路排序是递归合并2个有序数组。</p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/截屏2021-09-04 上午11.06.31.png" alt=""></p>
<p>上面是一个4层的二叉树，从下往上为1，2，3，4层</p>
<p>可以将归并排序过程看作倒置的二叉树：</p>
<ul>
<li>将其看作高度为h的树，第h层最多$2^{h-1}$个节点，所以$n  \le 2^{h-1}$，$h -1 = \lceil log_2n \rceil$</li>
<li>高度为h，需要$h -1 = \lceil log_2n \rceil$趟排序</li>
<li>每趟对两个<strong>有序</strong>列表排序，每比较一次，就可以得出一个元素位置，所以<strong>每趟最多比较n-1次，O(n)</strong>，n为全部元素个数</li>
<li><p>趟数$O(log_2{n})$  每趟$O(n)$  时间复杂度$O(nlog_2{n})$  空间复杂度$O(n)$</p>
</li>
<li><p><strong>稳定</strong></p>
</li>
</ul>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p><strong>不是基于比较的算法</strong></p>
<p>多关键字排序，比如数字123，<strong>先对个位排序，再对十位排序，再对百位排序</strong></p>
<ul>
<li>用到了队列进行分配和收集，如果基数为r，那么就有r个队列，比如数字0-9，基数为10，10个队列</li>
<li>如果有d个关键字位，就需要d躺排序</li>
<li>时间复杂度：O(d(n+r))    收集为O(r)，分配为O(n)   与初始状态无关</li>
<li>空间复杂度：r个队列，O(r)</li>
</ul>
<h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><p>采用归并排序</p>
<ul>
<li><p>初始归并段r</p>
</li>
<li><p>归并路数k</p>
</li>
<li><p>趟数S</p>
</li>
</ul>
<p>趟数：$S = log_k{r}$</p>
<p>读写磁盘次数=(磁盘块数+趟数*磁盘块数)x2</p>
<blockquote>
<p>生成初始归并段需要磁盘块数的读和写，每趟都要堆所有磁盘块进行读和写</p>
</blockquote>
<p>内部归并，k个元素中选择最小的需要比较(k-1)次</p>
<p>每趟归并n个元素，比较次数为$(n-1)(k-1)$</p>
<p>S趟归并需要比较$S(n-1)(k-1)$次</p>
<p><strong>败者树</strong>：k个元素中选择最小的只需要比较$\lceil log_2k \rceil$次</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>排序</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫-数据存储(二)</title>
    <url>/2018/06/07/spider-csv/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><strong>csv 逗号分隔值, 有时也称为字符分隔值, 因为分隔字符可以不是逗号</strong> <strong>文件以 纯文本 形式存储表格数据(数字和文本), 纯文本不含必须像二进制数字那样被解读的数据</strong> <span id="more"></span> # csv文件实例 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ID,UserName,PassWord</span><br><span class="line">1,bc,123</span><br><span class="line"> 2,dis,456</span><br><span class="line">3,ad,789</span><br></pre></td></tr></table></figure> # 储存为csv文件的实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import csv</span><br><span class="line">headers &#x3D; [&quot;ID&quot;,&quot;UserName&quot;,&quot;PassWord&quot;]</span><br><span class="line">rows &#x3D; [</span><br><span class="line">    (&quot;1&quot;,&quot;bc&quot;,&quot;123&quot;),</span><br><span class="line">    (&quot;2&quot;,&quot;dis&quot;,&quot;456&quot;),</span><br><span class="line">    (&quot;3&quot;,&quot;ad&quot;,&quot;789&quot;)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">with open(&#39;csv_test.csv&#39;, &#39;w&#39;, newline&#x3D;&#39;&#39;) as f:  # 如果没有newline参数会有空行出现  参考资料 https:&#x2F;&#x2F;blog.csdn.net&#x2F;chuan_yu_chuan&#x2F;article&#x2F;details&#x2F;53671587</span><br><span class="line">    f_csv &#x3D; csv.writer(f)  # 构造一个csv.writer类的实例</span><br><span class="line">    f_csv.writerow(headers)</span><br><span class="line">    f_csv.writerows(rows)</span><br></pre></td></tr></table></figure>
<p># rows列表中的数据元组也可以是字典 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rows &#x3D; [</span><br><span class="line">    (&#123;&quot;ID&quot;:&quot;1&quot;, &quot;UserName&quot;:&quot;bc&quot;, &quot;PassWord&quot;:&quot;123&quot;&#125;),</span><br><span class="line">    (&#123;&quot;ID&quot;:&quot;2&quot;, &quot;UserName&quot;:&quot;dis&quot;, &quot;PassWord&quot;:&quot;456&quot;&#125;),</span><br><span class="line">    (&#123;&quot;ID&quot;:&quot;3&quot;, &quot;UserName&quot;:&quot;ad&quot;, &quot;PassWord&quot;:&quot;789&quot;&#125;)</span><br><span class="line">]</span><br><span class="line">with open(&#39;csv_dict.csv&#39;, &#39;w&#39;) as f:</span><br><span class="line">    f_csv &#x3D; csv.DictWriter(f, headers)</span><br><span class="line">    f_csv.writeheader()</span><br><span class="line">    f_csv.writerows(rows)</span><br></pre></td></tr></table></figure> # 读取csv文件需要创建reader对象 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">with open(&#39;csv_test.csv&#39;) as f:</span><br><span class="line">    f_csv &#x3D; csv.reader(f)</span><br><span class="line">    headers &#x3D; next(f_csv)</span><br><span class="line">    print(headers)</span><br><span class="line">    for row in f_csv:</span><br><span class="line">        print(row)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>spider</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>spider</tag>
        <tag>csv</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫-数据存储(一)</title>
    <url>/2018/06/06/spider-json/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><em>JSON的格式是 <code>键:值</code> 类似于python中的字典</em> <em>JSON数组: JSON数组在方括号中书写,可包含多个对象 如<code>[&#123;'name':'blackstone', 'age', 21&#125;,&#123;'name':'marry', 'age', 19&#125;]</code></em> <span id="more"></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.168 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">&#x27;http://www.seputu.com/&#x27;</span></span><br><span class="line">r = requests.get(url, headers)</span><br><span class="line">soup = BeautifulSoup(r.text, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">content = []</span><br><span class="line"><span class="keyword">for</span> mulu <span class="keyword">in</span> soup.find_all(class_=<span class="string">&#x27;mulu&#x27;</span>):</span><br><span class="line">    h2 = mulu.find(<span class="string">&#x27;h2&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> h2 != <span class="literal">None</span>:</span><br><span class="line">        h2_title = h2.string  <span class="comment"># find返回的是tag类型  有.string方法</span></span><br><span class="line">        <span class="built_in">list</span> = []</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> mulu.find(class_=<span class="string">&#x27;box&#x27;</span>).find_all(<span class="string">&#x27;a&#x27;</span>): <span class="comment"># find方法返回匹配的第一个tag   find_all方法返回匹配的tag的列表</span></span><br><span class="line">            href = a.get(<span class="string">&#x27;href&#x27;</span>)   <span class="comment"># tag.get(&#x27;attr&#x27;)</span></span><br><span class="line">            box_title = a.get(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line">            <span class="built_in">list</span>.append(&#123;<span class="string">&#x27;href&#x27;</span>:href, <span class="string">&#x27;box_title&#x27;</span>:box_title&#125;)</span><br><span class="line">        content.append(&#123;<span class="string">&#x27;title&#x27;</span>:h2_title, <span class="string">&#x27;content&#x27;</span>:<span class="built_in">list</span>&#125;)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;T1.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="comment"># dump的作用: 1.将Python对象转换成JSON对象,2.将JSON对象通过fp文件流写入文件</span></span><br><span class="line">    json.dump(content, fp=fp, indent=<span class="number">4</span>)  <span class="comment"># indent是缩进   设置缩进为几个空格</span></span><br></pre></td></tr></table></figure>
<h2 id="需要注意的地方">需要注意的地方</h2>
<h3 id="dumps与dump">dumps与dump</h3>
<p><strong>dumps是生成了一个字符串, 并没有写入文件<br />
dump把python对象转换成JSON对象, 并且写入文件</strong> ### 解码 <code>json.load(json_str)</code>或者<code>json.loads(str)</code></p>
<h2 id="总结">总结</h2>
<p>dumps和loads方法都在内存中转换，dump和load的方法会多一个步骤，dump是把序列化后的字符串写到一个文件中load是从一个文件中读取文件</p>
]]></content>
      <categories>
        <category>spider</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>spider</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>线程</title>
    <url>/2018/06/17/threads/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Python标准库提供了两个模块: thread 和 threading, thread是低级模块, threading是对其的封装, 绝大多数情况下我们只需要使用threading <span id="more"></span> ## 使用threading创建多线程 有两种方法</p>
<p>第一种方法是:把一个函数传入并创建Thread实例,然后调用start方法开始执行</p>
<p>第二种方法是:从threading.Thread<strong>继承</strong>并创建线程类, 然后<strong>重写</strong>__init__方法和run方法</p>
<p>方法一演示如下 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_run</span>(<span class="params">urls</span>):</span></span><br><span class="line">    print(<span class="string">&quot;Current process %s is running&quot;</span> % threading.current_thread().name)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        print(<span class="string">&quot;%s ------&gt; %s&quot;</span> % (threading.current_thread().name, url))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">&quot;%s ended&quot;</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;%s is running...&quot;</span> % threading.current_thread().name)</span><br><span class="line">t1 = threading.Thread(target=thread_run, name=<span class="string">&quot;thread1&quot;</span>, args=([<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>],))</span><br><span class="line">t2 = threading.Thread(target=thread_run, name=<span class="string">&quot;thread2&quot;</span>, args=([<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>],))</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;%s ended&quot;</span> % threading.current_thread().name)</span><br></pre></td></tr></table></figure> 运行结果 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MainThread is running...</span><br><span class="line">Current process thread1 is running</span><br><span class="line">thread1 ------&gt; 1</span><br><span class="line">Current process thread2 is running</span><br><span class="line">thread2 ------&gt; 5</span><br><span class="line">thread1 ------&gt; 2</span><br><span class="line">thread2 ------&gt; 6</span><br><span class="line">thread1 ------&gt; 3</span><br><span class="line">thread2 ------&gt; 7</span><br><span class="line">thread2 ------&gt; 8</span><br><span class="line">thread1 ------&gt; 4</span><br><span class="line">thread1 ended</span><br><span class="line">thread2 ended</span><br><span class="line">MainThread ended</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure> 方法二 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random, threading, time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, urls</span>):</span></span><br><span class="line">        threading.Thread.__init__(self, name=name)</span><br><span class="line">        self.urls = urls</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Current %s is running...&quot;</span> % threading.current_thread().name)</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> self.urls:</span><br><span class="line">            print(<span class="string">&quot;%s ---&gt;&gt;&gt; %s&quot;</span> % (threading.current_thread().name, url))</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">&quot;%s ended&quot;</span> % threading.current_thread().name)</span><br><span class="line">print(<span class="string">&quot;%s is running&quot;</span> % threading.current_thread().name)</span><br><span class="line">t1 = MyThread(name=<span class="string">&quot;Thread1&quot;</span>, urls=[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>])</span><br><span class="line">t2 = MyThread(name=<span class="string">&quot;Thread2&quot;</span>, urls=[<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>])</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line">print(<span class="string">&quot;%s ended&quot;</span> % threading.current_thread().name)</span><br></pre></td></tr></table></figure> 运行结果如下 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MainThread is running</span><br><span class="line">Current Thread1 is running...</span><br><span class="line">Thread1 ---&gt;&gt;&gt; 1</span><br><span class="line">Current Thread2 is running...</span><br><span class="line">Thread2 ---&gt;&gt;&gt; 4</span><br><span class="line">Thread2 ---&gt;&gt;&gt; 5</span><br><span class="line">Thread1 ---&gt;&gt;&gt; 2</span><br><span class="line">Thread2 ---&gt;&gt;&gt; 6</span><br><span class="line">Thread1 ---&gt;&gt;&gt; 3</span><br><span class="line">Thread2 ended</span><br><span class="line">Thread1 ended</span><br><span class="line">MainThread ended</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure> ## 线程同步 多个线程对某个数据进行修改可能会出现错误, 使用Thread对象的Lock和RLock方法可以实现简单的线程同步,这两个对象都有acquire方法和release方法, 对于哪些每次只允许一个线程操作的数据, 可以将其操作放到acquire和release之间 对于<strong>Lock对象</strong>如果一个线程进行两次aquire,由于没有release第二次的aquire将会挂起,造成死锁 <strong>RLock</strong>对象允许一个线程多次对其进行acquire操作 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RLock使多个线程不能同时更改变量</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">mylock = threading.RLock()</span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        初始化</span></span><br><span class="line"><span class="string">        :param name: 线程名称</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        threading.Thread.__init__(self, name=name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">global</span> num</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            mylock.acquire()</span><br><span class="line">            print(<span class="string">&quot;%s locked, Number: %d&quot;</span> % (threading.current_thread().name, num))</span><br><span class="line">            <span class="keyword">if</span> num &gt;= <span class="number">4</span>:</span><br><span class="line">                mylock.release()</span><br><span class="line">                print(<span class="string">&quot;%s released, Number: %d&quot;</span> % (threading.current_thread().name, num))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            print(<span class="string">&quot;%s released, Number: %d&quot;</span> % (threading.current_thread().name, num))</span><br><span class="line">            mylock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    thread1 = MyThread(<span class="string">&#x27;thread1&#x27;</span>)</span><br><span class="line">    thread2 = MyThread(<span class="string">&#x27;thread2&#x27;</span>)</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br></pre></td></tr></table></figure> 执行结果 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread1 locked, Number: 0</span><br><span class="line">thread1 released, Number: 1</span><br><span class="line">thread1 locked, Number: 1</span><br><span class="line">thread1 released, Number: 2</span><br><span class="line">thread1 locked, Number: 2</span><br><span class="line">thread1 released, Number: 3</span><br><span class="line">thread1 locked, Number: 3</span><br><span class="line">thread1 released, Number: 4</span><br><span class="line">thread1 locked, Number: 4</span><br><span class="line">thread1 released, Number: 4</span><br><span class="line">thread2 locked, Number: 4</span><br><span class="line">thread2 released, Number: 4</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树、B-树的一些性质</title>
    <url>/2021/09/04/tree-feature/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="树">树</h2>
<h4 id="基本性质">基本性质</h4>
<ul>
<li>节点数 = 总度数 + 1</li>
<li>度为m的树，第i层<strong>最多</strong>有<span class="math inline">\(1 \times m \times m^{2} ... = m^{i-1}\)</span>个节点</li>
<li>高度为h的m叉树<strong>最多</strong>有<span class="math inline">\(1+m+m^{2}+... = \frac{m^{h} - 1}{m-1}\)</span>​​</li>
</ul>
<h5 id="求n个节点m叉树的最小高度">求n个节点m叉树的最小高度</h5>
<ol type="1">
<li><p>高度最小，肯定为完全m叉树，$0 &lt; h层节点个数 &lt; m^{h-1} $</p></li>
<li><p>所以$1+m+...+m^{h-2} &lt; n +m+...+m^{h-1} $​​​</p></li>
<li><p>$  &lt; n  $​</p></li>
<li><p>$ m^{h-1} &lt; n(m-1)+1 m^h $​​</p></li>
<li><p><span class="math inline">\(h-1&lt; log_m[n(m-1)] \le h\)</span>​​</p></li>
<li><p>最小高度为$h = log_{m}[n(m-1) + 1] $​​​​​</p></li>
</ol>
<h4 id="顺序存储的m叉树">顺序存储的m叉树</h4>
<p>若从1开始编号，对于节点i有以下性质：</p>
<ul>
<li><p>双亲节点编号为<span class="math inline">\(\lfloor \frac{i-2}{m} \rfloor + 1\)</span>​</p>
<blockquote>
<p>节点i的第一个孩子节点编号=上一个节点编号+m个孩子的个数+1+1，所以j=(i-1)*m+2</p>
</blockquote></li>
<li><p>第k个孩子编号为<span class="math inline">\((i-1)m+k+1\)</span></p>
<blockquote>
<p>由上述可知，第1个子女编号j=(i-1)*m+2，所以第k个孩子编号为(i-1)m+k+1</p>
</blockquote></li>
<li><p>所在层数为<span class="math inline">\(\lfloor log_2i \rfloor + 1\)</span></p></li>
</ul>
<h2 id="二叉树">二叉树</h2>
<h4 id="基本性质-1">基本性质</h4>
<ul>
<li><p><span class="math inline">\(n_0 = n_2 + 1\)</span>​</p></li>
<li><p>高度为h的二叉树<strong>最多</strong>有<span class="math inline">\(m^{h} - 1\)</span>​​个节点（满二叉树）</p></li>
<li><p>n个节点的二叉树（完全二叉树）最小高度为<span class="math inline">\(h = \lceil log_{m}n(m-1) \rceil\)</span>​​</p></li>
</ul>
<h4 id="顺序存储的二叉树">顺序存储的二叉树</h4>
<p>若从1开始编号，对于节点i有以下性质：</p>
<ul>
<li>双亲节点编号为<span class="math inline">\(\lfloor \frac{i}{2} \rfloor\)</span></li>
<li>左孩子编号为2i</li>
<li>右孩子编号为2i+1</li>
<li>所在层数为<span class="math inline">\(\lfloor log_2i \rfloor + 1\)</span></li>
</ul>
<p>若从0开始编号，对于节点i有以下性质：</p>
<ul>
<li><p>双亲节点编号为 (i-1)/2</p></li>
<li><p>左孩子编号为2i+1</p></li>
<li><p>右孩子编号为2i+2</p></li>
</ul>
<h2 id="b树">B树</h2>
<h4 id="基本性质-2">基本性质</h4>
<p>设有m阶B树，设<span class="math inline">\(k = \lceil \frac{m}{2} \rceil\)</span></p>
<p>关键字数的取值范围：</p>
<ul>
<li>根结点 <span class="math inline">\(\in [1, m-1]\)</span></li>
<li>其他 <span class="math inline">\(\in [k-1, m-1]\)</span></li>
</ul>
<p>子结点数/分支数的取值范围：</p>
<ul>
<li>根结点 <span class="math inline">\(\in [2, m]\)</span></li>
<li>其他 <span class="math inline">\(\in [k, m]\)</span></li>
</ul>
<p><strong>关键字个数为n的B树，其叶子节点为n+1个。</strong></p>
<h4 id="最大最小高度">最大最小高度</h4>
<p>根据以上基本性质，可推导出给定关键字数<span class="math inline">\(n\)</span>下的最大和最小高度</p>
<p><strong>最大高度推导：</strong></p>
<p>关键字数一定，想要高度最大，则每个结点的关键字数是最少的，这样高度就能尽可能大，这样<strong>每层的最小关键字数</strong>如下</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">层数</th>
<th style="text-align: center;">节点数</th>
<th style="text-align: center;">关键字数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span class="math inline">\(1\times1\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;"><span class="math inline">\(2\times(k-1)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">2k</td>
<td style="text-align: center;"><span class="math inline">\(2k\times(k-1)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">h</td>
<td style="text-align: center;"><span class="math inline">\(2k^{h-2}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(2k^{h-2}\times(k-1)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">h+1(叶子层)</td>
<td style="text-align: center;"><span class="math inline">\(2k^{h-1}\)</span></td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<p>求和算出关键字数为：<span class="math inline">\(n \ge 2(k-1) 1 + \sum_{i=0}^{h-2}k^i = 2k^{h-1}-1\)</span></p>
<p>也可以利用叶子节点个数为n+1的性质来得到：<span class="math inline">\(n+1 \ge 2k^{h-1}\)</span>，可得到$h log_k() +1 $</p>
<p>根据此公式可算出最大高度</p>
<p><strong>最小高度推导：</strong></p>
<p>关键字数一定，想要高度最小，则每个结点的关键字数是最多的，这样高度就能尽可能小，这样每层的关键字数如下</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">层数</th>
<th style="text-align: center;">节点数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">m</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;"><span class="math inline">\(m^2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">h</td>
<td style="text-align: center;"><span class="math inline">\(m^{h-1}\)</span></td>
</tr>
</tbody>
</table>
<p>每个结点数，关键字数都为最多，即<span class="math inline">\(m-1\)</span>个。</p>
<p>则<span class="math inline">\(n \le (m-1)(1+m+m^2+...+m^h) = m^h -1\)</span></p>
<p>推出<span class="math inline">\(h \ge log_m(n+1)\)</span></p>
<p>给定高度求结点数的最大最小值：</p>
<blockquote>
<p>高度为5的3阶树至少有（）个结点，至多有（）个结点</p>
</blockquote>
<p>节点数最少，即每个结点的子树数最少：</p>
<p>根据 结点数/分支数的取值范围可知3阶B树</p>
<ul>
<li>根结点 <span class="math inline">\(\in [2, 3]\)</span></li>
<li>其他 <span class="math inline">\(\in [2, 3]\)</span></li>
</ul>
<p>这样结点最少，有<span class="math inline">\((1 + 2 + 2^2 + ... + 2^4) = 2^5 -1 = 31\)</span></p>
<p>节点数最多，即每个结点的子树数最多：</p>
<p>结点最多有<span class="math inline">\((1 + 3 + 3^2 + ... + 3^4) = （3^5 -1）/（3-1） = 121\)</span></p>
<h4 id="总结">总结</h4>
<p>根据以下公式算最大最小高度，其中n位关键字个数 <span class="math display">\[
 2k^{h-1} \le n+1 \le m^h
\]</span></p>
<p>不管出什么题都是有基本性质推导的，最大最小高度的性质记住，其他的可以现推。</p>
<h2 id="b树-1">B+树</h2>
<ul>
<li>关键字个数=子树个数</li>
</ul>
<p>根节点：</p>
<ul>
<li><span class="math inline">\(关键字个数 \in [1, m]\)</span></li>
</ul>
<p>其他节点：</p>
<ul>
<li><span class="math inline">\(关键字个数 \in [k, m]\)</span></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>B树</tag>
        <tag>B-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>vim笔记</title>
    <url>/2020/11/21/vim-notes/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="移动光标">移动光标</h2>
<p>gg 移动到第一行 G 移动到最后一行 0 到行首（第 1 列） ^ 到第一个非空白字符 $ 到行尾 <code>&lt;n&gt;gg</code> 移动到第n行 Ctrl-d 向下移动半页 Ctrl-u 向上移动半页</p>
<h2 id="增删改查">增删改查</h2>
<h3 id="增">增</h3>
<p>a (append) i (insert) o (open a line) 以上三种都是在当前字符/行后插入</p>
<p>A 行尾插入 I 行头插入 O 向上新建一行</p>
<h3 id="删-d-delete">删 d delete</h3>
<p>d$ 删除当前字符到行末的内容 x 删除当前字符 dd 剪切当前行 di( 删除()中间的字符 di" 删除引号中间字符 dw 删除当前单词</p>
<h3 id="改-c-change">改 c change</h3>
<p>u 撤销 . 重复 :%s/a/b 全局把a替换成b :s/a/b 替换当前行第一个a为b :s/a/b/g 替换当前行所有a为b :n,$s/a/b 替换第n行到最后一行的a为b</p>
<p>ciw change inner word</p>
<ul>
<li>比如(asdasd) 输入ci(就可以修改括号中间的内容 ctw change to word</li>
<li>比如ct) 就修改 asdasd) 做括号左边的内容</li>
</ul>
<h3 id="查-f-find">查 f find</h3>
<p><code>f&lt;x&gt;</code> 在当前行查找第一个字符x，按;查找下一个，按,查找上一个 <code>F&lt;x&gt;</code> 反向查找</p>
<p>/word 全文查找单词 按n查找下一个，按N查找上一个 ?word 反向查找</p>
<h3 id="复制粘贴">复制粘贴</h3>
<p>y 复制 yy 复制当前行 p 粘贴 P 在上一行粘贴 ### 格式</p>
<p><code>&lt;opration&gt; &lt;motion&gt;</code> d3h 向左删除三个字符 df: 删除当前行:前的内容 y$ 复制当前字符到末尾</p>
<h2 id="配置文件-.vimrc">配置文件 .vimrc</h2>
<p>在<code>~</code>文件夹下新建一个.vimrc文件</p>
<h2 id="visual-模式">visual 模式</h2>
<p>在普通模式下按v进入可视模式 V 进入可视行模式 - 选中后输入:normal <command> 可以执行normal指令 - 选中后:normal A.png 在每行后面添加.png后缀 ctrl+v 进入可视块模式</p>
<h2 id="分屏">分屏</h2>
<h2 id="插件">插件</h2>
<p>到<a href="https://github.com/junegunn/vim-plug">https://github.com/junegunn/vim-plug</a>根据提示安装<code>vim-plug</code> 并且修改配置文件</p>
<h2 id="其他">其他</h2>
<p><a href="https://blog.csdn.net/ii1245712564/article/details/46496347">重复技巧</a></p>
<p><a href="https://github.com/neovim/neovim/wiki/Installing-Neovim">安装neoVim</a></p>
<p><strong>取消搜索高亮</strong>：<code>:noh</code></p>
]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>vue 父子组件通信</title>
    <url>/2020/03/29/vue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="父到子">父到子</h2>
<p>通过在父组件的prop属性向子组件传递数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;student :student&#x3D;&quot;liming&quot;&gt;&lt;&#x2F;student&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">    姓名: &#123;&#123; student.name &#125;&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      student: &#123;</span><br><span class="line">        type: Object,</span><br><span class="line">        default: ()&#x3D;&gt;(&#123;&#125;),</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="子到父">子到父</h2>
<p>子组件通过<code>$emit('eventName', data)</code>产生事件, 在父组件中监听此事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;MyInput @update:data&#x3D;&quot;handleUpdate&quot;&gt;&lt;&#x2F;MyInput&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	export default &#123;</span><br><span class="line">		methods: &#123;</span><br><span class="line">      handleUpdate(data) &#123;</span><br><span class="line">        &#x2F;&#x2F; do something</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&#x2F;&#x2F; 当el-input的输入框的值发生改变, 会触发input事件</span><br><span class="line">	&lt;el-input @input&#x3D;&quot;$emit(&#39;update:data&#39;, value)&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="双向绑定数据">双向绑定数据</h2>
<h3 id="v-model原理">v-model原理</h3>
<p>用v-model实现, v-model只是语法糖, 以下两种写法等同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input v-model&#x3D;&quot;message&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 转换后：</span><br><span class="line">&lt;input</span><br><span class="line">  v-bind:value&#x3D;&quot;message&quot;</span><br><span class="line">  v-on:input&#x3D;&quot;message&#x3D;$event.target.value&quot;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>v-bind把message变量赋值给input的value, 这是<code>input</code>接收数据</li>
<li>v-on监听input事件, 当检测到数据变化, 修改message的值, 这是input发送数据</li>
<li>两者在一起实现了当input的value改变, 则修改message变量</li>
</ul>
<p>实现思想: 统一数据源</p>
<h3 id="方案1-用model属性">方案1 用model属性</h3>
<p>这个方案和上面的一样, 只不过v-model默认绑定属性名为value, 默认事件名为input, 这个方法可以<strong>自定义prop和event</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;SearchBar v-models&#x3D;&quot;text&quot;&gt;&lt;&#x2F;SearchBar&gt;</span><br><span class="line">	&lt;!--等价于--&gt;、</span><br><span class="line">	&lt;SearchBar :search&#x3D;&quot;text&quot; @update:search&#x3D;&quot;this.text &#x3D; $event.target.value&quot;&gt;&lt;&#x2F;SearchBar&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	export default &#123;</span><br><span class="line">		data: ()&#x3D;&gt; &#123;</span><br><span class="line">      text: &#39;&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleUpdate(val) &#123;</span><br><span class="line">        this.text &#x3D; val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">&lt;template&gt;&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	export default &#123;</span><br><span class="line">    name: &quot;SearchBar&quot;,</span><br><span class="line">    model: &#123;</span><br><span class="line">      prop: &#39;search&#39;,</span><br><span class="line">      event: &#39;update:search&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      search: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="方案2-用setter-getter">方案2: 用setter, getter</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;model&quot;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      value: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: &#39;&#39;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    computed: &#123;</span><br><span class="line">      model: &#123;</span><br><span class="line">        get () &#123;</span><br><span class="line">          return this.value</span><br><span class="line">        &#125;,</span><br><span class="line">        set (newVal) &#123;</span><br><span class="line">          this.$emit(&#39;update:value&#39;, newVal)</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>以上例子中, 父组件传来值为value, 如果直接修改子组件中的value，并不会告知父组件数据已修改, 所以设置一个<strong>中间变量</strong>, 把它的getter设置为value, <strong>setter则通知父组件修改数据</strong></p>
<h3 id="方案3-使用watch">方案3: 使用watch</h3>
<p>此方法也是通过监听属性改变, 然后用emit产生事件 实现的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;input :value&#x3D;&quot;searchText&quot; @update:value&#x3D;&quot;handleUpdate&quot;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data: ()&#x3D;&gt; &#123;</span><br><span class="line">			searchText: &quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleUpdate(val) &#123;</span><br><span class="line">        this.searchText &#x3D; val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;input v-model&#x3D;&quot;text&quot;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data: ()&#x3D;&gt; &#123;</span><br><span class="line">			text: &quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      value: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: &#39;&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    watch: &#123;</span><br><span class="line">      text(newVal, oldVal) &#123;</span><br><span class="line">        this.text &#x3D; newVal;  &#x2F;&#x2F; 修改子组件的值</span><br><span class="line">        this.$emit(&#39;update:value&#39;, newVal)	&#x2F;&#x2F; 并且通知父组件</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="方案4-使用-.sync-修饰符">方案4: 使用 .sync 修饰符</h3>
<p>事实上，<code>.sync</code>修饰符是一个简写，它做了一件事情</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">&lt;template&gt;    </span><br><span class="line">	&lt;children :msg.sync&#x3D;&quot;parentMsg&quot;&gt;&lt;&#x2F;children&gt;    </span><br><span class="line">	</span><br><span class="line">	&lt;!-- 等价于 --&gt;    </span><br><span class="line">	&lt;children :msg&#x3D;&quot;parentMsg&quot; @update:msg&#x3D;&quot;parentMsg &#x3D; $event&quot;&lt;&#x2F;children&gt;    &lt;!-- 这里的$event就是子组件$emit传递的参数 --&gt; </span><br><span class="line">	&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<p>只是少写了个update:[prop]的监听事件而已, 当然子组件该怎么写还怎么写</p>
<h3 id="minxin">minxin</h3>
<p>为了实现双向数据绑定，每次创建组件时都需要写相同的代码，所以可以写一个mixin文件，增加重用性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; formMixin.js</span><br><span class="line">const formMixin &#x3D; &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: &quot;data&quot;,</span><br><span class="line">    event: &quot;update&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      type: Object,</span><br><span class="line">      default: () &#x3D;&gt; (&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    formData: &#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        return this.data;</span><br><span class="line">      &#125;,</span><br><span class="line">      set(val) &#123;</span><br><span class="line">        this.$emit(&quot;update&quot;, val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default formMixin;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vuejs</category>
      </categories>
      <tags>
        <tag>vuejs</tag>
        <tag>组件通信</tag>
      </tags>
  </entry>
  <entry>
    <title>zero-tier使用</title>
    <url>/2021/02/06/zero-tier/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="我的情况">我的情况</h2>
<p>设备：PC, mbp, vps</p>
<p>需求：想通过PC直接远程mbp</p>
<h2 id="流程">流程</h2>
<h2 id="准备工作">准备工作</h2>
<p>官网注册，并且创建一个网络，这个网络有个ID，</p>
<h3 id="创建moon节点">创建moon节点</h3>
<p><a href="https://www.cnblogs.com/Yogile/p/12642423.html">参考这篇文章</a></p>
<ol type="1">
<li>安装zerotier</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -s https://install.zerotier.com/ | sudo bash</span><br></pre></td></tr></table></figure>
<p>加入网络，<code>zerotier-cli join &lt;network id&gt;</code></p>
<ol start="2" type="1">
<li>生成moon模板</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /var/lib/zerotier-one</span><br><span class="line">zerotier-idtool initmoon identity.public &gt; moon.json</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><p>修改moon.json 的endpoint选项<code>"stableEndpoints": [ "x.x.x.x/9993" ]</code> 9993是zerotier端口，记得在vps开放udp端口</p></li>
<li><p>生成签名文件 <code>zerotier-idtool genmoon moon.json</code> 之后会生成一个000000xxxx.moon 文件。</p></li>
<li><p><strong>将 moon 节点加入网络</strong></p></li>
</ol>
<p>在 VPS 的 Zerotier 安装目录下（/var/lib/zerotier-one）建立文件夹 moons.d，将生成的 .moon文件拷贝进去。<code>cp 0000006xxxxxxxxx.moon moons.d/</code></p>
<p>重启 zerotier，重启服务。<code>/etc/init.d/zerotier-one restart</code>至此，VPS 上（moon 服务器）配置完成。 记住moon.json中的id</p>
<h3 id="设备端">设备端</h3>
<p><a href="https://www.cnblogs.com/Yogile/p/12502311.html">参考这篇文章</a></p>
<p>不同系统都不一样</p>
<h4 id="mac">MAC</h4>
<ul>
<li>加入moon节点 <code>sudo zeroiter-one orbit &lt;id&gt; &lt;repeart_id&gt;</code> id是moon.json中的</li>
<li>检验是否成功<code>sudo zeroiter-one listpeers</code></li>
<li></li>
</ul>
<h2 id="文件共享">文件共享</h2>
<h3 id="pc---mac">pc -&gt; mac</h3>
<p>首先在PC上开启共享功能，以及选择共享文件夹 <a href="https://zhuanlan.zhihu.com/p/110788184">参考此文章</a></p>
<p>在zerotier官网的网络中可以看leaf的局域网ip，这个ip是固定的</p>
<p>之后到finder中按下command+k输入cifs://<ip></p>
<p>然后对话框中输入pc的登录账户和密码就可以连接了</p>
<h3 id="mac---pc">mac -&gt; pc</h3>
<p><a href="http://www.xitongcheng.com/jiaocheng/dnrj_article_48868.html">参考这篇文章</a></p>
<p>在mac上设置好共享文件夹后，直接打开pc的网络就能看到共享文件夹</p>
<h2 id="远程桌面">远程桌面</h2>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>zero tier</tag>
        <tag>内网穿透</tag>
        <tag>远程桌面</tag>
      </tags>
  </entry>
  <entry>
    <title>仿射变换 矩阵运算</title>
    <url>/2021/01/16/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2-%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="平移">平移</h2>
<p><span class="math inline">\((x, y) -&gt; (u, y)\)</span></p>
<p><span class="math inline">\(u = a_1x+b_1y+c_1\)</span></p>
<p><span class="math inline">\(v = a_2x+b_2+c_2\)</span></p>
<span id="more"></span>
<p>矩阵形式 <span class="math display">\[
\begin{pmatrix}
u\\
v\\
\end{pmatrix}
=
\begin{pmatrix}
a_1 &amp; b_1\\
a_2 &amp; b_2\\
\end{pmatrix}
\begin{pmatrix}
x\\
y\\
\end{pmatrix}
+
\begin{pmatrix}
c_1\\
c_2\\
\end{pmatrix}
\]</span></p>
<h2 id="旋转">旋转</h2>
<p>绕原点旋转。</p>
<p><span class="math display">\[
\begin{pmatrix}
u\\
v\\
\end{pmatrix}
=
\begin{pmatrix}
cos\theta &amp; -sin\theta\\
-sin\theta &amp; cos\theta\\
\end{pmatrix}
\begin{pmatrix}
x\\
y\\
\end{pmatrix}
+
\begin{pmatrix}
0\\
0\\
\end{pmatrix}
\]</span></p>
<h2 id="刚体变换">刚体变换</h2>
<p>旋转+平移也称刚体变换（Rigid Transform），就是说如果图像变换前后<strong>两点间的距离</strong>仍然保持不变，那么这种变化就称为刚体变换。 <span class="math display">\[
\begin{pmatrix}
u\\
v\\
\end{pmatrix}
=
\begin{pmatrix}
cos\theta &amp; -sin\theta\\
sin\theta &amp; cos\theta\\
\end{pmatrix}
\begin{pmatrix}
x\\
y\\
\end{pmatrix}
+
\begin{pmatrix}
t_X\\
t_y\\
\end{pmatrix}
\]</span></p>
<h2 id="翻转">翻转</h2>
<h3 id="垂直翻转">垂直翻转</h3>
<p><span class="math inline">\(u=x; v=-y\)</span></p>
<p>矩阵形式 <span class="math display">\[
\begin{pmatrix}
u\\
v\\
\end{pmatrix}
=
\begin{pmatrix}
1 &amp; 0\\
0 &amp; -1\\
\end{pmatrix}
\begin{pmatrix}
x\\
y\\
\end{pmatrix}
+
\begin{pmatrix}
0\\
0\\
\end{pmatrix}
\]</span></p>
<h3 id="水平翻转">水平翻转</h3>
<p><span class="math inline">\(u=-x; v=y\)</span></p>
<p>矩阵形式 <span class="math display">\[
\begin{pmatrix}
u\\
v\\
\end{pmatrix}
=
\begin{pmatrix}
-1 &amp; 0\\
0 &amp; 1\\
\end{pmatrix}
\begin{pmatrix}
x\\
y\\
\end{pmatrix}
+
\begin{pmatrix}
0\\
0\\
\end{pmatrix}
\]</span></p>
<h3 id="垂直水平翻转">垂直水平翻转</h3>
<p><span class="math inline">\(u=-x; v=-y\)</span></p>
<p>矩阵形式 <span class="math display">\[
\begin{pmatrix}
u\\
v\\
\end{pmatrix}
=
\begin{pmatrix}
-1 &amp; 0\\
0 &amp; -1\\
\end{pmatrix}
\begin{pmatrix}
x\\
y\\
\end{pmatrix}
+
\begin{pmatrix}
0\\
0\\
\end{pmatrix}
\]</span></p>
<h2 id="缩放">缩放</h2>
<p><span class="math inline">\(u = s_xx; v = s_yy\)</span></p>
<p>矩阵形式</p>
<p><span class="math display">\[
\begin{pmatrix}
u\\
v\\
\end{pmatrix}
=
\begin{pmatrix}
s_x &amp; 0\\
0 &amp; s_y\\
\end{pmatrix}
\begin{pmatrix}
x\\
y\\
\end{pmatrix}
+
\begin{pmatrix}
0\\
0\\
\end{pmatrix}
\]</span></p>
<h2 id="相似变换">相似变换</h2>
<p>相似变换又称缩放旋转，相似变换包含了旋转、等比例缩放和平移等变换。 若缩放比例为scale，旋转角度为θ，旋转中心是$ (center_x,center_y) $，则仿射变换可以表示为： <span class="math display">\[
\begin{pmatrix}
u\\
v\\
\end{pmatrix}
=
\begin{pmatrix}
\alpha &amp; \beta\\
-\beta &amp; \alpha\\
\end{pmatrix}
\begin{pmatrix}
x\\
y\\
\end{pmatrix}
+
\begin{pmatrix}
(1-\alpha)center_x &amp; -\beta center_y\\
\beta center_x &amp; (1-\alpha)center_y\\
\end{pmatrix}
\]</span></p>
<h2 id="透视变换">透视变换</h2>
<p><a href="https://baike.baidu.com/item/透视变换">透视变换</a>（Perspective Transformation）是将二维的图片投影到一个三维视平面上，然后再转换到二维坐标下，所以也称为投影映射（Projective Mapping）。简单来说就是二维→三维→二维的一个过程。</p>
<p>$X=a_1x+b_1y+c_1 $</p>
<p><span class="math inline">\(Y=a_2x+b_2y+c_2\)</span></p>
<p><span class="math inline">\(Z=a_3x+b_3y+c_3\)</span> <span class="math display">\[
\begin{pmatrix}
X\\
Y\\
Z
\end{pmatrix}
=
\begin{pmatrix}
a_1 &amp; b_1 &amp; c_1\\
a_1 &amp; b_1 &amp; c_1\\
a_1 &amp; b_1 &amp; c_1\\
\end{pmatrix}
\begin{pmatrix}
x\\
y\\
1
\end{pmatrix}
\]</span></p>
]]></content>
      <categories>
        <category>dip</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>指令系统、CPU、流水线综合</title>
    <url>/2021/09/20/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E7%BB%BC%E5%90%88/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="alu加减法标志位">ALU加减法，标志位</h2>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/%E6%88%AA%E5%B1%8F2021-09-20%20%E4%B8%8B%E5%8D%883.56.51.png" /></p>
<p>上图电路可以实现无符号数的加法和减法，当为加法时，sub=0，X和Y作为加法器的输入。当sub=1时，Y被取反，并且加上了Cin=1，相当于X和Y补作为加法器输入，实现了减法。Cin, Cout分别为上一位的进位，和本位的进位。</p>
<p><strong>ZF：</strong> 零标志（Zero Flag），ZF=1表示有符号/无符号计算结果为0。用于判断while条件中的相等</p>
<p><strong>OF：</strong> 溢出标志(Overflow Flag)，OF=1表示<strong>有符号整数</strong>溢出，无符号数看CF</p>
<p><strong>CF：</strong> 进/借位标志（Carry Flag），判断<strong>无符号数</strong>溢出，CF=1时，若sub=0,加法,则表示进位溢出，若sub=1, 为减法, 则表示借位溢出（不够减）。<span class="math inline">\(CF= Sub \oplus Cout（Sub==Cin）\)</span>。CF=1表示溢出</p>
<p><strong>SF：</strong> 符号标志（Sign Flag），SF=两个数最高位异或，<strong>计算结果的符号</strong>。根OF搭配实现大小关系。</p>
<p>这些标志位都属于PSW（程序状态寄存器），与跳转条件指令有关，条件判断的本质位一个减法，如当a==1时跳转，会计算a-1，判断ZF是否位0，若位0则jmp</p>
<p>计算a-b</p>
<p>若OF=SF，表示大于，如OF=0，SF=0，没有溢出，结果符号为0，说明a&gt;b</p>
<p>若OF<span class="math inline">\(\ne\)</span>SF，表示小于，OF=0, SF=1，没有溢出，结果符号为1，说明a&lt;b</p>
<p>ZF=1，a=b</p>
<p>例题</p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/%E6%88%AA%E5%B1%8F2021-09-22%20%E4%B8%8B%E5%8D%884.45.52.png" /></p>
<p>（3）无符号数相减，a-b，若a&lt;b，肯定发生了借位即CF=1，若a=b，结果为0，ZF=0，所以C，Z，N应该为1, 1, 0</p>
<h2 id="溢出判断">溢出判断</h2>
<h3 id="无符号数加减法">无符号数加减法</h3>
<p><span class="math inline">\(CF = Sub \oplus Cout\)</span> ，公式要记住，2017年考了，sub代表减法，Cout代表进位。如0110+0100，cout=0，sub=0，所以CF=0</p>
<h3 id="有符号数加减法">有符号数加减法</h3>
<p>真题 2018 19题</p>
<ol type="1">
<li><p>一位符号位，只有符号相同的数相加才会发生溢出，因此判断条件：两个正数相加，结果为负，则溢出。</p>
<p><a href="https://www.zhihu.com/question/265388131">如何确定数值计算后的SF,ZF,CF,OF？ - 知乎 (zhihu.com)</a></p></li>
<li><p>一位符号位，符号位<strong>进位</strong>与最高数位<strong>进位</strong>相同则无溢出，否则溢出。</p></li>
<li><p>两位符号位，01正溢出，10负溢出。</p></li>
</ol>
<h3 id="无符号数乘法">无符号数乘法</h3>
<ol type="1">
<li>两个n位的无符号数a、b相乘，左边n位必须全0，否则溢出</li>
<li>手算：计算两个数十进制乘积，看是否超出了n位数能表示的范围</li>
</ol>
<blockquote>
<p>2020真题</p>
</blockquote>
<h3 id="有符号数乘法补码">有符号数乘法（补码）</h3>
<ol type="1">
<li>两个n位的有符号数a、b相乘，左边<strong>n+1位</strong>必须<strong>全0或全1</strong>，否则溢出</li>
<li>手算：计算两个数十进制乘积，看是否超出了n位有符号数能表示的范围</li>
</ol>
<p>为什么是前n+1位呢？假设两个4位数相乘，结果为正数，最大正数为0111，扩展为8位（正数补0），0000 0111，若前面5位有一位为1，就超过了4位能表示的最大正数。若结果为负数，最小负数为1000,扩展（负数补1），1111 1000，若前5位有一位为0，就超过了最小负数。</p>
<blockquote>
<p>2019真题</p>
</blockquote>
<h3 id="移位">移位</h3>
<p>对于<span class="math inline">\([X]_补=X_0.X_1X_2...X_n\)</span>，补码左移，什么情况会发生溢出？</p>
<p>​ <span class="math inline">\(X_0 \ne X1\)</span>时会溢出，可以用双符号位理解，当左移双符号位变为<span class="math inline">\(X_0X_1\)</span>，不相等肯定溢出。</p>
<h3 id="浮点数">浮点数</h3>
<h2 id="电路图元件">电路图元件</h2>
<p><span class="math inline">\(X_{in}\)</span> 控制寄存器数据流入</p>
<p><span class="math inline">\(X_{out}\)</span> 控制寄存器数据流出</p>
<p><span class="math inline">\(X_{op}\)</span> 控制器件的操作，比如<span class="math inline">\(ALU_{op}\)</span>可以控制ALU操作为add、sub…</p>
<blockquote>
<p>若<span class="math inline">\(PC_{out}=1, MAR_{in}=1\)</span>则<span class="math inline">\(PC \rarr MAR\)</span></p>
</blockquote>
<p>三态门：三种状态分别是连接、断开、高阻（了解）。控制器件与总线之间数据通路之间的连接与断开</p>
<p>暂存器：暂存数据，一般与ALU搭配使用。如ALU有两个输入a和b，如果没有暂存器，数据总线同时连通a和b，造成两个输入端一样，增加暂存器可以将一个数据暂存其中，另一个数通过数据总线直接送入ALU，可以实现两个不同的输入。</p>
<p>移位寄存器：实现移位运算</p>
<p>多路选择器MUX：从多个输入中选择一个输出，控制信号为<span class="math inline">\(MUX_{op}\)</span></p>
<p>译码器：n个输入<span class="math inline">\(2^n\)</span>个输出，如对IR中的指令的操作码字段译码，向控制器提供特定的操作信号</p>
<h2 id="一条指令执行过程">一条指令执行过程</h2>
<p>一个指令周期可以分为4个机器周期：取指、间址、执行、中断。通常考数据流向、电路连线、元器件识别</p>
<p><strong>取指</strong>：</p>
<ol type="1">
<li><span class="math inline">\(PC \rarr MAR \rarr 地址总线 \rarr M\)</span></li>
<li><span class="math inline">\(CU读命令 \rarr 控制总线 \rarr M\)</span></li>
<li><span class="math inline">\(M \rarr 数据总线 \rarr MDR \rarr IR\)</span></li>
<li><span class="math inline">\(CU读命令\)</span></li>
<li><span class="math inline">\((PC)+1\)</span></li>
</ol>
<p><strong>间址:</strong>(和取指周期前三步差不多)</p>
<ol type="1">
<li><span class="math inline">\(Ad(IR) \rarr MAR \rarr 地址总线 \rarr M\)</span></li>
<li><span class="math inline">\(CU读命令 \rarr 控制总线 \rarr M\)</span></li>
<li><span class="math inline">\(M \rarr 数据总线 \rarr MDR\)</span></li>
</ol>
<p><strong>执行：</strong>不统一</p>
<p><strong>中断：</strong></p>
<p>中断周期要做的事是保存程序断点到主存，所以要访存。堆栈在主存中，SP是栈顶指针地址。因为堆栈从高地址到低地址，所以SP-1而不是+1</p>
<ol type="1">
<li><span class="math inline">\(CU控制信号使SP-1, SP \rarr MAR \rarr 地址总线 \rarr M\)</span></li>
<li><span class="math inline">\(CU写命令 \rarr 控制总线 \rarr M\)</span></li>
<li><span class="math inline">\(PC \rarr MDR \rarr 数据总线 \rarr M （将PC保存到SP指向的内存）\)</span></li>
<li><span class="math inline">\(CU将中断程序的入口地址 \rarr PC\)</span></li>
</ol>
<h2 id="一系列指令执行过程">一系列指令执行过程</h2>
<h3 id="x86">x86</h3>
<h4 id="数据表示">数据表示</h4>
<p>字大小：16bit</p>
<p>题目中exx代表32位寄存器，e开头, 3个字母，如eax，ebp …。若是两个字母ax、bx等是16位寄存器</p>
<p>如果数据来自于寄存器，会写作eax，若访问内存，会加个括号，（eax+02H）, [eax+8]</p>
<p>寻址时2个寄存器之间只能相加，最多用2个寄存器和1个有符号数计算地址，王道4.2.3 P172</p>
<p><code>mov dword ptr [eax], 2</code> [eax]是读/写的地址, dword ptr指明读取单位是2个字即32bit，因此这条指令操作是：把2以4Byte形式传送到内存地址[eax]中。</p>
<h4 id="算术逻辑运算指令">算术逻辑运算指令</h4>
<p>add、sub、mul、imul、div、div、inc、dec、shl、shr</p>
<h4 id="分支结构">分支结构</h4>
<p>if/else/switch，判断条件的本质是计算a-b（cmp A, B），根据PSW来决定是否跳转，无符号数看CF、ZF，有符号数看OF、SF、ZF。</p>
<p>汇编语言：</p>
<p>jmp和com一起使用，下面例子为：当eax&lt;=ebx时，跳转到03H。在条件跳转之前一定有一个cmp，无条件跳转则没有。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmp	eax,	ebx</span><br><span class="line">jle	03H</span><br></pre></td></tr></table></figure>
<p>电路结构：jmp是让PC加上偏移完成跳转，(PC)+指令字长+(指令字长*OFFSET)</p>
<p>下面是条件跳转的结构图，</p>
<p>1为指令寄存器，C、Z、N代表若=1，则检查CF、ZF、NF，若其中有一个为1就跳转</p>
<p>2是？</p>
<p>3是？</p>
<p>若要实现小于等于时跳转，ZF=1，CF=1，因此Z、C为1，当标志寄存器中的CF、ZF为1，Z&amp;ZF=1，C&amp;CF=1，一起经过或门，其输出为多路选择器的控制端，若为1则跳转，否则PC+2（这题字长为2B）。</p>
<p>由此可知3的输出肯定为PC+2+2x偏移量，右边输入为PC+2，所以3位加法器。那2的输出是OFFSETx2，可知2位移位寄存器。</p>
<p>当满足条件，多路选择器输出为PC+2+2xoffset，修改PC，完成跳转，否则PC就自增指令字长/字节，跳到下一条指令。</p>
<blockquote>
<p>偏移量是针对下一条指令，所以先+2，再+2x偏移</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/%E6%88%AA%E5%B1%8F2021-09-23%20%E4%B8%8B%E5%8D%882.59.59.png" /></p>
<h4 id="循环结构">循环结构</h4>
<p>for、while，原理同跳转指令</p>
<p>C语言：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">  <span class="keyword">do</span> something</span><br></pre></td></tr></table></figure>
<p>汇编语言：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Loop1: </span><br><span class="line">	&lt;do something&gt;</span><br><span class="line"></span><br><span class="line">inc i</span><br><span class="line">cmp i, N</span><br><span class="line">jl Loop1		&#x2F;&#x2F; i&lt;N满足条件，继续循环</span><br></pre></td></tr></table></figure>
<h4 id="函数调用">函数调用</h4>
<p>call/ret与push、pop搭配使用，call则将<strong>当前PC地址、函数实参、栈底指针</strong>入栈，ret则弹出上一层函数的地址，继续执行。比如:</p>
<p><strong>当前PC地址是：call指令的下一条指令地址。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">f1()&#123;</span><br><span class="line">  f2();</span><br><span class="line">  f3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在执行完f2，接下来应该执行f3，ret，pop出一个地址，这个地址是f3函数的地址，栈底指针是f1函数的栈底指针。</p>
<blockquote>
<p>栈底指针： 每个函数都有一个栈和栈底指针，在函数定义局部变量时相当于把变量的值入栈，因此要保存函数现场，要把栈底指针保存，要找局部变量时，要先找到当前调用程序的栈底指针，再根据偏移找到变量。EBP栈底指针，ESP栈顶指针。</p>
</blockquote>
<p>汇编：</p>
<p>每个函数第一条指令为push ebp，意思是保护先前EBP指针， EBP入栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push ebp	&#x2F;&#x2F; 保护上层函数地址</span><br><span class="line">move ebp esp &#x2F;&#x2F; 把esp栈顶指针设置为ebp栈底指针</span><br><span class="line"></span><br><span class="line">cmp n, 1		&#x2F;&#x2F; 比较</span><br><span class="line">jle	xxx			&#x2F;&#x2F; 根据结果跳转</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="程序举例">程序举例</h4>
<ul>
<li><p>访问数组时格式<code>move arr (, %edi, 4)  %edx</code></p>
<p>arr时数组地址，%edi是index，4是数组元素占字节数(int)，这个代码的意思是<code>arr[edi] -&gt; %edx</code></p></li>
<li><p>mov的间接寻址<code>mov 8(%ebp), %edi</code> 8(%ebp)的意思是，基于%ebp偏移8个单元</p></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">    s += arr[i]</span><br><span class="line">  retrun s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push	%ebp								&#x2F;&#x2F; 保护上层函数指针</span><br><span class="line">mov		%esp, %ebp						&#x2F;&#x2F; 栈顶指针指向栈底</span><br><span class="line">sub		$0x10, -0x4(%ebp)		&#x2F;&#x2F; -0x4(%ebp)是相对寻址，这个单元存放变量i的值</span><br><span class="line">movl	$0x0, -0x4(%ebp)		&#x2F;&#x2F; i&#x3D;0</span><br><span class="line">jmp		第12行</span><br><span class="line">mov		-0x4(%ebp), %eax		&#x2F;&#x2F; 把栈底指针偏移-4字节的数据移入%eax，使%eax存放i的值</span><br><span class="line">mov		arr(, %eax, 4), %edx	&#x2F;&#x2F; arr[%eax] -&gt; %edx, %eax是索引</span><br><span class="line">mov		s, %eax							&#x2F;&#x2F; s是累加变量sum的地址，传给%eax</span><br><span class="line">add		%edx, %eax					&#x2F;&#x2F; sum +&#x3D; arr[i]</span><br><span class="line">mov		%edx, s</span><br><span class="line">addl	%0x1, -0x4(%ebp)		&#x2F;&#x2F; i++</span><br><span class="line">cmpl	%0x3, -0x4(%ebp)		&#x2F;&#x2F; i-3</span><br><span class="line">jle		第6行								&#x2F;&#x2F; if i&lt;3, 跳转</span><br><span class="line">mov		s, %eax						</span><br><span class="line">leave</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<h3 id="mips">MIPS</h3>
<h4 id="五段流水线">五段流水线</h4>
<p>流水线一般结合MIPS32（RISC）考，不和X86一起考，因为X86是CISC不支持流水线。</p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/%E6%88%AA%E5%B1%8F2021-07-09%20%E4%B8%8B%E5%8D%8811.53.18.png" /></p>
<p>简单介绍一下指令执行过程，<strong>注意：以下不是所有指令都具有，只是为了方便设计流水线，每个指令周期都有这几个机器周期，但周期内可能为空指令（空指令阶段什么都不做，但是要消耗时间），必须知道每种指令的机器周期有哪些。</strong></p>
<ol type="1">
<li>IF阶段，根据PC值从指令cache中取出指令，并将指令放在指令寄存器中，这是每个指令都要做的</li>
<li>ID阶段，对指令译码，并从cache中取操作数(取不到则从主存找)，并存放到ID段的锁存器中，这里有三个：A、B、Imm，Imm代表立即数</li>
<li>EX阶段，ALU将上一步得到的操作信息进行运算，运算结果放入EX段锁存器</li>
<li>M阶段，访存阶段，只有Load和Store访存</li>
<li>WB阶段，将数据写回<strong>寄存器</strong></li>
</ol>
<h5 id="运算类指令">运算类指令</h5>
<p>如ADD，SUB，SHL等，其指令周期为：</p>
<ol type="1">
<li>IF</li>
<li>ID，取出需要进行运算的操作数</li>
<li>EX，将运算结果放入寄存器中，等待WB阶段写回寄存器</li>
<li><strong>M ，空段</strong>，因为运算器运算的结果肯定是要直接放入某个寄存器中，因此不需要访存，例如ADD Rs, Rd的功能为<span class="math inline">\((Rs)+(Rd) \rarr Rd\)</span>，无访存阶段</li>
<li>WB，运算结果写回寄存器</li>
</ol>
<h5 id="load指令">LOAD指令</h5>
<p>LOAD Rd,996(Rs)，其功能为<span class="math inline">\((996 + (Rs)) \rarr Rd\)</span>，通常情况下，LOAD指令都要使用基址寻址，从表达式中可以看出进行了加法运算，因此必定有EX阶段</p>
<ol type="1">
<li>IF，每个指令都要有这个阶段</li>
<li>ID，将基地址(Rs)取出，放到锁存器A中，偏移量的值放入Imm中</li>
<li>EX，得到有效地址EA</li>
<li>M，从cache的EA地址取数，并存放到锁存器</li>
<li>WB，将该数写回Rd寄存器</li>
</ol>
<h5 id="store指令">STORE指令</h5>
<p>STORE Rs, 996(Rd)，其功能为<span class="math inline">\(Rs \rarr (996+(Rd))\)</span>，其前三个步骤都与LOAD一样</p>
<ol start="4" type="1">
<li>M，写入数据到cache，这一步就完成了STORE指令目的</li>
<li><strong>WB，空</strong></li>
</ol>
<h5 id="条件转移">条件转移</h5>
<p>采用相对寻址，如beq Rs, Rt, #偏移量，其功能为：若Rs==Rt，则(PC) + 指令字长/字节 + (指令字长/字节x偏移量) -&gt; PC，否则(PC) + 指令字长/字节 <span class="math inline">\(\rarr\)</span> PC(即顺序执行)</p>
<blockquote>
<p>注：跳转到相对于下一条指令的偏移地址，这里指令字长单位是bit，字节是8bit。若指令字长为字节B，可以写作(PC) + 指令字长 + (指令字长x偏移量) -&gt; PC</p>
</blockquote>
<ol type="1">
<li>IF</li>
<li>ID，取出要比较的两个数，放入A、B锁存器，偏移量放入Imm中</li>
<li>EX，运算，比较两个数</li>
<li>M，不访存，这个阶段更新PC值</li>
<li><strong>WB， 空</strong>，计算结果只是为了判断跳转，不需要写回</li>
</ol>
<h5 id="无条件转移">无条件转移</h5>
<p>采用相对寻址，如jmp #偏移量，其功能为：(PC) + 指令字长/字节 + (偏移量/字节x指令字长) -&gt; PC</p>
<blockquote>
<p>注：跳转到相对于下一条指令的偏移地址</p>
</blockquote>
<ol type="1">
<li>IF</li>
<li>ID，偏移量放入Imm中</li>
<li>EX，这个阶段更新PC值</li>
<li><strong>M，空</strong></li>
<li><strong>WB， 空</strong></li>
</ol>
<h4 id="判断是否冲突">判断是否冲突</h4>
<p><a href="https://blog.csdn.net/Cyril_KI/article/details/111770213">流水线中数据相关的理解（RAW、WAR和WAW）_Cyril_KI的博客-CSDN博客</a></p>
<p>判断方法：判断两条指令什么相关，若<strong>时间上先运行</strong>的指令向R1<strong>写</strong>，但是还没写入时，<strong>时间上后运行</strong>的指令向R1<strong>读</strong>，这就发生了写后读。</p>
<h5 id="方法">方法</h5>
<ol type="1">
<li>判断指令类型：运算类、load、store、条件转移、无条件转移</li>
<li>写出每个指令需要的机器周期</li>
<li>画图</li>
</ol>
<h5 id="例1">例1</h5>
<p>在无转发机制的五段基本流水线（取指、译码/读寄存器、运算、访存、写回寄存器）中，下列指令存在数据冒险的指令对是（）</p>
<p>I1: add R1, R2, R3; (R2) + (R3) -&gt; R1</p>
<p>I2: add R5, R2, R4; (R2) + (R4) -&gt; R5</p>
<p>I3: add R4, R5, R3; (R5) + (R3) -&gt; R4</p>
<p>I4: add R5, R2, R6; (R2) + (R6) -&gt; R5</p>
<p>A I1, I2</p>
<p>B I2, I3</p>
<p>C I2, I4</p>
<p>D I3, I4</p>
<table>
<thead>
<tr class="header">
<th>指令</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>I1</td>
<td>IE</td>
<td>ID(R2, R3)</td>
<td>EX</td>
<td>M</td>
<td>WB(R1)</td>
<td></td>
</tr>
<tr class="even">
<td>I2</td>
<td></td>
<td>IE</td>
<td>ID(R2, R4)</td>
<td>EX</td>
<td>M</td>
<td>WB(R5)</td>
</tr>
</tbody>
</table>
<p>可以看到I1在5写的寄存器R1和I2使用到的寄存器无关，因此不存在冲突，继续添加指令</p>
<table>
<thead>
<tr class="header">
<th>指令</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>I1</td>
<td>IE</td>
<td>ID(R2, R3)</td>
<td>EX</td>
<td>M</td>
<td>WB(R1)</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>I2</td>
<td></td>
<td>IE</td>
<td>ID(R2, R4)</td>
<td>EX</td>
<td>M</td>
<td>WB(R5)</td>
<td></td>
</tr>
<tr class="odd">
<td>I3</td>
<td></td>
<td></td>
<td>IE</td>
<td>ID(R5, R3)</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>写到这一步发现，I3在4要读R5，但是上一条指令还没写完，于是便出现了RAW冲突，所以选B</p>
<p>解决方法是等待</p>
<table>
<thead>
<tr class="header">
<th>指令</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>I1</td>
<td>IE</td>
<td>ID(R2, R3)</td>
<td>EX</td>
<td>M(空)</td>
<td>WB(R1)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>I2</td>
<td></td>
<td>IE</td>
<td>ID(R2, R4)</td>
<td>EX</td>
<td>M(空)</td>
<td>WB(R5)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>I3</td>
<td></td>
<td></td>
<td>IE</td>
<td></td>
<td></td>
<td></td>
<td>ID(R5, R3)</td>
<td>EX</td>
<td>M(空)</td>
<td>WB(R4)</td>
</tr>
</tbody>
</table>
<h5 id="例2">例2</h5>
<p>判断：流水线按序流动时，在RAW、WAR和WAW中，只可能出现RAW相关。</p>
<p>对。当流水线按序流动，其图像如下：</p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/%E6%88%AA%E5%B1%8F2021-07-10%20%E4%B8%8A%E5%8D%881.12.33.png" /></p>
<ol type="1">
<li>I1的2是读数据，I2、I3中的WB是写，都在2其之后，所以不存在WAR(读后写)相关</li>
<li>I1的5是写数据，如果I2的3访问到了I1写的寄存器，就出现了RAW(写后读)相关</li>
<li>I1的5是写，I2的6是写，在I1的写之后，所以不存在WAW相关</li>
</ol>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>面试问题(计算机基础)</title>
    <url>/2020/08/05/interview/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="数据库">数据库</h2>
<h3 id="acid">ACID</h3>
<ul>
<li><p>A, atomacity 原子性 事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。通常，与某个事务关联的操作具有共同的目标，并且是相互依赖的。如果系统只执行这些操作的一个子集，则可能会破坏事务的总体目标。原子性消除了系统处理操作子集的可能性。</p></li>
<li><p>C, consistency 一致性</p>
<p>事务在完成时，必须使所有的数据都保持一致状态（各种 constraint 不被破坏）。</p></li>
<li><p>I, isolation 隔离性 一个事务的影响在该事务提交前对其他事务都不可见。</p></li>
<li><p>D, durability 持久性</p>
<p>事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持。</p></li>
</ul>
<h4 id="三大范式">三大范式</h4>
<p>https://cloud.tencent.com/developer/article/1415705</p>
<p>https://juejin.im/post/6844904029617651720</p>
<h5 id="nf">1NF:</h5>
<p>数据原子性，表中的字段不可再分。eg地区字段可以分解为省份，城市，和具体地址三个字端。</p>
<h5 id="nf-1">2NF:</h5>
<p>在1NF的基础上，消除了部分函数依赖，即每个非主属性完全依赖于主键。</p>
<p>eg：一个选课关系表有（学号，姓名，课号）三个字段，因为一个学生对应多个课程，一个课程对应多个学生，所以（学号，课号）可以唯一确定一条记录。用（学号，课号）作为主键，但是姓名可以根据学号唯一确定，所以姓名部分函数依赖于学号，这不符合第二范式的定义。</p>
<p><strong>带来的问题</strong></p>
<p>数据冗余</p>
<p>增删改出现问题 eg：如果想增加一个课程，这个课程如果没有人选就无法添加，如果一个课程只有一个人选，那么退课的时候也会删除课程，如果要更新课程的名称，那就要更新所有包含此课程的记录。</p>
<h5 id="nf-2">3NF</h5>
<p>在2NF的基础上，消除非主属性对主属性的传递函数依赖。</p>
<p>不符合3NF会带来数据冗余和更新异常的问题。（更新异常：有重复的冗余信息，修改时需要同时修改多条记录，否则会出现数据不一致的情况 。）</p>
<p>eg：（学号，系号，系名）中，学号决定系号，系号决定系名，这样存在传递函数依赖学号决定系名。</p>
<p>范式化的优点：</p>
<ul>
<li>可以尽量的减少数据冗余，数据表更新快体积小</li>
<li>范式化的更新操作比反范式化更快</li>
<li>范式化的表通常比反范式化更小</li>
</ul>
<p>缺点：</p>
<ul>
<li>对于查询需要对多个表进行关联（导致性能降低）</li>
<li>更难进行索引优化</li>
</ul>
<h4 id="数据库索引">数据库索引</h4>
<h4 id="b树">B+树</h4>
<h2 id="计算机网络">计算机网络</h2>
<p>osi模型</p>
<ol type="1">
<li><p>应用层(数据):是计算机用户以及各种应用程序和网络之间的接口</p></li>
<li><p>表示层(数据):它对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。</p></li>
<li><p>会话层(数据):不同机器上的用户建立会话</p></li>
<li><p>传输层(段):实现网络不同主机上用户进程之间的数据通信，可靠与不可靠的传输，传输层的错误检测，流量控制等</p></li>
<li><p>网络层(包):提供逻辑地址(IP)、通过路径选择算法将数据从源端到目的端</p></li>
<li><p>数据链路层(帧):将比特流数据封装成帧，增加错误检测与修正等功能，增加可靠性</p></li>
<li><p>物理层(比特流):利用物理介质提供物理连接，提供比特流传输</p></li>
</ol>
<h3 id="tcpip">TCP/IP</h3>
<p>TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。</p>
<p>链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。</p>
<p>网络层：负责路由以及把分组报文发送给目标网络或主机。点对点</p>
<p>传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。</p>
<p>应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。</p>
<h3 id="链路层">链路层</h3>
<h4 id="arp协议">ARP协议</h4>
<p>1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。</p>
<p>2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。</p>
<p>3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。</p>
<p>4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p>
<p>广播发送ARP请求，单播发送ARP响应。</p>
<ul>
<li><p>作用</p>
<p>ARP 为 IP 地址到对应的硬件地址提供动态映射。</p></li>
<li><p>点对点链路使用 ARP 吗?</p>
<p>不使用</p></li>
<li><p>ARP 高效运行的关键是什么?</p>
<p>关键是每个主机上都有一个 ARP 的高速缓存。</p></li>
</ul>
<h3 id="传输层">传输层</h3>
<h4 id="tcp-udp简单介绍">TCP UDP简单介绍</h4>
<p>TCP提供的是面向连接，可靠的字节流服务。即客户端和服务器交换数据前，必须现在双方之间建立一个TCP连接，之后才能传输数据。并且提供超时重发，流量控制等功能，保证数据能从一端传到另一端。</p>
<p>UDP（User Data Protocol，用户数据报协议）是一个简单的面向数据报的运输层协议。它不提供可靠性，只是把数据报发送出去，但是不能保证它们能到达目的地。由于UDP在传输数据报前不用再客户和服务器之间建立一个连接，且没有超时重发等机制，所以传输速度很快。</p>
<p><strong>使用场景</strong></p>
<p>对实时性要求高和高速传输的场合下使用UDP;在可靠性要求低，追求效率的情况下使用UDP; 需要传输大量数据且对可靠性要求高的情况下使用TCP</p>
<h4 id="三次握手">三次握手</h4>
<p>三次握手的目的是为了建立安全可靠的连接。</p>
<p>第一次握手：客户端给服务端发送一个报文，报文中SYN位置1</p>
<p>第二次握手：服务端接收到报文后，就知道客户端想建立一个连接，然后服务端给客户端发送一个确认报文，在这个报文中 ACK位置1</p>
<p>两次握手之后，对于客户端而言，已经知道服务端的接收、发送能⼒是正常的，但是服务端并不能确认客户端的接收能力是否正常，所以要进行第三次握手</p>
<p>第三次握手：客户端给服务端发送报文，报文中ACK位置1</p>
<p>通过三次握手之后，服务端和客户端都知道彼此的发送和接收能力都是正常的，那么这个连接就可以被安全的建立了。</p>
<h4 id="四次挥手">四次挥手</h4>
<p>四次挥手也是由客户端首先发起的</p>
<p>第一次挥手：客户端会发送一个报文，在报文中FIN位置1</p>
<p>第二次挥手：当服务端收到这个报文后，会发送报文 ACK=1作为应答，此时服务端知道客户端想和他断开连接，但此时服务端不一定能做好准备，所以此时服务端只能告诉客户端已经收到断开连接的请求</p>
<p>第三次挥手：当服务端做好断开连接的准备时，发送一个报文给客户端，报文中FIN标志位 置1</p>
<p>第四次挥手：当这个报文发给客户端时，客户端同样要给服务端发送一个确认报文，ACK=1</p>
<p>通过这四次挥手就能得出客户端和服务端都做好了断开连接的准备，于是连接可以断开了。</p>
<ul>
<li><p>为什么客户端发送 ACK 之后不直接关闭，⽽而是要等一阵子才关闭（TIME_WAIT）。</p>
<p>这其中的原因就是，要确保服务器是否已经收到了ACK 报文。如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到报⽂之后，就知道之前的报⽂文丢失了，然后再次发送 ACK 报⽂。</p></li>
</ul>
<h4 id="tcp拥塞控制">tcp拥塞控制</h4>
<p>https://blog.csdn.net/qq_43313035/article/details/89069962</p>
<p>拥塞：对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降。</p>
<p>拥塞控制是为了提高网络利用率，降低丢包率。发送方维护一个拥塞窗口。</p>
<p>主要是下面四种机制：</p>
<p><strong>1- 慢开始</strong></p>
<p>慢开始是指在TCP开始发送报文段时先设置拥塞窗口为1。然后指数增加窗口大小</p>
<p><strong>2-拥塞避免</strong></p>
<p>当窗口大小&gt;阈值时，拥塞窗口大小增加改为线型增加。</p>
<p><strong>3- 快速重传</strong></p>
<ol type="1">
<li>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设 置的重传计时器时间到期。</li>
<li>由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量。</li>
</ol>
<p><strong>4- 快速恢复</strong> 连续收到3个对数据包的重复确认，发送端就知道需要马上重传。并且把 ssthresh（慢开始门限）和窗口大小设置为当前窗口的一半，然后开始执行拥塞避免算法。</p>
<h4 id="tcp流量控制">tcp流量控制</h4>
<p>如果发送端发送数据太快，接收端来不及接收，可能会丢失数据。所以流量控制是控制发送端发送速率，要让接收端来得及接收。</p>
<p>具体就是：</p>
<p>接收方每次收到数据包，可以在发送确定报⽂的时候，同时告诉发送方⾃己的缓存区还剩余多少是空闲的，我们也把缓存区的剩余⼤小称之为接收窗口⼤小。</p>
<p>发送方收到之后，便会调整自己的发送速率，也就是调整自己发送窗口的大小，当发送方收到接收窗口的大小为0时，发送方就会停止发送数据，防止出现大量丢包情况的发生。</p>
<p>发送方如果收到零窗口通知，就会启动计时器。若计时器的时间到期，就会发送一个报文：如果接收方可以接收数据就告诉他此时接收窗口的大小，如果接收大小还是为0，发送方就重新设置计时器。</p>
<h3 id="应用层">应用层</h3>
<h4 id="http">http</h4>
<p>[http协议-面试](<a href="https://troywu0.gitbooks.io/interview/content/http协议.html">https://troywu0.gitbooks.io/interview/content/http%E5%8D%8F%E8%AE%AE.html</a></p>
<p>http协议是超文本传输协议，它规定了浏览器怎样向万维网请求文档，以及服务器如何把文档传递给浏览器。从层次的角度来看，http协议是一个应用层协议。</p>
<p>在浏览器和服务器之间的请求和响应，必须按照规定的格式和遵循一定格式，这些格式和规则就是http。</p>
<p>HTTP就是一种无状态协议，它对用户的操作没有记忆功能。为了解决这种情况，引出了<strong>Cookie&amp;Session</strong>机制，让浏览器具备了记忆功能</p>
<p>他的工作流程大概是这样的：每个站点都有一个服务器进程，不断监听tcp的80端口，查看是否有浏览器向它发送连接请求。一旦监听到连接请求并建立了tcp连接之后，浏览器就向服务器发出页面请求，服务器就要返回所请求的页面作为响应。最后tcp连接被释放。</p>
<h4 id="从输入url到页面加载发生了什么"><a href="https://segmentfault.com/a/1190000013522717">从输入URL到页面加载发生了什么</a></h4>
<ol type="1">
<li>浏览器请求dns解析域名的ip地址</li>
<li>浏览器和服务器建立tcp连接</li>
<li>浏览器向服务器发出请求</li>
<li>服务器给出响应，并把相应的文件发送给浏览器</li>
<li>释放tcp连接</li>
<li>浏览器渲染文本</li>
</ol>
<h4 id="http-1.0-1.1">http 1.0 / 1.1</h4>
<p>http1.1相较于1.0有以下新的特性：</p>
<ul>
<li>支持长连接 一个tcp连接上有多个请求，不用重复建立和断开连接，提高带宽利用率</li>
<li>增加host字段</li>
<li>新增了24个状态码 （410表示对象被永久删除）</li>
<li>引入range字段，支持之请求资源的一部分，节省了带宽</li>
<li>缓存控制字段 cache-control 服务端响应时，回传<strong>max-age参数</strong>，那么客户端在下次请求时，根据上次回传的max-age值，首先判断缓存的<strong>相对时间</strong>如果还未超过时间，则不发起请求，直接从Cache中读取。反之，则重新请求。</li>
<li>支持断点传输</li>
</ul>
<h4 id="http-2.0">http 2.0</h4>
<ul>
<li>支持二进制传输</li>
<li>服务器推送：服务器可以额外的向客户端推送资源，而无需客户端明确的请求</li>
<li>多路复用，一个Tcp中多个http请求是并行的</li>
</ul>
<h4 id="https">https</h4>
<p><a href="https://blog.csdn.net/qq_31967569/article/details/84296432">https加密原理</a></p>
<p><strong>发送者-&gt;接收者：</strong></p>
<ol type="1">
<li>message通过hash生成消息摘要</li>
<li>用private key加密摘要生成签名</li>
<li>把message和签名一起发送给接收者</li>
<li>接收者对message进行hash处理得到消息摘要，再用public key把签名解密，两者相等表示验证成功</li>
</ol>
<p><strong>公钥证书：</strong></p>
<ol type="1">
<li>服务端生成密钥对，私钥自己保管，公钥交给CA</li>
<li>CA生成密钥对，用自己的私钥对服务端的公钥进行签名生成数字证书，证书中包含服务端公钥</li>
<li>客户端获取证书</li>
<li>用公钥对证书进行签名认证，成功说明公钥匙服务端的</li>
<li>客户端可以用公钥加密消息发送给服务端</li>
<li>服务端收到密文后用私钥解密</li>
</ol>
<p><a href="https://segmentfault.com/a/1190000019976390">https流程</a></p>
<p><a href="https://www.jianshu.com/p/e30a8c4fa329">流程详细解释</a></p>
<ol type="1">
<li>client请求server获取证书</li>
<li>客户端验证证书合法性</li>
<li>若合法，则生成一个随机值（之后对称加密信息要用到）</li>
<li>用证书中的公钥对这个随机值加密，发送给服务端</li>
<li>服务端用私钥对密文解密，获取随机值</li>
<li>服务端将随机值和信息混合在一起进行对称加密，发送给客户端</li>
<li>客户端解密</li>
</ol>
<h4 id="get-post-区别">get post 区别</h4>
<ul>
<li><p>在浏览器回退时，GET是无害的，POST会再次提交请求。</p></li>
<li><p>GET请求参数会被完整保留在浏览历史记录里，而POST中的参数不会被保留</p></li>
<li><p>GET参数通过URL传递，POST放在Request body中。</p></li>
<li><p>GET 请求在url中传送的参数有长度限制，而POST没有</p></li>
<li><p>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</p></li>
<li><p>GET产生一个TCP数据包；POST产生两个TCP数据包。</p>
<p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p>
<p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p></li>
</ul>
<h4 id="cookie-session区别">cookie session区别</h4>
<ul>
<li>cookie是把用户的数据写在用户本地浏览器上, 其他网站也可以扫描使用你的cookie，容易泄露自己网站用户的隐私，而且一般浏览器对单个网站站点有cookie数量与大小的限制。</li>
<li>Session是把用户的数据写在用户的独占session上，存储在服务器上，一般只将session的id存储在cookie中。但将数据存储在服务器对服务器的成本会高。</li>
<li>session是由服务器创建的，开发人员可以在服务器上通过request对象的getsession方法得到session 一般情况，登录信息等重要信息存储在session中，其他信息存储在cookie中</li>
<li>工作流程： 服务器会为每一个访问服务器的用户创建一个session对象，并且把session对象的id保存在本地cookie上，只要用户再次访问服务器时，带着session的id，服务器就会匹配用户在服务器上的session，根据session中的数据，还原用户上次的浏览状态或提供其他人性化服务。</li>
</ul>
<h4 id="url各部分都是什么">url各部分都是什么</h4>
<p>　protocol :// hostname[:port] / path / [?query]</p>
<h4 id="dns">dns</h4>
<p>dns的作用是把域名和主机名转换成ip地址。</p>
<p>解析流程：</p>
<p>（需要明确的是，每一级域名都有自己的NS记录，NS记录指向该级域名的域名服务器。这些服务器知道下一级域名的各种记录。）</p>
<p>dns解析是分级查询。</p>
<p><a href="https://segmentfault.com/a/1190000013522717">dns查询原理</a></p>
<h2 id="操作系统">操作系统</h2>
<h4 id="进程线程区别">进程线程区别</h4>
<p><strong>（1）联系</strong></p>
<p>线程是进程的一部分，一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。</p>
<p><strong>（2）区别：</strong></p>
<p>根本区别：进程是CPU资源分配的基本单位，线程是独立运行和独立调度的基本单位（CPU上真正运行的是线程）。</p>
<p>地址空间：线程共享本进程的地址空间，而进程之间是独立的地址空间。</p>
<p>资源方面：线程本身不拥有系统资源，只拥有一些在运行过程中必不可少的资源（如程序计数器，寄存器等），所以线程之间切换的开销比较小，而进程之间的切换开销会大一些。</p>
<h4 id="协程">协程</h4>
<p>协程是一种用户态的轻量级线程，<strong>协程的调度完全由用户控制</strong>。协程切换开销比较小。</p>
<p>线程是抢占式的调度，而协程是协同式的调度，协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力（协程不支持并行）。</p>
<h5 id="应用场景">应用场景</h5>
<p><a href="https://www.jianshu.com/p/1f5195dcc75b">什么是CPU密集型、IO密集型</a></p>
<p><strong>1）需要频繁创建销毁的优先用线程</strong></p>
<p><strong>2) 线程和协程推荐在IO密集型的任务(比如网络调用)中使用，而在CPU密集型的任务中，表现较差。</strong></p>
<h4 id="死锁">死锁</h4>
<p><a href="https://www.cnblogs.com/shan1393/p/9046140.html">产生死锁的四个条件和解决办法</a></p>
<h4 id="进程调度算法">进程调度算法</h4>
<p><a href="https://blog.csdn.net/u010889616/article/details/48424501">批处理系统、分时处理系统、实时处理系统简介</a></p>
<h4 id="进程通信">进程通信</h4>
<p>https://zhuanlan.zhihu.com/p/135395279</p>
<p>目的：实现信息交换，实现进程的互斥和同步</p>
<ol type="1">
<li><p>共享内存</p>
<p>在内存中划出一块共享存储区域，各个进程可通过对该共享区的读写来实现通信。</p>
<p><strong>特点</strong>：<br />
​ 1. 不用从用户态到内核态的频繁切换和拷贝数据，直接从内存中读取就可以。 ​ 2. 共享内存是临界资源，所以需要操作时必须要保证原子性。使用信号量或者互斥锁都可以。</p></li>
<li><p>管道通信系统</p>
<p>管道指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件。发送进程以字符流形式将数据送入管道，接收进程从管道中接受数据。</p>
<p><strong>特点</strong>:</p>
<ol type="1">
<li>半双工。一个进程对pipe进行读写时，另一进程需要等待。</li>
<li>数据单向流动。</li>
<li>只能在父子进程或兄弟进程间使用</li>
</ol>
<p>named_pipe 命名管道：可以在无亲缘关系的进程之间进行通讯</p></li>
<li><p>socket</p>
<p><strong>优点</strong>：1）传输数据为字节级，传输数据可自定义，数据量小效率高；2）传输数据时间短，性能高；3) 适合于客户端和服务器端之间信息实时交互；4) 可以加密,数据安全性强</p>
<p><strong>缺点</strong>：1) 需对传输的数据进行解析，转化成应用级的数据。</p></li>
<li><p>消息队列</p>
<p>消息队列是消息的链表。克服了管道只能承载无格式字节流以及缓冲区大小受限等特点。</p>
<p>可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题</p></li>
<li><p>信号量</p>
<p>本质是一个计数器，用pv操作实现进程间的通信和互斥。</p>
<p>​ PV操作用于同一进程，实现互斥。</p>
<p>​ PV操作用于不同进程，实现同步。</p></li>
</ol>
<h2 id="项目">项目</h2>
<ul>
<li><p>golang</p>
<p>http://golang.iswbm.com/en/latest/chapters/p02.html</p></li>
<li><p>jwt</p>
<p>http://blacston.com/2019/07/26/jwt-go/#more</p></li>
<li><p><a href="https://segmentfault.com/a/1190000011450120">cors</a></p></li>
<li><p><a href="https://blog.csdn.net/dc8899/article/details/21336467">mvc架构</a></p></li>
<li><p>orm</p></li>
<li><p><a href="https://www.cnblogs.com/wangyongsong/articles/10004370.html">restful</a></p></li>
</ul>
<h2 id="其他">其他</h2>
<h3 id="排序算法">排序算法</h3>
<p><a href="https://www.cnblogs.com/codingmylife/archive/2012/10/21/2732980.html">稳定性</a></p>
<p><img src="https://img-blog.csdn.net/20180117112126129?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjQyODAxMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" /></p>
<h3 id="docker">docker</h3>
<p>docker将应用程序及其所有依赖项打包在一起。这可以保证无论其环境如何，软件始终运行相同。</p>
<p><a href="https://hit-alibaba.github.io/interview/basic/arch/Concurrency.html">面试总结</a></p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>os</tag>
        <tag>database</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>python 命令行参数</title>
    <url>/2020/12/17/pyton-commandline-arguments/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本分翻译自 https://realpython.com/python-command-line-arguments</p>
<p>python处理命令行参数的功能为一些<strong>基于文本命令行</strong>的程序提供了一个用户友好的界面。这类似于图形用户界面（一个由图形元素或部件操作的可视化应用程序）。</p>
<p>python提供了可以获取、提取命令行参数的机制。这些参数可以用来更改程序的行为。举个例子，假如你的程序要处理一个文件中的数据，那么你可以把文件路径传给程序，而不是在源代码中写死。</p>
<p><strong>通过此教程，你将会了解：</strong></p>
<ul>
<li>python命令行参数的起源</li>
<li>python命令行参数的底层支持</li>
<li>设计命令行界面的指导标准</li>
<li>手动定制以及处理命令行参数的简单方法</li>
<li>使用python中的库简化复杂命令行界面的开发</li>
</ul>
<p>如果你想在不使用专用库的情况下开发一个用户友好的命令行界面，或者是想更好的理解现有的python命令行参数库的一些共识，那么请继续阅读！</p>
<h2 id="命令行界面-the-command-line-interface">命令行界面 The Command Line Interface</h2>
<p><strong>命令行界面(CLI)</strong> 为用户提供了一种方式，使用户可以和运行在<strong>基于文本的shell解释器</strong>中的程序进行交互。</p>
<p>shell解释器有Linux上的bash，windows上的命令提示行等。命令行界面由能显示命令提示符的shell解释器支持。它一般有以下几个要素：</p>
<ul>
<li>一个命令或一段程序</li>
<li>0或多个命令行参数</li>
<li>一个输出，代表命令结果</li>
<li>使用或帮助的参考文档</li>
</ul>
<p>不是每个命令行界面都提供以上要素，这些也不是命令行界面的全部特点。命令行的复杂性表现在从传递单个参数到多个参数和选项，很像领域专用语言(Domain Specific Language)。举个例子，一些程序可能会从命令行启动web版的文档，或者像python那样打开一个交互解释器。</p>
<p>下面两个python命令的例子展示出了命令行界面的样子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python -c <span class="string">&quot;print(Real Python)&quot;</span></span></span><br><span class="line">Real Python</span><br></pre></td></tr></table></figure>
<p>在这个例子里，python解释器接收<code>-c</code>参数，它表示将在选项<code>-c</code>之后的参数作为Python程序执行。</p>
<p>下面这个例子展示了使用<code>-h</code>调用python来显示<code>help</code>信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python -h</span></span><br><span class="line">usage: python3 [option] ... [-c cmd | -m mod | file | -] [arg] ...</span><br><span class="line">Options and arguments (and corresponding environment variables):</span><br><span class="line">-b     : issue warnings about str(bytes_instance), str(bytearray_instance)</span><br><span class="line">         and comparing bytes/bytearray with str. (-bb: issue errors)</span><br><span class="line">[ ... complete help text not shown ... ]</span><br></pre></td></tr></table></figure>
<h2 id="c语言历史遗留">C语言历史遗留</h2>
<p>Python命令行参数是从c语言继承而来的。在<a href="https://en.wikipedia.org/wiki/Guido_van_Rossum">Guido Van Rossum</a> 于1993年写的<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.4180">写给Unix/C程序员的Python介绍</a>中提到了，C对Python是有很大的影响的。Guido提及了字面量的定义，标识符，操作符以及像<code>break</code>, <code>continue</code>,<code>return</code>之类的语句。Python命令行参数也很大程度上受到了C语言的影响。</p>
<p>为了说明两个语言之间的相似性，情况下面的C语言程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Arguments count: %d\n&quot;</span>, argc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Argument %6d: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四行定义了<code>main()</code>, c程序的入口函数。下面的参数要记好笔记：</p>
<ol type="1">
<li><p><strong>argc</strong> 是代表参数个数的一个整数</p></li>
<li><p><strong>argv</strong> 是是一个字符指针的数组，包含程序名(第一个参数)，后面是其他参数(如果有的话)</p></li>
</ol>
<p>你可以在linux环境下使用<code>gcc -o main main.c</code>上面的代码，然后用<code>./main</code>执行得到下面的结果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -o main main.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./main</span></span><br><span class="line">Arguments count: 1</span><br><span class="line">Argument      0: ./main</span><br></pre></td></tr></table></figure>
<p>如果没有用<code>-o</code>选项指明，gcc编译器将默认使用<code>a.out</code>作为输出可执行文件名。它代表<strong>汇编输出(assembler output)</strong>, 让人想起在旧的UNIX系统上生成的可执行文件。而且观察到，可执行文件的名称./main是唯一的参数。 让我们使用同一个程序，并传递几个Python命令行参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./main Python Command Line Arguments</span></span><br><span class="line">Arguments count: 5</span><br><span class="line">Argument      0: ./main</span><br><span class="line">Argument      1: Python</span><br><span class="line">Argument      2: Command</span><br><span class="line">Argument      3: Line</span><br><span class="line">Argument      4: Arguments</span><br></pre></td></tr></table></figure>
<p>输出结果显示参数的个数是5，参数列表包括程序名main，后面是在命令行传递的“Python Command Line Arguments”的每个单词。</p>
<blockquote>
<p><strong>注意</strong>: <code>argc</code> 代表 <strong>argument count</strong>, 而 <code>argv</code> 代表 <strong>argument vector</strong>. 想知道更多内容, 可以查看 <a href="https://en.wikibooks.org/wiki/A_Little_C_Primer/C_Command_Line_Arguments">A Little C Primer/C Command Line Arguments</a>.</p>
</blockquote>
<p>上述编译<code>main.c</code>文件假定你是用的是Linux或Mac OS系统。在Windows上你也可以用以下几个方法来编译C程序。</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux"><strong>Windows Subsystem for Linux (WSL):</strong></a> It’s available in a few Linux distributions, like <a href="https://ubuntu.com/">Ubuntu</a>, <a href="https://www.opensuse.org/">OpenSUSE</a>, and <a href="https://www.debian.org/">Debian</a>, among others. You can install it from the Microsoft Store.</li>
<li><a href="https://visualstudio.microsoft.com/downloads/#build-tools-for-visual-studio-2019"><strong>Windows Build Tools:</strong></a> This includes the Windows command line build tools, the Microsoft C/C++ compiler <a href="https://docs.microsoft.com/en-us/cpp/build/walkthrough-compiling-a-cpp-cli-program-on-the-command-line?view=vs-2019"><code>cl.exe</code></a>, and a compiler front end named <a href="https://en.wikipedia.org/wiki/Clang"><code>clang.exe</code></a> for C/C++.</li>
<li><a href="https://visualstudio.microsoft.com/downloads/"><strong>Microsoft Visual Studio:</strong></a> This is the main Microsoft integrated development environment (IDE). To learn more about IDEs that can be used for both Python and C on various operating systems, including Windows, check out <a href="https://realpython.com/python-ides-code-editors-guide/">Python IDEs and Code Editors (Guide)</a>.</li>
<li><a href="http://mingw-w64.org/"><strong>mingw-64 project:</strong></a> This supports the <a href="https://gcc.gnu.org/">GCC compiler</a> on Windows.</li>
</ul>
<p>如果你已经安装了Microsoft Visual Studio或者Windows Build Tools，那么你可以用下面的方法编译main.c:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:/&gt;cl main.c</span><br></pre></td></tr></table></figure>
<p>你将会获得一个名为<code>main.exe</code>的可执行文件，可以用下面命令执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:&#x2F;&gt;main</span><br><span class="line">Arguments count: 1</span><br><span class="line">Argument      0: main</span><br></pre></td></tr></table></figure>
<p>你可以实现一个Python程序，main.py，这和上面的C程序main.c是一样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    print(<span class="string">f&quot;Arguments count: <span class="subst">&#123;<span class="built_in">len</span>(sys.argv)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i, arg <span class="keyword">in</span> <span class="built_in">enumerate</span>(sys.argv):</span><br><span class="line">        print(<span class="string">f&quot;Argument <span class="subst">&#123;i:&gt;<span class="number">6</span>&#125;</span>: <span class="subst">&#123;arg&#125;</span>&quot;</span>)  </span><br></pre></td></tr></table></figure>
<p>在代码中并没有看到像C语言中argc的变量，他在Python中并不存在，因为<code>sys.argv</code>已经够用了。你可以不用知道参数列表长度，来解析<code>sys.argv</code>的命令行参数，如果你的程序需要知道参数长度的话，也可以调用内置<code>len()</code>函数。</p>
<p>请注意<code>enumerate()</code>，当应用于一个可迭代对象时，他返回一个可枚举对象(enumerate object)，该对象可以同时返回sys.argv元素的索引和它对应的值。这让我们可以遍历sys.argv，而不用维护一个计数变量。</p>
<p>main.py运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python main.py Python Command Line Arguments</span></span><br><span class="line">Arguments count: 5</span><br><span class="line">Argument      0: main.py</span><br><span class="line">Argument      1: Python</span><br><span class="line">Argument      2: Command</span><br><span class="line">Argument      3: Line</span><br><span class="line">Argument      4: Arguments</span><br></pre></td></tr></table></figure>
<p>sys.argv包含了和C语言中argv相同的信息:</p>
<ul>
<li><strong>程序名称</strong><code>main.py</code>是参数列表第一个参数</li>
<li><code>Python</code>, <code>Command</code>, <code>Line</code>, and <code>Arguments</code>是剩下的参数</li>
<li>译者注：代码中:&gt;6是让变量i代表的字符串占据6个字符宽度并且右对齐，类似于C语言中的"%6d"</li>
</ul>
<p>通过对C语言比较难懂部分的一些简短的介绍，你现在可以去学习更多关于Python命令行参数的内容了。</p>
<h2 id="两个unix实用工具">两个Unix实用工具</h2>
<p>为了在本教程中使用Python命令行参数，你将实现Unix生态系统中两个实用程序的部分功能。</p>
<ol type="1">
<li><a href="https://en.wikipedia.org/wiki/Sha1sum">sha1sum</a></li>
<li><a href="https://en.wikipedia.org/wiki/Seq_(Unix)">seq</a></li>
</ol>
<p>在下面几个部分中，你将会熟悉这些unix工具。</p>
<h3 id="sha1sum">sha1sum</h3>
<p>sha1sum 计算SHA-1哈希值，它通常用来验证文件的完整性。给定一个输入，哈希函数返回相同的值。任何对输入的改变都将会导致输出不同的哈希值。在使用带有具体参数的实用工具之前，你可以先打印一下help信息。</p>
<blockquote>
<p>译者注：<strong>SHA-1</strong>（英语：Secure Hash Algorithm 1，中文名：安全散列算法1）是一种<a href="https://baike.baidu.com/item/密码散列函数">密码散列函数</a>。SHA-1可以生成一个被称为消息摘要的160位散列值，通常为40个十六进制数。（1个十六进制数是4位二进制数）</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sha1sum --<span class="built_in">help</span></span></span><br><span class="line">Usage: sha1sum [OPTION]... [FILE]...</span><br><span class="line">Print or check SHA1 (160-bit) checksums.</span><br><span class="line"></span><br><span class="line">With no FILE, or when FILE is -, read standard input.</span><br><span class="line"></span><br><span class="line">  -b, --binary         read in binary mode</span><br><span class="line">  -c, --check          read SHA1 sums from the FILEs and check them</span><br><span class="line">      --tag            create a BSD-style checksum</span><br><span class="line">  -t, --text           read in text mode (default)</span><br><span class="line">  -z, --zero           end each output line with NUL, not newline,</span><br><span class="line">                       and disable file name escaping</span><br><span class="line">[ ... complete help text not shown ... ]</span><br></pre></td></tr></table></figure>
<p>显示命令行程序的帮助信息是命令行界面提供的常用功能。</p>
<p>要计算一个文件内容的SHA-1 hash值，可以按如下操作进行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sha1sum main.c</span></span><br><span class="line">125a0f900ff6f164752600550879cbfabb098bc3  main.c</span><br></pre></td></tr></table></figure>
<p>返回的结果第一部分显示的是SHA-1哈希值，第二部分是文件名。而且此命令可以接受多个文件名作为参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sha1sum main.c main.py</span></span><br><span class="line">125a0f900ff6f164752600550879cbfabb098bc3  main.c</span><br><span class="line">d84372fc77a90336b6bb7c5e959bcb1b24c608b4  main.py</span><br></pre></td></tr></table></figure>
<p>由于Unix终端的通配符扩展特性，也可以提供带有通配符字符的命令行参数。这其中一个字符是asterisk，或者可以称作星号(*)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sha1sum main.*</span></span><br><span class="line">3f6d5274d6317d580e2ffc1bf52beee0d94bf078  main.c</span><br><span class="line">f41259ea5835446536d2e71e566075c1c1bfc111  main.py</span><br></pre></td></tr></table></figure>
<p>shell把main.*转换成main.c和main.py并且把他们传入sha1sum，因为当前文件夹下的这两个文件，都和main.*所匹配。该程序会计算参数列表的每个文件的SHA1值。在Windows上你会发现他的行为有所不同。Windows没有通配符扩展，所以程序可能必须得适应这一点。你可能需要在内部扩展通配符。</p>
<p>在没有参数的情况下，sha1sum从标准输入中读取。你可以通过在键盘上输入字符来传入数据。输入的字符流包括任何字符，包括回车键。要终止输入，必须用Enter发出文件结束的信号，然后输入Ctrl+D。</p>
<p>结果是为文本<code>Real\nPython\n</code>生成的SHA1哈希值。文件的名称是-。这是一个表示标准输入的惯例。当你执行以下命令时，会得到相同的哈希值。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python -c <span class="string">&quot;print(&#x27;Real\nPython\n&#x27;, end=&#x27;&#x27;)&quot;</span> | sha1sum</span></span><br><span class="line">87263a73c98af453d68ee4aab61576b331f8d9d6  -</span><br><span class="line"><span class="meta">$</span><span class="bash"> python -c <span class="string">&quot;print(&#x27;Real\nPython&#x27;)&quot;</span> | sha1sum</span></span><br><span class="line">87263a73c98af453d68ee4aab61576b331f8d9d6  -</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">printf</span> <span class="string">&quot;Real\nPython\n&quot;</span> | sha1sum</span></span><br><span class="line">87263a73c98af453d68ee4aab61576b331f8d9d6  -</span><br></pre></td></tr></table></figure>
<p>接下来，你将会阅读的是对<strong>seq</strong>的简单介绍 。</p>
<h3 id="seq">seq</h3>
<p><a href="https://en.wikipedia.org/wiki/Seq_%28Unix%29">seq</a>可以生成数字<strong>序列</strong>。在最基本的形式中，比如生成1-5的序列，你可以依照如下指令执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> seq 5</span></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>为了seq提供的所有功能，你可以在命令行打印出帮助信息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ seq --<span class="built_in">help</span></span><br><span class="line">Usage: seq [OPTION]... LAST</span><br><span class="line">  or:  seq [OPTION]... FIRST LAST</span><br><span class="line">  or:  seq [OPTION]... FIRST INCREMENT LAST</span><br><span class="line">Print numbers from FIRST to LAST, <span class="keyword">in</span> steps of INCREMENT.</span><br><span class="line"></span><br><span class="line">Mandatory arguments to long options are mandatory <span class="keyword">for</span> short options too.</span><br><span class="line">  -f, --format=FORMAT      use <span class="built_in">printf</span> style floating-point FORMAT</span><br><span class="line">  -s, --separator=STRING   use STRING to separate numbers (default: \n)</span><br><span class="line">  -w, --equal-width        equalize width by padding with leading zeroes</span><br><span class="line">      --<span class="built_in">help</span>     display this <span class="built_in">help</span> and <span class="built_in">exit</span></span><br><span class="line">      --version  output version information and <span class="built_in">exit</span></span><br><span class="line">[ ... complete <span class="built_in">help</span> text not shown ... ]</span><br></pre></td></tr></table></figure>
<p>在此教程中，你将会编写一些sha1sum和seq的简单变体。在每个例子中，你将会了解到Python命令行参数不同的特点和功能。</p>
<p>在Mac OS和Linux上，sha1sum和seq需要预先安装，尽管不同的系统或发布版本的特性和帮助信息可能会有所不同。如果你正在使用Windows 10，那么运行sha1sum和seq的最简单的方法则是在<a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">WSL</a>中安装Linux环境。如果你无法访问提供标准Unix实用程序的终端，你或许可以使用一些在线终端：</p>
<ul>
<li>在<a href="https://www.pythonanywhere.com/">PythonAnywhere</a>上创建一个免费账户，然后启动一个Bash控制台。</li>
<li>在<a href="https://repl.it/languages">repl.it</a>上创建一个临时Bash。</li>
</ul>
<p>以上只是两个例子，你也可以找到其他的替代品。</p>
<h2 id="sys.argv.arrary">sys.argv.Arrary</h2>
<p>在探索一些公认的约定和了解如何处理Python命令行参数之前，你需要知道对所有Python命令行参数的底层支持是由<a href="https://docs.python.org/library/sys.html?highlight=sys%20argv#sys.argv"><code>sys.argv</code></a>所提供的。 以下各节中的示例将向你展示如何处理存储在sys.argv中的Python命令行参数以及处理当访问它时所遇到的典型的错误。在这章你将会了解：</p>
<ul>
<li>如何<strong>访问</strong>sys.argv的内容</li>
<li>如何<strong>消除</strong>sys.argv的全局特性所带来的副作用</li>
<li>如何在Pythobn命令行参数中<strong>处理</strong>空格</li>
<li>如何在访问Python命令行参数时<strong>处理</strong>错误</li>
<li>如何<strong>接收</strong>以字节形式传递的Python命令行参数的原始格式</li>
</ul>
<p>让我们开始吧！</p>
<h3 id="显示参数">显示参数</h3>
<p>sys模块提供了一个列表叫做argv，它包括：</p>
<ol type="1">
<li>argv[0] 包含当前Python程序的名称</li>
<li>argv[1:]，列表剩余部分，包含所有传给这个程序的Python命令行参数</li>
</ol>
<p>下面这个例子展示了sys.argv的内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># argv.py</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">print(<span class="string">f&quot;Name of the script      : <span class="subst">&#123;sys.argv[<span class="number">0</span>]=&#125;</span>&quot;</span>)</span><br><span class="line">print(<span class="string">f&quot;Arguments of the script : <span class="subst">&#123;sys.argv[<span class="number">1</span>:]=&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>下面是代码解释：</p>
<ul>
<li>第2行倒入了Python的内部模块sys。</li>
<li>第4行通过访问sys.argv的第一个元素提取了程序名称。</li>
<li>第5行通过获取sys.argv的剩余元素，显示了Python命令行参数。</li>
</ul>
<blockquote>
<p><strong>注意：</strong>在上面argv.py中使用的<a href="https://realpython.com/python-f-strings/">f-string</a>语法使用了Python 3.8中的新调试说明符。 要了解有关此f字符串新功能和其他功能的更多信息，请查看Python 3.8中的新功能。</p>
<p>如果你的Python版本低于3.8，那么只需要移除两个f-string中的=使程序得以运行。输出结果回展示变量名而不是它们的名字。</p>
</blockquote>
<p>使用任意参数列表执行上面的脚本argv.py：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python argv.py un deux trois quatre</span></span><br><span class="line">Name of the script      : sys.argv[0]=&#x27;argv.py&#x27;</span><br><span class="line">Arguments of the script : sys.argv[1:]=[&#x27;un&#x27;, &#x27;deux&#x27;, &#x27;trois&#x27;, &#x27;quatre&#x27;]</span><br></pre></td></tr></table></figure>
<h3 id="反转首个参数">反转首个参数</h3>
<p>现在你对sys.argv有了足够的了解，接下来你将会对命令行传递的参数进行操作。示例程序example.py把在命令行传递的第一个参数逆转了过来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># reverse.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">arg = sys.argv[<span class="number">1</span>]</span><br><span class="line">print(arg[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>在reverse.py中程序通过以下几个步骤反转第一个参数：</p>
<ul>
<li>第5行获取程序存储在<code>sys.argv</code>中的index为1的参数。记住程序名存储在sys.argv的index 0的位置。</li>
<li>第6行打印了反转字符串。 args[::-1]是python中使用分片操作来反转列表的方法。</li>
</ul>
<p>按照下面运行脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python reverse.py <span class="string">&quot;Real Python&quot;</span></span></span><br><span class="line">nohtyP laeR</span><br></pre></td></tr></table></figure>
<p>如预期的那样，<code>reverse.py</code>对"Real Python"进行处理，并且反转了唯一参数并输出"nohtyP laeR"。注意多个单词"Real Python"周围的引号确保解释器将其处理为唯一参数而不是两个。你将在后面的部分中深入探讨参数分隔符。</p>
<h3 id="转换-sys.argv">转换 sys.argv</h3>
<p>sys.argv对正在运行的Python程序全局可用。 在执行过程中导入的所有模块都可以直接访问sys.argv。 这种全局访问可能很方便，但是sys.argv并非一成不变。 您可能想要实现一种更可靠的机制，以<em>将程序参数提供给Python程序中的不同模块</em>，尤其是在具有多文件的复杂程序中。</p>
<p>观察如果你随意使用<code>sys.argv</code>会发生什么：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># argv_pop.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">print(sys.argv)</span><br><span class="line">sys.argv.pop()</span><br><span class="line">print(sys.argv)</span><br></pre></td></tr></table></figure>
<p>调用<a href="https://docs.python.org/tutorial/datastructures.html#more-on-lists"><code>.pop()</code></a>方法移除<code>sys.argv</code>中最后一个元素。</p>
<p>执行上面的脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python argv_pop.py un deux trois quatre</span></span><br><span class="line">[&#x27;argv_pop.py&#x27;, &#x27;un&#x27;, &#x27;deux&#x27;, &#x27;trois&#x27;, &#x27;quatre&#x27;]</span><br><span class="line">[&#x27;argv_pop.py&#x27;, &#x27;un&#x27;, &#x27;deux&#x27;, &#x27;trois&#x27;]</span><br></pre></td></tr></table></figure>
<p>注意，第四个参数从sys.argv中被移除。</p>
<p>在上述简短的脚本中，您可以安全地依靠对sys.argv的全局访问，但是在较大规模的程序中，您可能希望将参数存储在单独的变量中。 前面的示例可以进行如下修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># argv_var_pop.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">print(sys.argv)</span><br><span class="line">args = sys.argv[<span class="number">1</span>:]</span><br><span class="line">print(args)</span><br><span class="line">sys.argv.pop()</span><br><span class="line">print(sys.argv)</span><br><span class="line">print(args)</span><br></pre></td></tr></table></figure>
<p>这次尽管<code>sys.argv</code>移除了最后一个元素，但<code>args</code>仍然保持不变。<code>args</code>不是全局的，你可以将其传递给程序，以根据程序的逻辑来解析参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">args=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> args <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        args = sys.argv[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure>
<p>在此摘录自<a href="https://realpython.com/what-is-pip/"><code>pip</code></a> 源码中，main()将sys.argv切片保存到args中，该片仅包含参数而不包含文件名。 sys.argv保持不变，并且对sys.argv的任何更改都不会影响arg。</p>
<h3 id="转义空格字符">转义空格字符</h3>
<h3 id="错误处理">错误处理</h3>
<h3 id="计算sha1sum">计算sha1sum</h3>
<h5 id="剖析python命令行参数">剖析python命令行参数</h5>
<h3 id="标准">标准</h3>
<h3 id="选项-option">选项 option</h3>
<h3 id="参数-arguments">参数 arguments</h3>
<h3 id="子命令-subcommand">子命令 subcommand</h3>
<h3 id="窗口">窗口</h3>
<h3 id="视觉">视觉</h3>
<h2 id="一些解析python命令行参数的方法">一些解析python命令行参数的方法</h2>
<h3 id="正则表达式">正则表达式</h3>
<h3 id="文件处理">文件处理</h3>
<h3 id="标准输入">标准输入</h3>
<h3 id="标准输出和标准错误">标准输出和标准错误</h3>
<h3 id="自定义解析器">自定义解析器</h3>
<h2 id="一些验证python命令行参数的方法">一些验证python命令行参数的方法</h2>
<h3 id="使用python-data-classes进行类型验证">使用python data classes进行类型验证</h3>
<h3 id="自定义验证">自定义验证</h3>
<h2 id="python标准库">python标准库</h2>
<h3 id="argparse">argparse</h3>
<h3 id="getopt">getopt</h3>
<h2 id="第三方库">第三方库</h2>
<h3 id="click">Click</h3>
<h3 id="python-prompt-toolkit">Python Prompt Toolkit</h3>
<h2 id="总结">总结</h2>
<h2 id="其他资源">其他资源</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python2</tag>
        <tag>命令行</tag>
        <tag>参数</tag>
        <tag>commandline</tag>
        <tag>arguments</tag>
      </tags>
  </entry>
  <entry>
    <title>408常见题</title>
    <url>/2021/09/07/408-problems/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="组成原理">组成原理</h2>
<h3 id="jmp和call跳转指令的偏移量">jmp和call跳转指令的偏移量</h3>
<p>jmp和call的偏移量为 相对于<strong>跳转指令的下一条指令</strong>的偏移，用补码表示。</p>
<p>2019真题 45 3）</p>
<h3 id="多道程序多任务">多道程序、多任务</h3>
<p>多道程序设计是并行处理的一种基本形式，意味着多个进程同时在一个处理器上运行。在现代操作系统中，当多个程序或进程在单个处理器上运行时，操作系统的工作就是有效地管理所有进程。</p>
<p>多道程序特点：</p>
<ul>
<li>CPU利用率高</li>
<li>系统吞吐量达</li>
<li>IO设备利用率高：多个程序使用IO设备，IO设备一直工作</li>
</ul>
<p>多任务是指操作系统使用多个CPU一次执行多个任务的能力。它基本上在一个系统中使用两个或多个CPU来分配共享公共资源（包括CPU和内存）的任务。</p>
<p>多任务特点：</p>
<ul>
<li>并行：CPU和I/O设备并行</li>
<li>并发：同一时间间隔内执行多个任务</li>
<li>对共享资源进行保护</li>
<li>单个CPU也可满足（2018 23）</li>
</ul>
<h3 id="多长时间响应一次才能不丢失数据">多长时间响应一次才能不丢失数据</h3>
<p>对于定时查询，查询时间必须小于传输（准备）数据时间</p>
<p>对于中断查询，中断响应时间小于传输（准备）数据时间</p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/1202.png" /></p>
<p>1）设备A每次传输数据时间=<span class="math inline">\(\frac{32bit}{2MB/s} = 2us\)</span>，必须每2us查询一次，</p>
<p>因为传输速率为2MB/S，所以每秒查询<span class="math inline">\(\frac{2MB}{4B}=0.5M\)</span>次，每次10条指令，IO时间占CPU总时间=<span class="math inline">\(\frac{0.5M \times 10 \times 4}{500M}= 4\%\)</span></p>
<p>2） 设备B传输数据时间=<span class="math inline">\(\frac{32bit}{40MB/s} = 0.1us\)</span> 中断处理时间=<span class="math inline">\(400 / 500MHz = 0.8us\)</span> 因为中断处理时间大于数据传输时间，<strong>数据会被刷新，造成丢失</strong></p>
<p>3）DMA方式使用CPU的时间只有预处理和后处理，每次传1000B，一秒传<span class="math inline">\(\frac{40MB}{1000B}=40000\)</span>次，百分比=<span class="math inline">\(\frac{40000 \times 500}{500M}=4\%\)</span></p>
<blockquote>
<p>IO时间占CPU占用百分比计算方法必须掌握，真题2019 21</p>
</blockquote>
<h3 id="io接口">I/O接口</h3>
<p>数据流动方向：CPU从主存取数据，放入通用寄存器，再传送给I/O端口</p>
<p>2017考题：IO指令实现的数据传送通常发生在（通用寄存器和IO端口之间）</p>
<h3 id="寄存器位数取决于">寄存器位数取决于</h3>
<p>PC位数取决于内存容量和指令字长</p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/Screen%20Shot%202021-11-09%20at%2016.34.50.png" /></p>
<p>内存为4GB=<span class="math inline">\(2^{32B}\)</span> 指令字长为32bit = <span class="math inline">\(2^2B\)</span> 所以PC位数为30</p>
<p>解释：PC的每个值对应一个指令，所以PC位数取决于内存中能保存的指令条数</p>
<h3 id="编译过程">编译过程</h3>
<ul>
<li>高级语言程序 （编译） 目标文件（链接）机器代码</li>
<li>汇编程序（汇编）目标文件</li>
<li>解释程序不生成目标代码，每一行指令直接解释执行</li>
<li>汇编与编译的区别在于源文件不同</li>
</ul>
<h3 id="中断流程">中断流程</h3>
<h4 id="多级中断">多级中断</h4>
<ol type="1">
<li>关中断</li>
<li>保存断点</li>
<li>中断服务寻址程序</li>
<li>保护现场（PSW，PC）和屏蔽字</li>
<li>开中断（允许多级中断）</li>
<li>执行中断服务程序</li>
<li>关中断</li>
<li>恢复现场和屏蔽字</li>
<li>开中断</li>
<li>中断返回</li>
</ol>
<h4 id="单重中断">单重中断</h4>
<ol type="1">
<li>关中断</li>
<li>保存断点</li>
<li>中断服务程序寻址</li>
<li>保护现场</li>
<li>中断服务程序</li>
<li>恢复现场</li>
<li>开中断</li>
<li>中断返回</li>
</ol>
<blockquote>
<p>总结：前三步是由硬件完成的（中断隐指令），因为单重中断不允许在中断程序时再相应，所以在执行结束之前一直处于关中断状态</p>
</blockquote>
<h4 id="其他总结">其他总结</h4>
<ul>
<li>中断向量是中断服务程序的<strong>地址</strong>，由硬件产生，速度快</li>
<li>中断服务程序一般是由操作系统提供</li>
<li>中断和trap区别：trap是有意识安排的，目的是为了实现用户态和核心态的转换</li>
<li>中断传输数据以字节为单位，</li>
<li>中断优先级：
<ul>
<li>DMA优先级比外中断高，（避免数据丢失）</li>
</ul></li>
</ul>
<h3 id="dma过程">DMA过程</h3>
<p>DMA分为预处理、数据传送、后处理3个阶段</p>
<p>预处理：由CPU完成必要的准备工作，数据传送前由<strong>DMA控制器请求总线使用权</strong></p>
<p>数据传送：由<strong>DMA控制器直接控制总线完成</strong></p>
<p>后处理：DMA控制器<strong>向CPU发送中断请求</strong></p>
<h3 id="数据类型转换">数据类型转换</h3>
<p>有符号数和无符号数转换：</p>
<ul>
<li>只改变解释方式</li>
</ul>
<p>不同字长转换：</p>
<ul>
<li>大转小，<strong>高位</strong>截断，保留低位</li>
<li>小转大：补0或1，数值不变</li>
</ul>
<p>整数、小数的转换：</p>
<ul>
<li>精度从小到大为：int、float、double</li>
<li>精度小转精度大：数值不变</li>
<li>精度大转精度小：舍入，有损失，如float 3.14转int变为3</li>
</ul>
<h3 id="性能计算">性能计算</h3>
<ul>
<li>主频</li>
<li>CPI</li>
<li>总线带宽=总线工作频率x总线宽度/8</li>
<li>处理速率<span class="math inline">\(MIPS=\frac{主频}{CPI}\)</span></li>
<li>平均访问时间=命中率x访问cache时间+（1-命中率）x访问内存时间</li>
<li>cache-主存效率=<span class="math inline">\(\frac{cache存取周期}{平均访问时间}\)</span></li>
</ul>
<h3 id="对程序员透明的部件">对程序员透明的部件</h3>
<p><strong>透明：</strong></p>
<ul>
<li>ALU（加法器、乘法器、移位器）</li>
<li>IR指令寄存器（CPU自动取指，程序员只能通过PC来改变指令）</li>
<li>MAR</li>
<li>MDR</li>
</ul>
<p><strong>不透明：</strong>（可以操控、编程的）</p>
<ul>
<li>PC（跳转指令）</li>
<li>通用寄存器</li>
<li>程序状态字寄存器</li>
<li>ACC 累加寄存器</li>
</ul>
<h3 id="流水线时间计算">流水线时间计算</h3>
<p>m端流水线，n个指令，时钟周期为t，总时间为 <span class="math inline">\(m+(n-1)t\)</span></p>
<p>经常于低位交叉存储结合起来考。2012真题，P310 .6</p>
<p>2013真题，第三问</p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/Screen%20Shot%202021-11-05%20at%2010.25.56.png" /></p>
<p>一次突发传送总线事务时间=送首地址和命令时间（一个总线时钟周期）+存储器准备数据时间+传送数据时间</p>
<p>存储器准备数据时间即为8体交叉存储器传送32B数据时间，因为一个体字长32b，<strong>8个体把存储周期分为8份</strong>，每份40/8=5ns，8个体需要传<span class="math inline">\([8+(8-1)]*5 = 75ns\)</span></p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/Screen%20Shot%202021-11-05%20at%2010.36.39.png" /></p>
<p>每准备好32b就把它传送出去，传送时间为1个时钟周期 =5ns，第二个准备好时，第一个刚好传送完，以此类推，最后第8个传送完后再花5ns</p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/Screen%20Shot%202021-11-05%20at%2010.38.06.png" /></p>
<p>所以总时间= 5+75+5</p>
<h3 id="cpu执行时间">CPU执行时间</h3>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/Screen%20Shot%202021-11-05%20at%2010.25.56.png" /></p>
<p>第四问，2种思路：</p>
<ol type="1">
<li><p>计算平均每条指令的CPI，再乘指令条数</p>
<p><span class="math inline">\(一条指令执行过程中因cache缺失导致平均额外开销=平均访存次数xcache缺失率x一次突发传送总线事务时间\)</span></p></li>
<li><p>计算所有指令命中时花费时间+不命中时花费时间</p></li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/Screen%20Shot%202021-11-05%20at%2010.51.07.png" /></p>
<h3 id="单双缓冲区时间">单/双缓冲区时间</h3>
<p>原则：</p>
<ol type="1">
<li>C和M不能同时发生，且<strong>C结束紧跟着M</strong>：CPU处理完才能接收</li>
<li>单缓冲下T和M不能同时发生：因为T和M都用到了同一个缓冲</li>
<li>由1、2可知，单缓冲下只能T和C同时发生</li>
</ol>
<p><strong>画图分析时假设一个初始状态，计算下次达到这种状态的时间</strong></p>
<p>对于单缓冲来说，初始是缓冲区满</p>
<p>对于双缓冲来说，初始是一个空一个满</p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/%E5%A4%87%E6%B3%A8.jpg" /></p>
<p><strong>注意：</strong>若题中要计算从读入到分析数据的总时间，要从缓冲区为空开始算起，计算公式为：第一个数据时间+（n-1）x上面计算的花费时间</p>
<h3 id="lru">LRU</h3>
<p><strong>方法</strong>：每次替换时往前数，找到cache中，离当前位置最远的替换。做题时画下面的表，命中时在下面打勾，标记。</p>
<p>eg: cache大小为4，访问序列是1 8 1 7 8 2 7 2 1 8 3 8 2 1 3 1 7 1 3 7</p>
<p>注意下面第一次遇到3时需要替换，往前看分别出现 8, 1, 2 因此选择替换7</p>
<table>
<thead>
<tr class="header">
<th>1</th>
<th>8</th>
<th>1</th>
<th>7</th>
<th>8</th>
<th>2</th>
<th>7</th>
<th>2</th>
<th>1</th>
<th>8</th>
<th>3</th>
<th>8</th>
<th>2</th>
<th>1</th>
<th>3</th>
<th>1</th>
<th>7</th>
<th>1</th>
<th>3</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td>8</td>
<td>8</td>
<td>8</td>
<td></td>
<td>8</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>8</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>7</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td>7</td>
<td></td>
<td>7</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>3</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td>✅</td>
<td></td>
<td>✅</td>
<td></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>最后发现✅有14个，总次数为20，因此命中率为70%。</p>
<h2 id="操作系统">操作系统</h2>
<h3 id="虚拟地址和物理地址低xx位相同">虚拟地址和物理地址低xx位相同</h3>
<p>若页大小为4KB=<span class="math inline">\(2^{12}B\)</span>，则物理地址和虚拟地址低12位相同，根据这一点知道虚拟地址可以判断cache组号</p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/Screen%20Shot%202021-11-15%20at%2019.14.30.png" /></p>
<p>答：call指令虚拟地址为00401025，因为页大小为4KB，所以物理地址和虚拟地址低12位相同，所以7-10位代表组号，所以在第0组</p>
<p>2018年44题也考了这个知识点</p>
<h3 id="磁盘物理地址">磁盘物理地址</h3>
<p>结构：柱面号，盘面/磁头号，扇区号</p>
<blockquote>
<p>柱面就是磁道</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/Screen%20Shot%202021-11-15%20at%2019.00.32.png" /></p>
<p>3）每个柱面10x200/2=1000个簇</p>
<p>每个磁道200/2=100个簇</p>
<p>所以柱面号=100 530/1000 = 100</p>
<p>磁道号=100530%1000/100=5</p>
<p>扇区号=100530%100x2=60</p>
<h3 id="动态分区">动态分区</h3>
<p>首次适应：地址递增。产生碎片</p>
<p>最佳适应：容量递增。<strong>产生最多的外部碎片</strong></p>
<p>最坏适应：容量递减。不容易产生碎片，但是浪费空间</p>
<p>临近适应：循环首次适应。</p>
<h3 id="clock算法">CLOCK算法</h3>
<p>（A，M）分别代表（访问位，修改位）</p>
<p>替换顺序为（0，0）、（0，1）、（1，0）、（1，1）</p>
<h3 id="只有fifo会导致bleady异常">只有FIFO会导致Bleady异常</h3>
<h3 id="工作集概念">工作集概念</h3>
<p>t时刻前n个访问的页面去重的结果，所以数量<span class="math inline">\(\le\)</span>n</p>
<h3 id="内核级线程用户级线程">内核级线程、用户级线程</h3>
<h4 id="用户级线程">用户级线程</h4>
<ol type="1">
<li>线程的调度不需要内核直接参与，控制简单。</li>
<li>可以在不支持线程的操作系统中实现。</li>
</ol>
<h4 id="内核级线程">内核级线程</h4>
<ol type="1">
<li>线程在用户态的运行，而线程的调度和管理在内核实现，在控制权从一个线程传送到另一个线程需要用户态到内核态再到用户态的模式切换，比较占用系统资源。</li>
</ol>
<h4 id="区别和联系">区别和联系</h4>
<ol type="1">
<li>内核支持线程是<strong>操作系统</strong>内核可感知的，而用户级线程是OS内核不可感知的。</li>
<li>用户级线程的创建、撤消和调度不需要OS内核的支持。</li>
<li>用户级线程的程序实体是运行在用户态下的程序，而内核支持线程的程序实体则是可以运行在任何状态下的程序。</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/Screen%20Shot%202021-11-15%20at%2016.00.15.png" /></p>
<h3 id="共享段">共享段</h3>
<p>为了实现分段共享，可在系统中配置一张共享段表，所有各共享段都在共享段表中占有一表项。</p>
<p>表项中记录了共享段的段号、段长、内存始址、存在位（是否已调入内存）等信息，并记录了共享此分段的每个进程的情况。</p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/Screen%20Shot%202021-11-15%20at%2016.04.48.png" /></p>
<h3 id="死锁">死锁</h3>
<p>考选择题</p>
<p>死锁预防：破坏 互斥条件、不可剥夺条件、请求并保持条件、循环等待条件</p>
<p>死锁避免：银行家算法</p>
<p>死锁检测：资源分配图</p>
<p>死锁解除：资源剥夺、撤销进程、进程回退</p>
<h3 id="内中断外中断子函数">内中断、外中断、子函数</h3>
<ul>
<li>內中断处理后直接终止，外中断处理后返回原指令执行</li>
<li>内中断发送必须立即处理，外中断在指令周期结束处理</li>
<li>外中断和子函数区别：外中断保存PC和PSW，子函数保存寄存器</li>
<li></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/Screen%20Shot%202021-11-08%20at%2015.53.53.png" /></p>
<h3 id="进程调度算法">进程调度算法</h3>
<p>画表最好算，最方便</p>
<p>不管什么算法，先画下面这个表</p>
<table>
<thead>
<tr class="header">
<th>进程</th>
<th>提交时间（就绪时间）</th>
<th>开始时间</th>
<th>运行时间</th>
<th>结束时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>根据不同算法填表，最后通过表来计算等待时间、周转时间、带权周转时间</p>
<p>例题：</p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/%E6%88%AA%E5%B1%8F2021-10-17%20%E4%B8%8B%E5%8D%888.09.03.png" /></p>
<h4 id="fcfs">FCFS</h4>
<p>太简单，画甘特图都可以解决</p>
<h4 id="短作业优先">短作业优先</h4>
<ol type="1">
<li>根据题目补全信息</li>
</ol>
<table>
<thead>
<tr class="header">
<th>进程</th>
<th>提交时间（就绪时间）</th>
<th>开始时间</th>
<th>运行时间</th>
<th>结束时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td></td>
</tr>
<tr class="even">
<td>2</td>
<td>2</td>
<td></td>
<td>6</td>
<td></td>
</tr>
<tr class="odd">
<td>3</td>
<td>4</td>
<td></td>
<td>4</td>
<td></td>
</tr>
<tr class="even">
<td>4</td>
<td>6</td>
<td></td>
<td>5</td>
<td></td>
</tr>
<tr class="odd">
<td>5</td>
<td>8</td>
<td></td>
<td>2</td>
<td></td>
</tr>
</tbody>
</table>
<ol type="1">
<li>P1来先运行，结束时间为3，将3与提交时间这一列比较，只有P2小于3，所以P2开始时间为3</li>
</ol>
<table>
<thead>
<tr class="header">
<th>进程</th>
<th>提交时间（就绪时间）</th>
<th>开始时间</th>
<th>运行时间</th>
<th>结束时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td><strong>3</strong></td>
</tr>
<tr class="even">
<td>2</td>
<td>2</td>
<td><strong>3</strong></td>
<td>6</td>
<td></td>
</tr>
<tr class="odd">
<td>3</td>
<td>4</td>
<td></td>
<td>4</td>
<td></td>
</tr>
<tr class="even">
<td>4</td>
<td>6</td>
<td></td>
<td>5</td>
<td></td>
</tr>
<tr class="odd">
<td>5</td>
<td>8</td>
<td></td>
<td>2</td>
<td></td>
</tr>
</tbody>
</table>
<ol start="2" type="1">
<li>P2结束时间为3+6=9， 将9与提交时间这一列比较，发现都小于9，找到除结束进程外运行时间最小的进程，为P5，所以P5开始时间为9</li>
</ol>
<table>
<thead>
<tr class="header">
<th>进程</th>
<th>提交时间（就绪时间）</th>
<th>开始时间</th>
<th>运行时间</th>
<th>结束时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>3</td>
</tr>
<tr class="even">
<td>2</td>
<td>2</td>
<td>3</td>
<td>6</td>
<td><strong>9</strong></td>
</tr>
<tr class="odd">
<td>3</td>
<td>4</td>
<td></td>
<td>4</td>
<td></td>
</tr>
<tr class="even">
<td>4</td>
<td>6</td>
<td></td>
<td>5</td>
<td></td>
</tr>
<tr class="odd">
<td>5</td>
<td>8</td>
<td><strong>9</strong></td>
<td>2</td>
<td></td>
</tr>
</tbody>
</table>
<ol start="3" type="1">
<li>P5结束时间为9+2=11，因为现在知道所有进程都到了，直接找到运行时间最小的P3，所以P3开始时间为11，其余的也可以填出来</li>
</ol>
<table>
<thead>
<tr class="header">
<th>进程</th>
<th>提交时间（就绪时间）</th>
<th>开始时间</th>
<th>运行时间</th>
<th>结束时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>3</td>
</tr>
<tr class="even">
<td>2</td>
<td>2</td>
<td>3</td>
<td>6</td>
<td>9</td>
</tr>
<tr class="odd">
<td>3</td>
<td>4</td>
<td><strong>11</strong></td>
<td>4</td>
<td><strong>15</strong></td>
</tr>
<tr class="even">
<td>4</td>
<td>6</td>
<td><strong>15</strong></td>
<td>5</td>
<td><strong>20</strong></td>
</tr>
<tr class="odd">
<td>5</td>
<td>8</td>
<td>9</td>
<td>2</td>
<td><strong>11</strong></td>
</tr>
</tbody>
</table>
<ol start="4" type="1">
<li><p>根据这个表计算</p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/IMG_A24FDAA9C2AB-1.jpeg" /></p>
<p>等待时间 = 开始-就绪=周转-运行</p>
<p>周转时间 = 结束-就绪</p>
<p>带权周转时间 = 周转时间/运行时间</p></li>
</ol>
<table>
<thead>
<tr class="header">
<th>进程</th>
<th>提交时间（就绪时间）</th>
<th>开始时间</th>
<th>运行时间</th>
<th>结束时间</th>
<th>等待时间</th>
<th>周转时间</th>
<th>带权周转时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>3</td>
<td>0</td>
<td>3</td>
<td>3/3</td>
</tr>
<tr class="even">
<td>2</td>
<td>2</td>
<td>3</td>
<td>6</td>
<td>9</td>
<td>1</td>
<td>7</td>
<td>7/6</td>
</tr>
<tr class="odd">
<td>3</td>
<td>4</td>
<td>11</td>
<td>4</td>
<td>15</td>
<td>7</td>
<td>11</td>
<td>11/4</td>
</tr>
<tr class="even">
<td>4</td>
<td>6</td>
<td>15</td>
<td>5</td>
<td>20</td>
<td>9</td>
<td>14</td>
<td>14/5</td>
</tr>
<tr class="odd">
<td>5</td>
<td>8</td>
<td>9</td>
<td>2</td>
<td>11</td>
<td>1</td>
<td>3</td>
<td>3/2</td>
</tr>
</tbody>
</table>
<h4 id="高响应比优先">高响应比优先</h4>
<p><span class="math display">\[
响应比 = \frac{等待时间+运行时间}{运行时间}
\]</span></p>
<p>仿照上面的方法，<strong>但是每次进程结束都需要计算一次响应比</strong></p>
<table>
<thead>
<tr class="header">
<th>进程</th>
<th>提交时间（就绪时间）</th>
<th>开始时间</th>
<th>运行时间</th>
<th>结束时间</th>
<th>等待时间</th>
<th>周转时间</th>
<th>带权周转时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>3</td>
<td>0</td>
<td>3</td>
<td>3/3</td>
</tr>
<tr class="even">
<td>2</td>
<td>2</td>
<td>3</td>
<td>6</td>
<td>9</td>
<td>1</td>
<td>7</td>
<td>7/6</td>
</tr>
<tr class="odd">
<td>3</td>
<td>4</td>
<td>9</td>
<td>4</td>
<td>13</td>
<td>5</td>
<td>9</td>
<td>9/4</td>
</tr>
<tr class="even">
<td>4</td>
<td>6</td>
<td>15</td>
<td>5</td>
<td>20</td>
<td>9</td>
<td>14</td>
<td>14/5</td>
</tr>
<tr class="odd">
<td>5</td>
<td>8</td>
<td>13</td>
<td>2</td>
<td>15</td>
<td>5</td>
<td>7</td>
<td>7/2</td>
</tr>
</tbody>
</table>
<h3 id="openread系统调用">open、read系统调用</h3>
<ol type="1">
<li>open根据（路径、文件名）找到相应的目录文件，从目录中找到文件名对应的目录项，并检查权限</li>
<li>将目录项复制到内存中的打开文件表，返回表目对应的编号，用户使用这个编号来指明要操作的文件</li>
<li>read根据（文件描述符、buf缓冲区地址、字节数）从fd的位置读数据</li>
</ol>
<h3 id="进程资源图简化判断死锁">进程资源图简化，判断死锁</h3>
<p><a href="https://blog.csdn.net/coding1994/article/details/52474731">资源分配图化简法</a></p>
<h3 id="大端小端">大端小端</h3>
<p>人看的是大端，机器存的是小端。（<strong>小机</strong>）</p>
<p>小端：12 34 56，12存储在低位。大端相反。</p>
<h3 id="分页确定逻辑地址结构">分页确定逻辑地址结构</h3>
<ul>
<li><p>虚拟存储器最大容量：看MAR有多少位</p></li>
<li><p>页号+页内偏移。页号包括页表索引</p></li>
<li><p>多级页表逻辑地址确定：</p>
<p>页内偏移由页大小决定</p>
<p>最高一级页表位数不能超过<strong>log(一页的页表项数)</strong>，其他级的位数都为<strong>log(一页的页表项数)</strong></p>
<p>eg：48位虚地址，页面大小为4KB，页表项大小为8B</p>
<p>页面大小为4KB，所以页面偏移为12，一页的页表项数 = <span class="math inline">\(4KB/8B = 2^{9}\)</span>，剩下的48-12=36位按每级9位分配，36/9=4，所以4级</p></li>
<li><p>cache组相连映射确定地址结构：</p>
<p>标记+组号+偏移</p>
<p>偏移由页大小确定，组号由组数确定，组数=cache条数/m路，剩下的是标记</p></li>
</ul>
<h3 id="tlb页表cache">TLB、页表、cache</h3>
<p>cpu根据虚拟地址中的虚拟页号去TLB中找页，若存在将虚拟地址转换为物理地址。根据物理地址去cache中找块，若找到无需到主存中找。</p>
<ul>
<li>页表是为了实现虚拟内存，完成对<strong>内存</strong>的扩容。cache是为了解决cpu与主存速度不匹配的问题</li>
<li>缺页要从<strong>磁盘</strong>中取出<strong>页</strong>到内存，cache不命中要从<strong>主存</strong>去取出<strong>块</strong>到cache。因此缺页开销更大</li>
<li>TLB表项为虚拟页号+物理页号（主存）。cache表项为标记+数据。快表是慢表的一个副本，结构一样。cache中存放了数据，因此取数时最少访问主存0次。</li>
</ul>
<h2 id="数据结构">数据结构</h2>
<ul>
<li>双链表、静态链表</li>
<li>共享栈</li>
</ul>
<h3 id="折半查找判定树画法">折半查找判定树画法</h3>
<p><a href="https://blog.csdn.net/BlevMeM/article/details/84672731">数据结构学习记录（二）——折半查找二叉判定树的画法</a></p>
<p>原则：若向上取整，说明分界点在右边，右子树节点数<span class="math inline">\(\le\)</span>左子树节点数，向上取整则反</p>
<ol type="1">
<li>先画满二叉树，再一个一个加节点，要按照上面的原则</li>
<li>按中序遍历填入从小到大的数字</li>
</ol>
<ul>
<li>对一个序列进行折半查找，问查找到某个数字需要找几次，用表的长度判断，而不是数字的值</li>
</ul>
<h3 id="kmp">KMP</h3>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/Screen%20Shot%202021-11-15%20at%2015.28.57.png" /></p>
<ol type="1">
<li>计算next数组</li>
</ol>
<p>​ next数组前两个为-1，0，后面的按照后缀长度填</p>
<p>​ 如abaabc的next数组</p>
<table>
<thead>
<tr class="header">
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>a</td>
<td>ab</td>
<td>aba</td>
<td>abaa</td>
<td>abaab</td>
<td>abaabc</td>
</tr>
<tr class="even">
<td>-1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
<ol start="2" type="1">
<li>i指向主串不回退，j指向模式串，比较到abaabc发现不同，将j从5改为2，此时i=5，j=2</li>
<li>比较4次完成匹配。</li>
<li>总比较次数为6+4</li>
</ol>
<h3 id="中缀表达式转后缀表达式">中缀表达式转后缀表达式</h3>
<p><a href="https://blog.csdn.net/sgbfblog/article/details/8001651">中缀表达式转换为后缀表达式_</a></p>
<ol type="1">
<li>（直接入栈</li>
<li>其他符号入栈时要保证自己比栈顶元素优先级高</li>
<li>遇到）全部出栈，直到把（出栈</li>
</ol>
<h3 id="wpl">WPL</h3>
<p>定义要搞清楚：所有<strong>叶节点</strong>的带权路径之和</p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/Screen%20Shot%202021-11-07%20at%2019.03.44.png" /></p>
<h3 id="循环队列">循环队列</h3>
<h4 id="顺序表示">顺序表示</h4>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/%E6%88%AA%E5%B1%8F2021-10-06%20%E4%B8%8B%E5%8D%888.51.14.png" /></p>
<p>牺牲额外一块空间。</p>
<p>空条件：front == rear</p>
<p>满条件：front == (rear+1)%maxsize</p>
<p>元素个数：(rear-front+maxsize)%maxsize</p>
<h4 id="链式表示">链式表示</h4>
<p>初始状态：</p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/Screen%20Shot%202021-11-16%20at%2014.44.44.png" /></p>
<p>从尾部插入：</p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/Screen%20Shot%202021-11-16%20at%2014.45.08.png" /></p>
<p>判空：front==rear</p>
<p>判满：rear-&gt;next = front</p>
<ul>
<li>栈括号匹配</li>
<li>栈递归应用</li>
<li>栈层次遍历</li>
</ul>
<h3 id="树和森林的遍历">树和森林的遍历</h3>
<table>
<thead>
<tr class="header">
<th>树</th>
<th>森林</th>
<th>二叉树</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>先根</td>
<td>先序</td>
<td>先序</td>
</tr>
<tr class="even">
<td>后根</td>
<td>中序</td>
<td>中序</td>
</tr>
</tbody>
</table>
<h3 id="b树插入删除高度">B树插入、删除、高度</h3>
<p>高度：看树、二叉树性质那一篇笔记</p>
<p>插入：大于最大关键字树则分裂，可能会导致父节点也分裂</p>
<p>删除：</p>
<ol type="1">
<li>直接删除</li>
<li>兄弟够借：若被删除节点右（左）兄弟够借，先将共同父亲放入被删除节点，再把右（左）兄弟的最左（右）边的孩子放入父节点。</li>
<li>不够借：被删除节点左右兄弟都不够借，则与父节点交换然后与兄弟合并。</li>
</ol>
<h3 id="排序二叉树平衡二叉树"><strong>排序二叉树——平衡二叉树</strong></h3>
<p>平衡二叉树是特殊的排序二叉树</p>
<p>删除操作与排序二叉树一样：</p>
<ol type="1">
<li>叶节点直接删除</li>
<li>如果只有一个子树，用子树替代</li>
<li>如果有两个子树，用直接后继替代，然后删除直接后继</li>
</ol>
<p>平衡二叉树插入操作：</p>
<p>RL LR LL RR</p>
<ul>
<li><strong>二叉搜索树</strong></li>
</ul>
<h3 id="哈夫曼树构造前缀性质"><strong>哈夫曼树：构造、前缀、性质</strong></h3>
<p>性质：只能度为0和2的节点</p>
<h3 id="邻接矩阵邻接表邻接多重表十字链表定义和画法">邻接矩阵、邻接表、邻接多重表、十字链表定义和画法</h3>
<p><strong>邻接矩阵</strong></p>
<p>顶点表是一维数组，边表是二维数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> Vex[vNum];		<span class="comment">//  定点可以是char型、int型</span></span><br><span class="line">  <span class="keyword">int</span> Edge[vNum][vNum];	<span class="comment">// 1代表有边</span></span><br><span class="line">  <span class="keyword">int</span> vexnum, arcnmum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>邻接表</strong></p>
<p>分为顶点节点和边表节点，每个顶点节点是一个单链表，连接着与这个顶点相连的边节点（有向图则与出边相连）</p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/20130429141926037.jpg" /></p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> Vex;</span><br><span class="line">  ArcNode* first;</span><br><span class="line">&#125;VNode, AdjList[Vnum];</span><br><span class="line"><span class="comment">// VNode AdjList[Vnum];		//   邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> Vex;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  AdjList vertices;</span><br><span class="line">  <span class="keyword">int</span> vexnum, arcnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>十字链表</strong></p>
<p>十字链表是<strong>有向图</strong>的链式存储</p>
<p>顶点节点：</p>
<ul>
<li>data：顶点符号/编号</li>
<li>firstin：第一个入边</li>
<li>firstout：第一个出边</li>
</ul>
<p>弧节点：</p>
<ul>
<li>tailvex：弧尾节点，若一条弧从1指向4，则弧尾节点为1</li>
<li>headvex：弧头节点，若一条弧从1指向4，则弧尾节点为4</li>
<li>hlink：下一条弧头节点相同的弧</li>
<li>tlink：下一条弧尾节点相同的弧</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/1358881-20181120114948819-61490260.png" /></p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/1358881-20181120114814046-2079914035.png" /> 十字链表画法：先画同一行（弧尾相同)，再垂直连接弧头相同的边，最后连接顶点的第一个入边弧并补全空符号。</p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E7%94%BB%E6%B3%952.jpg" /></p>
<p><strong>邻接多重表</strong></p>
<p>是<strong>无向图</strong>的链式表示，无向图的邻接矩阵中，一条边要占2个格子，删除的时候需要分别修改两个位，邻接多重表中有几条边就有几个弧节点。</p>
<p>顶点节点：</p>
<ul>
<li>data：顶点符号</li>
<li>firstedge：第一条边（一般是序号最小）</li>
</ul>
<p>弧节点：</p>
<ul>
<li>ivex，若一条弧连接0-1，ivex为0</li>
<li>ilink，与ivex相连的下一条弧</li>
<li>jvex，若一条弧连接0-1，jvex为1</li>
<li>jlink，与jvex相连的下一条弧</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/%E6%88%AA%E5%B1%8F2021-10-05%20%E4%B8%8B%E5%8D%8810.05.08.png" /></p>
<ul>
<li>DFS、BFS</li>
</ul>
<h3 id="最小生成树mstprim算法kruskal算法">最小生成树MST：Prim算法、Kruskal算法</h3>
<p>Prim（选点，Point，PP）：任选初始点，选择与此点<strong>相连</strong>边中权值最小的边，不断重复，<strong>直到将所有点加入</strong>。复杂度<span class="math inline">\(O(V^2)\)</span></p>
<p>Kruskal（选边）：不断选择权值最小的边，<strong>直到连通分量为</strong>1。因为用最小堆实现每次选择最小的边，所以复杂度<span class="math inline">\(O(Elog_2(E))\)</span></p>
<p>最小生成树唯一的条件：所有边的权值不同</p>
<h3 id="最短路径dfsdijkstra算法floyd算法">最短路径：DFS、Dijkstra算法、Floyd算法</h3>
<p>都不考算法，只需要会手动模拟</p>
<p>Dijkstra https://www.bilibili.com/video/BV1zz4y1m7Nq</p>
<p>floyd https://www.bilibili.com/video/BV16w411o76v</p>
<ol type="1">
<li><p>十字区域照抄</p></li>
<li><p>十字区域中含∞的行或列照抄</p></li>
<li><p>对角线都是0</p></li>
<li><p>剩余部分，比较对应红色部分的行与列值之和 and 原值的大小，谁小取谁</p></li>
<li><p>剩余部分若不是原值，下标就是红色区域的行与列下标合并去重</p></li>
</ol>
<h3 id="拓扑排序">拓扑排序</h3>
<p>结合工程背景，用节点表示先后顺序。选择某种数据结构，基于该数据结构来解决问题。eg：工厂流水线</p>
<p>拓扑序列：陆续删除入度为0的节点。</p>
<p>有可能考算法：indegree数组 or DFS</p>
<p>indegree实现法：</p>
<ol type="1">
<li>用邻接表实现简单</li>
<li>遍历所有边，统计每个顶点的入度并存储在 <code>indgree</code> 中</li>
<li>将所有入度为0的点入栈</li>
<li>栈顶元素出栈，遍历其所有出边（这里用邻接矩阵方便），将出边指向的顶点入度-1，入度为0则进栈</li>
<li>栈为空停止，此时如果还有顶点未输出则有<strong>回路</strong></li>
</ol>
<h4 id="关键路径aoe网">关键路径：AOE网</h4>
<p>若只需要知道关键路径可以看：<a href="https://www.bilibili.com/video/BV1Fq4y1X7Tb">求解关键路径</a></p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/2313asdas.png" /></p>
<p>最早发生ve：从前往后，选择大的。对于V4: 3+2 &lt; 2+4，所以ve(4) =6</p>
<p>最晚发生vl：从后往前，选择小的。对于V2: 7-3&gt;6-2，所以vl(2)=4</p>
<p>最早开始e：对于图中的边a3，从V2指向V4，因此e(3) = ve(2) = 3</p>
<p>最晚开始l：对于图中的边a3，从V2指向V4，因此l(3) = vl(4) - we ight = 6-2=4</p>
<h4 id="哈希算法">哈希算法</h4>
<p>开放定址法：线性探测+0，+1…+n。平方探测：<span class="math inline">\(0^2, 1, -1, 2^2, -2^2...\)</span>。再散列</p>
<p>拉链法：掌握存储结构，类似于孩子表示法（顺序表+链表）。定义结构，实现插入、删除、查找。</p>
<p><a href="http://data.biancheng.net/view/30.html">树的双亲表示法、孩子表示法和孩子兄弟表示法 (biancheng.net)</a></p>
<p>成功/失败查找长度。装填因子。</p>
<ul>
<li>查找算法</li>
<li>排序算法</li>
</ul>
<h3 id="堆的插入删除">堆的插入删除</h3>
<p>建立：从最后一个分支节点，往前调整每个分支节点</p>
<p>插入：从下往上调整，只调整插入节点到根节点这个子树</p>
<p>删除：从上往下调整，调整根节点</p>
<h2 id="计算机网络">计算机网络</h2>
<h3 id="物理层编码">物理层编码</h3>
<ul>
<li>以太网使用曼彻斯特编码</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/Screen%20Shot%202021-11-08%20at%2016.04.40.png" /></p>
<h3 id="极限传输速率">极限传输速率</h3>
<p>无噪声，奈氏定理<span class="math inline">\(V = 2f \times log_{2}N\)</span>，f为带宽</p>
<p>有噪声，香农<span class="math inline">\(V = Wlog_2(1+\frac{S}{N})\)</span> W为带宽，S/N为信噪比</p>
<blockquote>
<p>带宽单位为MHz，为最高频率-最低频率</p>
<p>若给出信噪比为30dB，需要将其转换为S/N，关系是<span class="math inline">\(30 = 10log_{10}1000\)</span>,所以S/N=1000</p>
</blockquote>
<p>eg：一个传输数字信号的模拟信道的功率是0.62W，噪声功率是0.02W，频率范围是3.5～3.9MHz，该信道最高数据传输率是：</p>
<p>有噪声，用香农公式，带宽为0.4MHz，<span class="math inline">\(V = 0.4 \times log_2(1+31) = 2Mbps\)</span></p>
<h3 id="cdma">CDMA</h3>
<p>真实数据 = <strong>码片序列</strong> 与 <strong>叠加的序列</strong>的内积。</p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/Screen%20Shot%202021-11-07%20at%2018.44.42.png" /></p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/Screen%20Shot%202021-11-07%20at%2018.45.24.png" /></p>
<h3 id="gbn最大传送速率">GBN最大传送速率</h3>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/Screen%20Shot%202021-11-07%20at%2018.40.34.png" /></p>
<p>GBN在接收到一次确认帧之前可以发N个帧。</p>
<p>此题发送一个确认帧时间为50x2=100ms，N个帧大小为1000x1000B=1MB，1MB/100ms=80Mbps</p>
<h3 id="有效数据率-信道利用">有效数据率, 信道利用</h3>
<ul>
<li><p>帧大小：L</p></li>
<li><p>两主机间单向传播时间：t，则RTT为2t</p></li>
<li><p>信道带宽/数据传输率：M</p></li>
<li><p>发送周期：<span class="math inline">\(T = \frac{L}{M} + 2t + 确认帧发送时间\)</span>​​</p></li>
</ul>
<blockquote>
<p>如果题目忽略确认帧发送时间就不算括号内的，如果题目中说确认帧由数据帧捎带，意思是确认帧的发送时间和数据帧发送时间一样为<span class="math inline">\(\frac{L}{M}\)</span>​, 王道P81</p>
<p>发送周期：从开始发送<strong>第一个</strong>帧开始到收到<strong>第一个</strong>确认帧的时间，不是所有的</p>
</blockquote>
<p>信道利用率=数据发送时间/发送周期</p>
<p>信道吞吐率=发送速率x信道利用率</p>
<p>例题：若最大帧长1000B，用3bit编号，RTT=0.96ms，信道传输率为100Mb/s，捎带确认，求最大信道利用率</p>
<p>​ 3bit编号，发送窗口最大为8-1=7，所以一次最多发7000B</p>
<p>​ 发送周期=发送时间+传输时间+确认帧发送时间=<span class="math inline">\(\frac{1000B}{100Mb/s} + 0.96 + \frac{1000B}{100Mb/s}\)</span></p>
<p>​ 数据发送时间=<span class="math inline">\(7 \times \frac{1000B}{100Mb/s}\)</span></p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/IMG_359FD85BD012-1.jpeg" /></p>
<p>设数据帧长度=x，数据传输时间=<span class="math inline">\(\frac{x}{3kbps}\)</span>，信道利用率=<span class="math inline">\(\frac{x/3k}{200ms \times 2 + x/3k}=0.4\)</span>解得x=800bit</p>
<h3 id="吞吐量">吞吐量</h3>
<p><span class="math display">\[
吞吐量 = \frac{窗口大小}{RTT+发送时间+确认时间}
\]</span></p>
<h4 id="csmacd">CSMA/CD</h4>
<p><strong>截断二进制指数退让算法：</strong></p>
<ol type="1">
<li>确定基本退让时间<span class="math inline">\(2\tau\)</span></li>
<li><span class="math inline">\(k = min[重传次数, 10]\)</span></li>
<li>从<span class="math inline">\([0, 1, …, 2^k-1]\)</span>中选一个数<span class="math inline">\(r\)</span>，退避时间为<span class="math inline">\(r.2\tau\)</span></li>
<li>重传16次抛弃此帧</li>
</ol>
<p><strong>最小帧长：</strong><span class="math inline">\(总线传播时延 \times 数据传输率 \times 2 = 2\tau v\)</span></p>
<blockquote>
<p>注意传播和传输的区别，数据大小/传输速率=发送时延</p>
</blockquote>
<ul>
<li>以太网规定最短帧长为64B，凡长度小于64B的都是由于冲突而异常终止的无效帧</li>
</ul>
<h3 id="ip数据报">IP数据报</h3>
<p>分片后<strong>改变的字段：</strong></p>
<ul>
<li>标志位FLAG的MF、DF</li>
<li>总长度，总长度是分片后的首部长度和数据长度之和</li>
<li>首部校验和，首部发生改变，校验和也发生改变</li>
</ul>
<p>经过路由器TTL改变</p>
<p>若采用NAT，则源IP地址改变。其他情况IP均不变</p>
<h3 id="arp建立过程">ARP建立过程</h3>
<ol type="1">
<li>检查ARP缓存，有对应表项写入MAC帧，没有则用目的地址为FF-FF-FF-FF-FF-FF(6B)发送广播ARP请求</li>
<li>目的主机接收到请求会向源主机<strong>单播</strong>一个ARP相应分组</li>
<li>源主机收到后写入ARP缓存</li>
</ol>
<h3 id="路由表建立过程">路由表建立过程</h3>
<p>建立方法：静态路由、动态路由（RIP、OSPF）</p>
<ul>
<li>表项：目的网络地址、子网掩码、下一跳<strong>IP地址</strong>、接口</li>
<li>注意：默认路由的目的网络和子网掩码为0.0.0.0（如果用CIDR表示为0.0.0.0/0），下一跳IP地址为连接互联网的路由器IP</li>
<li>主机路由（特定路由）的子网掩码为全1，255.255.255.255</li>
</ul>
<h3 id="dhcp过程">DHCP过程</h3>
<ol type="1">
<li>主机广播DHCP<strong>发现</strong>消息，<strong>源IP为0.0.0.0，目的IP为255.255.255.255</strong></li>
<li>DHCP服务器广播DHCP<strong>提供</strong>消息</li>
<li>主机收到消息，广播DHCP<strong>请求</strong>消息</li>
<li>服务器广播DHCP<strong>确认</strong>消息</li>
</ol>
<h3 id="距离向量算法">距离向量算法</h3>
<p>更新策略</p>
<ol type="1">
<li>新网络更新</li>
<li>到<strong>相邻路由器</strong>的跳数变化也更新</li>
<li>到其他网络跳数变短更新，否则不更新</li>
</ol>
<p><strong>坏消息传得慢</strong>，若与R2相邻的网络不可达时，R2通知相邻的R1，R1会把到网络的距离+1，告诉R2，这样来回直到为16</p>
<h3 id="数据帧发送过程中地址变化">数据帧发送过程中地址变化</h3>
<p><strong>路由器转发后</strong>，将数据帧的源MAC地址改为路由器的MAC地址，目的MAC地址不变</p>
<p>IP地址不变。但当使用NAT是源IP改变</p>
<p>mac帧的目的mac地址和源mac地址在转发过程中都会发生改变</p>
<p><img data-src="https://raw.githubusercontent.com/baichen99/pics/master/img/Screen%20Shot%202021-11-12%20at%2015.59.31.png" /></p>
<h3 id="gbn和tcp区分">GBN和TCP区分</h3>
<ul>
<li>GBN中<span class="math inline">\(ACK_n\)</span>表示对n号帧的确认，期望收到n+1号帧</li>
<li>TCP中<span class="math inline">\(ack_n\)</span>表示对n-1号帧的确认，期望收到n号帧</li>
</ul>
<p>在GBN中，发送方需要重发出错帧及之后的帧</p>
<p>GBN中一个窗口包含一个帧，TCP一个窗口为一个MSS</p>
<p>要注意区分GBN、SR、TCP协议的确认机制:</p>
<ol type="1">
<li><p>GBN和TCP都采用累计确认机制，SR协议不是</p></li>
<li><p>关于ACK序号的问题:</p>
<ol type="i">
<li><p>GBN:ACK N表示N及其之前的都正确接收</p></li>
<li><p>SR:ACK N表示正确接收N号帧</p></li>
<li><p>TCP:ACK N表示期待收到N号帧</p></li>
</ol></li>
</ol>
<h3 id="慢开始拥塞避免快恢复快重传区分">慢开始、拥塞避免、快恢复、快重传区分</h3>
<ul>
<li>慢开始、快恢复：当遇到<strong>超时</strong>执行慢开始即窗口设为1，sshthresh/=2</li>
<li>当连续收到三个重复确认执行快恢复，窗口/=2，sshtresh/=2</li>
<li>拥塞避免按线性增长</li>
</ul>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>作文模板</title>
    <url>/2021/11/10/muban/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="话题引起"><a href="#话题引起" class="headerlink" title="话题引起"></a>话题引起</h3><ol>
<li>The bar chart above present 主题</li>
<li>The line chart shows the ascending/ tendency of 主题</li>
</ol>
<h3 id="图表描述"><a href="#图表描述" class="headerlink" title="图表描述"></a>图表描述</h3><ol>
<li>To put it more precise，描述变化或占比</li>
<li>静态图描述占比：the proportion of xxx in 2013 was 33% compared to 25% in 2008, showing an increase of 8%.</li>
<li>“分别占用”  the percentage of A B C is a b c respectively.</li>
<li>描述变化：the number of museums in China increased steadily from xx in 2013 to xx in 2015.</li>
<li>描述最值：</li>
</ol>
<h3 id="图表总结"><a href="#图表总结" class="headerlink" title="图表总结"></a>图表总结</h3><ol>
<li>As a matter of fact, what author tries to tell us is more than statistics.</li>
<li>Isolated as the figures seem to be, as a matter of fact, they are connected to one another closely.</li>
</ol>
<h3 id="具体意义"><a href="#具体意义" class="headerlink" title="具体意义"></a>具体意义</h3><ol>
<li>In fact, this chart is a miniature of a prevalent phenomenon. An incresing number of customers choose …</li>
<li>In fact, this chart is a miniature of contemporary society.</li>
<li>The table leads us to find out what causes the …</li>
</ol>
<h3 id="意义论证"><a href="#意义论证" class="headerlink" title="意义论证"></a>意义论证</h3><ol>
<li>I can find no better reasons than the following ones./There are many reasons for this phenomenon.<ol>
<li>On one hand./To begin with/For one thing</li>
<li>On the other hand./Furthermore/For another</li>
</ol>
</li>
</ol>
<ul>
<li>leads to/result in </li>
<li></li>
</ul>
<h3 id="意义总结"><a href="#意义总结" class="headerlink" title="意义总结"></a>意义总结</h3><ol>
<li>（正面/中立）As a consequence/result</li>
<li>（负面）If we keep turing a blind eye to it, the problem above will generate severe consequences. For example,..</li>
</ol>
<h3 id="结尾段"><a href="#结尾段" class="headerlink" title="结尾段"></a>结尾段</h3><h4 id="引言-结论"><a href="#引言-结论" class="headerlink" title="引言+结论"></a>引言+结论</h4><ol>
<li>Considering every aspect of this phenomenon, I, as most of others will do, safely draw a conclusion that…,it requires a xxx</li>
</ol>
<h4 id="总结-建议-憧憬"><a href="#总结-建议-憧憬" class="headerlink" title="总结+建议+憧憬"></a>总结+建议+憧憬</h4><ol>
<li>Considering every aspect of this phenonmenon, we should bear in mind that … ,   we should xxx, Only in this way can we meet a brighter furture.</li>
<li>两面：xx could prive to be a double-edged sword. Therefore, we must absorb the essence and neglect the drawbacks. Only in this way can we ….</li>
<li>中立： No matter what the reason, one thing is certian that there is a growing tendency xxx, which I believe will not change in a short time.</li>
</ol>
]]></content>
      <categories>
        <category>作文</category>
      </categories>
      <tags>
        <tag>作文</tag>
      </tags>
  </entry>
</search>
